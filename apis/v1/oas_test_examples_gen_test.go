// Code generated by ogen, DO NOT EDIT.

package v1

import (
	"fmt"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/validate"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestAvailability_EncodeDecode(t *testing.T) {
	var typ Availability
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Availability
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBadRequestResponse_EncodeDecode(t *testing.T) {
	var typ BadRequestResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BadRequestResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestConflictResponse_EncodeDecode(t *testing.T) {
	var typ ConflictResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ConflictResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetParameterResponse_EncodeDecode(t *testing.T) {
	var typ GetParameterResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetParameterResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetParameterResponseNosql_EncodeDecode(t *testing.T) {
	var typ GetParameterResponseNosql
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetParameterResponseNosql
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInstance_EncodeDecode(t *testing.T) {
	var typ Instance
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Instance
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInstanceHost_EncodeDecode(t *testing.T) {
	var typ InstanceHost
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InstanceHost
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInstanceHostsItem_EncodeDecode(t *testing.T) {
	var typ InstanceHostsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InstanceHostsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIsOk_EncodeDecode(t *testing.T) {
	var typ IsOk
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IsOk
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlAppliance_EncodeDecode(t *testing.T) {
	var typ NosqlAppliance
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlAppliance
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlApplianceDisk_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceDisk
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceDisk
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlApplianceInterfacesItem_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceInterfacesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceInterfacesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlApplianceInterfacesItemSwitch_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceInterfacesItemSwitch
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceInterfacesItemSwitch
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlApplianceInterfacesItemSwitchSubnet_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceInterfacesItemSwitchSubnet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceInterfacesItemSwitchSubnet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlApplianceInterfacesItemSwitchSubnetInternet_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceInterfacesItemSwitchSubnetInternet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceInterfacesItemSwitchSubnetInternet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlApplianceInterfacesItemSwitchUserSubnet_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceInterfacesItemSwitchUserSubnet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceInterfacesItemSwitchUserSubnet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlApplianceRemark_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceRemark
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceRemark
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlApplianceRemarkNosql_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceRemarkNosql
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceRemarkNosql
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlApplianceRemarkNosqlDatabaseEngine_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceRemarkNosqlDatabaseEngine
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceRemarkNosqlDatabaseEngine
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNosqlApplianceRemarkNosqlDatabaseEngine_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"Cassandra\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NosqlApplianceRemarkNosqlDatabaseEngine

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NosqlApplianceRemarkNosqlDatabaseEngine
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNosqlApplianceRemarkNosqlDiskSize_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceRemarkNosqlDiskSize
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceRemarkNosqlDiskSize
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNosqlApplianceRemarkNosqlDiskSize_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "102400"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NosqlApplianceRemarkNosqlDiskSize

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NosqlApplianceRemarkNosqlDiskSize
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNosqlApplianceRemarkNosqlMemory_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceRemarkNosqlMemory
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceRemarkNosqlMemory
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNosqlApplianceRemarkNosqlMemory_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "8192"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NosqlApplianceRemarkNosqlMemory

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NosqlApplianceRemarkNosqlMemory
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNosqlApplianceRemarkNosqlStorage_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceRemarkNosqlStorage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceRemarkNosqlStorage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNosqlApplianceRemarkNosqlStorage_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"SSD\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NosqlApplianceRemarkNosqlStorage

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NosqlApplianceRemarkNosqlStorage
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNosqlApplianceRemarkNosqlVirtualcore_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceRemarkNosqlVirtualcore
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceRemarkNosqlVirtualcore
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNosqlApplianceRemarkNosqlVirtualcore_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "3"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NosqlApplianceRemarkNosqlVirtualcore

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NosqlApplianceRemarkNosqlVirtualcore
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNosqlApplianceRemarkServersItem_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceRemarkServersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceRemarkServersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlApplianceRemarkZone_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceRemarkZone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceRemarkZone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlBackup_EncodeDecode(t *testing.T) {
	var typ NosqlBackup
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlBackup
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlBackupResponse_EncodeDecode(t *testing.T) {
	var typ NosqlBackupResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlBackupResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlBackupResponseNosql_EncodeDecode(t *testing.T) {
	var typ NosqlBackupResponseNosql
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlBackupResponseNosql
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateRequest_EncodeDecode(t *testing.T) {
	var typ NosqlCreateRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateRequestAppliance_EncodeDecode(t *testing.T) {
	var typ NosqlCreateRequestAppliance
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateRequestAppliance
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateRequestApplianceSettings_EncodeDecode(t *testing.T) {
	var typ NosqlCreateRequestApplianceSettings
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateRequestApplianceSettings
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateRequestApplianceSettingsBackup_EncodeDecode(t *testing.T) {
	var typ NosqlCreateRequestApplianceSettingsBackup
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateRequestApplianceSettingsBackup
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateRequestApplianceSettingsBackupDayOfWeekItem_EncodeDecode(t *testing.T) {
	var typ NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateRequestApplianceUserInterfacesItem_EncodeDecode(t *testing.T) {
	var typ NosqlCreateRequestApplianceUserInterfacesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateRequestApplianceUserInterfacesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateRequestApplianceUserInterfacesItemSwitch_EncodeDecode(t *testing.T) {
	var typ NosqlCreateRequestApplianceUserInterfacesItemSwitch
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateRequestApplianceUserInterfacesItemSwitch
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateRequestApplianceUserInterfacesItemUserSubnet_EncodeDecode(t *testing.T) {
	var typ NosqlCreateRequestApplianceUserInterfacesItemUserSubnet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateRequestApplianceUserInterfacesItemUserSubnet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateResponse_EncodeDecode(t *testing.T) {
	var typ NosqlCreateResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateResponseAccount_EncodeDecode(t *testing.T) {
	var typ NosqlCreateResponseAccount
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateResponseAccount
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateResponseHiddenRemark_EncodeDecode(t *testing.T) {
	var typ NosqlCreateResponseHiddenRemark
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateResponseHiddenRemark
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateResponseHiddenRemarkEncripted_EncodeDecode(t *testing.T) {
	var typ NosqlCreateResponseHiddenRemarkEncripted
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateResponseHiddenRemarkEncripted
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateResponseHiddenRemarkPlanSpec_EncodeDecode(t *testing.T) {
	var typ NosqlCreateResponseHiddenRemarkPlanSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateResponseHiddenRemarkPlanSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateResponseHiddenRemarkPlanSpecNote_EncodeDecode(t *testing.T) {
	var typ NosqlCreateResponseHiddenRemarkPlanSpecNote
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateResponseHiddenRemarkPlanSpecNote
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlGetParameter_EncodeDecode(t *testing.T) {
	var typ NosqlGetParameter
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlGetParameter
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlGetResponse_EncodeDecode(t *testing.T) {
	var typ NosqlGetResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlGetResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlGetVersionResponse_EncodeDecode(t *testing.T) {
	var typ NosqlGetVersionResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlGetVersionResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlGetVersionResponseNosql_EncodeDecode(t *testing.T) {
	var typ NosqlGetVersionResponseNosql
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlGetVersionResponseNosql
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlGetVersionResponseNosqlUpgradableVersionsItem_EncodeDecode(t *testing.T) {
	var typ NosqlGetVersionResponseNosqlUpgradableVersionsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlGetVersionResponseNosqlUpgradableVersionsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlIsOkResponse_EncodeDecode(t *testing.T) {
	var typ NosqlIsOkResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlIsOkResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlIsOkResponseNosql_EncodeDecode(t *testing.T) {
	var typ NosqlIsOkResponseNosql
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlIsOkResponseNosql
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlListResponse_EncodeDecode(t *testing.T) {
	var typ NosqlListResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlListResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlOkResponse_EncodeDecode(t *testing.T) {
	var typ NosqlOkResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlOkResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlOkResponseNosql_EncodeDecode(t *testing.T) {
	var typ NosqlOkResponseNosql
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlOkResponseNosql
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlPutParameter_EncodeDecode(t *testing.T) {
	var typ NosqlPutParameter
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlPutParameter
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlPutVersionRequest_EncodeDecode(t *testing.T) {
	var typ NosqlPutVersionRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlPutVersionRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlPutVersionRequestNosql_EncodeDecode(t *testing.T) {
	var typ NosqlPutVersionRequestNosql
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlPutVersionRequestNosql
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlPutVersionResponse_EncodeDecode(t *testing.T) {
	var typ NosqlPutVersionResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlPutVersionResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlPutVersionResponseNosql_EncodeDecode(t *testing.T) {
	var typ NosqlPutVersionResponseNosql
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlPutVersionResponseNosql
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlRemark_EncodeDecode(t *testing.T) {
	var typ NosqlRemark
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlRemark
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlRemarkNosql_EncodeDecode(t *testing.T) {
	var typ NosqlRemarkNosql
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlRemarkNosql
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlRemarkNosqlDatabaseEngine_EncodeDecode(t *testing.T) {
	var typ NosqlRemarkNosqlDatabaseEngine
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlRemarkNosqlDatabaseEngine
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNosqlRemarkNosqlDatabaseEngine_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"Cassandra\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NosqlRemarkNosqlDatabaseEngine

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NosqlRemarkNosqlDatabaseEngine
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNosqlRemarkNosqlDiskSize_EncodeDecode(t *testing.T) {
	var typ NosqlRemarkNosqlDiskSize
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlRemarkNosqlDiskSize
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNosqlRemarkNosqlDiskSize_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "102400"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NosqlRemarkNosqlDiskSize

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NosqlRemarkNosqlDiskSize
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNosqlRemarkNosqlMemory_EncodeDecode(t *testing.T) {
	var typ NosqlRemarkNosqlMemory
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlRemarkNosqlMemory
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNosqlRemarkNosqlMemory_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "8192"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NosqlRemarkNosqlMemory

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NosqlRemarkNosqlMemory
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNosqlRemarkNosqlStorage_EncodeDecode(t *testing.T) {
	var typ NosqlRemarkNosqlStorage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlRemarkNosqlStorage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNosqlRemarkNosqlStorage_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"SSD\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NosqlRemarkNosqlStorage

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NosqlRemarkNosqlStorage
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNosqlRemarkNosqlVirtualcore_EncodeDecode(t *testing.T) {
	var typ NosqlRemarkNosqlVirtualcore
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlRemarkNosqlVirtualcore
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNosqlRemarkNosqlVirtualcore_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "3"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NosqlRemarkNosqlVirtualcore

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NosqlRemarkNosqlVirtualcore
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNosqlRemarkServersItem_EncodeDecode(t *testing.T) {
	var typ NosqlRemarkServersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlRemarkServersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlSettings_EncodeDecode(t *testing.T) {
	var typ NosqlSettings
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlSettings
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlSettingsBackup_EncodeDecode(t *testing.T) {
	var typ NosqlSettingsBackup
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlSettingsBackup
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlSettingsBackupDayOfWeekItem_EncodeDecode(t *testing.T) {
	var typ NosqlSettingsBackupDayOfWeekItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlSettingsBackupDayOfWeekItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlStatusResponse_EncodeDecode(t *testing.T) {
	var typ NosqlStatusResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlStatusResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlStatusResponseAppliance_EncodeDecode(t *testing.T) {
	var typ NosqlStatusResponseAppliance
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlStatusResponseAppliance
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlStatusResponseApplianceSettingsResponse_EncodeDecode(t *testing.T) {
	var typ NosqlStatusResponseApplianceSettingsResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlStatusResponseApplianceSettingsResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlStatusResponseApplianceSettingsResponseNosql_EncodeDecode(t *testing.T) {
	var typ NosqlStatusResponseApplianceSettingsResponseNosql
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlStatusResponseApplianceSettingsResponseNosql
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlStatusResponseApplianceSettingsResponseNosqlJobsItem_EncodeDecode(t *testing.T) {
	var typ NosqlStatusResponseApplianceSettingsResponseNosqlJobsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlStatusResponseApplianceSettingsResponseNosqlJobsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlSuccessResponse_EncodeDecode(t *testing.T) {
	var typ NosqlSuccessResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlSuccessResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlUpdateRequest_EncodeDecode(t *testing.T) {
	var typ NosqlUpdateRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlUpdateRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlUpdateRequestAppliance_EncodeDecode(t *testing.T) {
	var typ NosqlUpdateRequestAppliance
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlUpdateRequestAppliance
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlUpdateRequestApplianceSettings_EncodeDecode(t *testing.T) {
	var typ NosqlUpdateRequestApplianceSettings
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlUpdateRequestApplianceSettings
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlUpdateRequestApplianceSettingsBackup_EncodeDecode(t *testing.T) {
	var typ NosqlUpdateRequestApplianceSettingsBackup
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlUpdateRequestApplianceSettingsBackup
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem_EncodeDecode(t *testing.T) {
	var typ NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNotFoundResponse_EncodeDecode(t *testing.T) {
	var typ NotFoundResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NotFoundResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPassword_EncodeDecode(t *testing.T) {
	var typ Password
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Password
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPlan_EncodeDecode(t *testing.T) {
	var typ Plan
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Plan
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPutParameterRequest_EncodeDecode(t *testing.T) {
	var typ PutParameterRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PutParameterRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPutParameterRequestNosql_EncodeDecode(t *testing.T) {
	var typ PutParameterRequestNosql
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PutParameterRequestNosql
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPutParameterResponse_EncodeDecode(t *testing.T) {
	var typ PutParameterResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PutParameterResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPutParameterResponseNosql_EncodeDecode(t *testing.T) {
	var typ PutParameterResponseNosql
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PutParameterResponseNosql
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestServerErrorResponse_EncodeDecode(t *testing.T) {
	var typ ServerErrorResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ServerErrorResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestServiceClass_EncodeDecode(t *testing.T) {
	var typ ServiceClass
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ServiceClass
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSuccess_EncodeDecode(t *testing.T) {
	var typ Success
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Success
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSuccessResponse_EncodeDecode(t *testing.T) {
	var typ SuccessResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SuccessResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTags_EncodeDecode(t *testing.T) {
	var typ Tags
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Tags
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUnauthorizedResponse_EncodeDecode(t *testing.T) {
	var typ UnauthorizedResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UnauthorizedResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
