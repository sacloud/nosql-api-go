// Code generated by ogen, DO NOT EDIT.

package v1

import (
	"fmt"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/validate"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestAvailability_EncodeDecode(t *testing.T) {
	var typ Availability
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Availability
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestAvailability_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"available\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Availability

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Availability
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestBadRequestResponse_EncodeDecode(t *testing.T) {
	var typ BadRequestResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BadRequestResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestConflictErrorResponse_EncodeDecode(t *testing.T) {
	var typ ConflictErrorResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ConflictErrorResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNosqlAppliance_EncodeDecode(t *testing.T) {
	var typ GetNosqlAppliance
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNosqlAppliance
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNosqlApplianceDisk_EncodeDecode(t *testing.T) {
	var typ GetNosqlApplianceDisk
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNosqlApplianceDisk
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNosqlApplianceDiskEncryptionKey_EncodeDecode(t *testing.T) {
	var typ GetNosqlApplianceDiskEncryptionKey
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNosqlApplianceDiskEncryptionKey
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNosqlApplianceInterfacesItem_EncodeDecode(t *testing.T) {
	var typ GetNosqlApplianceInterfacesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNosqlApplianceInterfacesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNosqlApplianceInterfacesItemSwitch_EncodeDecode(t *testing.T) {
	var typ GetNosqlApplianceInterfacesItemSwitch
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNosqlApplianceInterfacesItemSwitch
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNosqlApplianceInterfacesItemSwitchSubnet_EncodeDecode(t *testing.T) {
	var typ GetNosqlApplianceInterfacesItemSwitchSubnet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNosqlApplianceInterfacesItemSwitchSubnet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNosqlApplianceInterfacesItemSwitchSubnetInternet_EncodeDecode(t *testing.T) {
	var typ GetNosqlApplianceInterfacesItemSwitchSubnetInternet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNosqlApplianceInterfacesItemSwitchSubnetInternet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNosqlApplianceInterfacesItemSwitchUserSubnet_EncodeDecode(t *testing.T) {
	var typ GetNosqlApplianceInterfacesItemSwitchUserSubnet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNosqlApplianceInterfacesItemSwitchUserSubnet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNosqlApplianceRemark_EncodeDecode(t *testing.T) {
	var typ GetNosqlApplianceRemark
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNosqlApplianceRemark
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNosqlApplianceRemarkNosql_EncodeDecode(t *testing.T) {
	var typ GetNosqlApplianceRemarkNosql
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNosqlApplianceRemarkNosql
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNosqlApplianceRemarkNosqlDatabaseEngine_EncodeDecode(t *testing.T) {
	var typ GetNosqlApplianceRemarkNosqlDatabaseEngine
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNosqlApplianceRemarkNosqlDatabaseEngine
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetNosqlApplianceRemarkNosqlDatabaseEngine_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"Cassandra\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetNosqlApplianceRemarkNosqlDatabaseEngine

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetNosqlApplianceRemarkNosqlDatabaseEngine
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetNosqlApplianceRemarkNosqlDiskSize_EncodeDecode(t *testing.T) {
	var typ GetNosqlApplianceRemarkNosqlDiskSize
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNosqlApplianceRemarkNosqlDiskSize
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetNosqlApplianceRemarkNosqlDiskSize_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "102400"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetNosqlApplianceRemarkNosqlDiskSize

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetNosqlApplianceRemarkNosqlDiskSize
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetNosqlApplianceRemarkNosqlMemory_EncodeDecode(t *testing.T) {
	var typ GetNosqlApplianceRemarkNosqlMemory
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNosqlApplianceRemarkNosqlMemory
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetNosqlApplianceRemarkNosqlMemory_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "8192"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetNosqlApplianceRemarkNosqlMemory

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetNosqlApplianceRemarkNosqlMemory
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetNosqlApplianceRemarkNosqlPrimaryNodes_EncodeDecode(t *testing.T) {
	var typ GetNosqlApplianceRemarkNosqlPrimaryNodes
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNosqlApplianceRemarkNosqlPrimaryNodes
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNosqlApplianceRemarkNosqlPrimaryNodesAppliance_EncodeDecode(t *testing.T) {
	var typ GetNosqlApplianceRemarkNosqlPrimaryNodesAppliance
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNosqlApplianceRemarkNosqlPrimaryNodesAppliance
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNosqlApplianceRemarkNosqlPrimaryNodesApplianceZone_EncodeDecode(t *testing.T) {
	var typ GetNosqlApplianceRemarkNosqlPrimaryNodesApplianceZone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNosqlApplianceRemarkNosqlPrimaryNodesApplianceZone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNosqlApplianceRemarkNosqlStorage_EncodeDecode(t *testing.T) {
	var typ GetNosqlApplianceRemarkNosqlStorage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNosqlApplianceRemarkNosqlStorage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetNosqlApplianceRemarkNosqlStorage_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"SSD\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetNosqlApplianceRemarkNosqlStorage

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetNosqlApplianceRemarkNosqlStorage
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetNosqlApplianceRemarkNosqlVirtualcore_EncodeDecode(t *testing.T) {
	var typ GetNosqlApplianceRemarkNosqlVirtualcore
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNosqlApplianceRemarkNosqlVirtualcore
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetNosqlApplianceRemarkNosqlVirtualcore_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "3"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetNosqlApplianceRemarkNosqlVirtualcore

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetNosqlApplianceRemarkNosqlVirtualcore
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetNosqlApplianceRemarkServersItem_EncodeDecode(t *testing.T) {
	var typ GetNosqlApplianceRemarkServersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNosqlApplianceRemarkServersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNosqlApplianceRemarkZone_EncodeDecode(t *testing.T) {
	var typ GetNosqlApplianceRemarkZone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNosqlApplianceRemarkZone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNosqlSettings_EncodeDecode(t *testing.T) {
	var typ GetNosqlSettings
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNosqlSettings
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNosqlSettingsBackup_EncodeDecode(t *testing.T) {
	var typ GetNosqlSettingsBackup
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNosqlSettingsBackup
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNosqlSettingsBackupDayOfWeekItem_EncodeDecode(t *testing.T) {
	var typ GetNosqlSettingsBackupDayOfWeekItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNosqlSettingsBackupDayOfWeekItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNosqlSettingsRepair_EncodeDecode(t *testing.T) {
	var typ GetNosqlSettingsRepair
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNosqlSettingsRepair
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNosqlSettingsRepairFull_EncodeDecode(t *testing.T) {
	var typ GetNosqlSettingsRepairFull
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNosqlSettingsRepairFull
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNosqlSettingsRepairFullDayOfWeek_EncodeDecode(t *testing.T) {
	var typ GetNosqlSettingsRepairFullDayOfWeek
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNosqlSettingsRepairFullDayOfWeek
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetNosqlSettingsRepairFullDayOfWeek_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"sun\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetNosqlSettingsRepairFullDayOfWeek

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetNosqlSettingsRepairFullDayOfWeek
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetNosqlSettingsRepairFullInterval_EncodeDecode(t *testing.T) {
	var typ GetNosqlSettingsRepairFullInterval
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNosqlSettingsRepairFullInterval
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetNosqlSettingsRepairFullInterval_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "7"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetNosqlSettingsRepairFullInterval

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetNosqlSettingsRepairFullInterval
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetNosqlSettingsRepairIncremental_EncodeDecode(t *testing.T) {
	var typ GetNosqlSettingsRepairIncremental
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNosqlSettingsRepairIncremental
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNosqlSettingsRepairIncrementalDaysOfWeekItem_EncodeDecode(t *testing.T) {
	var typ GetNosqlSettingsRepairIncrementalDaysOfWeekItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNosqlSettingsRepairIncrementalDaysOfWeekItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetParameterResponse_EncodeDecode(t *testing.T) {
	var typ GetParameterResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetParameterResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetParameterResponseNosql_EncodeDecode(t *testing.T) {
	var typ GetParameterResponseNosql
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetParameterResponseNosql
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPlan_EncodeDecode(t *testing.T) {
	var typ GetPlan
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPlan
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetServiceClass_EncodeDecode(t *testing.T) {
	var typ GetServiceClass
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetServiceClass
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInstance_EncodeDecode(t *testing.T) {
	var typ Instance
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Instance
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInstanceHost_EncodeDecode(t *testing.T) {
	var typ InstanceHost
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InstanceHost
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInstanceHostsItem_EncodeDecode(t *testing.T) {
	var typ InstanceHostsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InstanceHostsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIsOk_EncodeDecode(t *testing.T) {
	var typ IsOk
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IsOk
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodeHealth_EncodeDecode(t *testing.T) {
	var typ NodeHealth
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeHealth
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodeHealthNosql_EncodeDecode(t *testing.T) {
	var typ NodeHealthNosql
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeHealthNosql
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodeHealthNosqlStatus_EncodeDecode(t *testing.T) {
	var typ NodeHealthNosqlStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeHealthNosqlStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNodeHealthNosqlStatus_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"healthy-partial\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NodeHealthNosqlStatus

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NodeHealthNosqlStatus
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNosqlAppliance_EncodeDecode(t *testing.T) {
	var typ NosqlAppliance
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlAppliance
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlApplianceDisk_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceDisk
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceDisk
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlApplianceDiskEncryptionKey_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceDiskEncryptionKey
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceDiskEncryptionKey
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlApplianceInterfacesItem_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceInterfacesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceInterfacesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlApplianceInterfacesItemSwitch_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceInterfacesItemSwitch
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceInterfacesItemSwitch
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlApplianceInterfacesItemSwitchSubnet_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceInterfacesItemSwitchSubnet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceInterfacesItemSwitchSubnet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlApplianceInterfacesItemSwitchSubnetInternet_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceInterfacesItemSwitchSubnetInternet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceInterfacesItemSwitchSubnetInternet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlApplianceInterfacesItemSwitchUserSubnet_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceInterfacesItemSwitchUserSubnet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceInterfacesItemSwitchUserSubnet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlApplianceRemark_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceRemark
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceRemark
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlApplianceRemarkNosql_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceRemarkNosql
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceRemarkNosql
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlApplianceRemarkNosqlDatabaseEngine_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceRemarkNosqlDatabaseEngine
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceRemarkNosqlDatabaseEngine
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNosqlApplianceRemarkNosqlDatabaseEngine_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"Cassandra\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NosqlApplianceRemarkNosqlDatabaseEngine

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NosqlApplianceRemarkNosqlDatabaseEngine
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNosqlApplianceRemarkNosqlDiskSize_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceRemarkNosqlDiskSize
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceRemarkNosqlDiskSize
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNosqlApplianceRemarkNosqlDiskSize_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "102400"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NosqlApplianceRemarkNosqlDiskSize

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NosqlApplianceRemarkNosqlDiskSize
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNosqlApplianceRemarkNosqlMemory_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceRemarkNosqlMemory
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceRemarkNosqlMemory
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNosqlApplianceRemarkNosqlMemory_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "8192"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NosqlApplianceRemarkNosqlMemory

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NosqlApplianceRemarkNosqlMemory
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNosqlApplianceRemarkNosqlPrimaryNodes_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceRemarkNosqlPrimaryNodes
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceRemarkNosqlPrimaryNodes
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlApplianceRemarkNosqlPrimaryNodesAppliance_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceRemarkNosqlPrimaryNodesAppliance
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceRemarkNosqlPrimaryNodesAppliance
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlApplianceRemarkNosqlPrimaryNodesApplianceZone_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceRemarkNosqlPrimaryNodesApplianceZone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceRemarkNosqlPrimaryNodesApplianceZone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlApplianceRemarkNosqlStorage_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceRemarkNosqlStorage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceRemarkNosqlStorage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNosqlApplianceRemarkNosqlStorage_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"SSD\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NosqlApplianceRemarkNosqlStorage

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NosqlApplianceRemarkNosqlStorage
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNosqlApplianceRemarkNosqlVirtualcore_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceRemarkNosqlVirtualcore
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceRemarkNosqlVirtualcore
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNosqlApplianceRemarkNosqlVirtualcore_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "3"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NosqlApplianceRemarkNosqlVirtualcore

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NosqlApplianceRemarkNosqlVirtualcore
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNosqlApplianceRemarkServersItem_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceRemarkServersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceRemarkServersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlApplianceRemarkZone_EncodeDecode(t *testing.T) {
	var typ NosqlApplianceRemarkZone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlApplianceRemarkZone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlBackup_EncodeDecode(t *testing.T) {
	var typ NosqlBackup
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlBackup
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlBackupResponse_EncodeDecode(t *testing.T) {
	var typ NosqlBackupResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlBackupResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlBackupResponseNosql_EncodeDecode(t *testing.T) {
	var typ NosqlBackupResponseNosql
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlBackupResponseNosql
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateRequest_EncodeDecode(t *testing.T) {
	var typ NosqlCreateRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateRequestAppliance_EncodeDecode(t *testing.T) {
	var typ NosqlCreateRequestAppliance
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateRequestAppliance
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateRequestApplianceDisk_EncodeDecode(t *testing.T) {
	var typ NosqlCreateRequestApplianceDisk
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateRequestApplianceDisk
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateRequestApplianceDiskEncryptionKey_EncodeDecode(t *testing.T) {
	var typ NosqlCreateRequestApplianceDiskEncryptionKey
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateRequestApplianceDiskEncryptionKey
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateRequestApplianceSettings_EncodeDecode(t *testing.T) {
	var typ NosqlCreateRequestApplianceSettings
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateRequestApplianceSettings
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateRequestApplianceSettingsBackup_EncodeDecode(t *testing.T) {
	var typ NosqlCreateRequestApplianceSettingsBackup
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateRequestApplianceSettingsBackup
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateRequestApplianceSettingsBackupDayOfWeekItem_EncodeDecode(t *testing.T) {
	var typ NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateRequestApplianceSettingsRepair_EncodeDecode(t *testing.T) {
	var typ NosqlCreateRequestApplianceSettingsRepair
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateRequestApplianceSettingsRepair
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateRequestApplianceSettingsRepairFull_EncodeDecode(t *testing.T) {
	var typ NosqlCreateRequestApplianceSettingsRepairFull
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateRequestApplianceSettingsRepairFull
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateRequestApplianceSettingsRepairFullDayOfWeek_EncodeDecode(t *testing.T) {
	var typ NosqlCreateRequestApplianceSettingsRepairFullDayOfWeek
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateRequestApplianceSettingsRepairFullDayOfWeek
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNosqlCreateRequestApplianceSettingsRepairFullDayOfWeek_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"sun\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NosqlCreateRequestApplianceSettingsRepairFullDayOfWeek

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NosqlCreateRequestApplianceSettingsRepairFullDayOfWeek
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNosqlCreateRequestApplianceSettingsRepairFullInterval_EncodeDecode(t *testing.T) {
	var typ NosqlCreateRequestApplianceSettingsRepairFullInterval
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateRequestApplianceSettingsRepairFullInterval
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNosqlCreateRequestApplianceSettingsRepairFullInterval_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "7"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NosqlCreateRequestApplianceSettingsRepairFullInterval

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NosqlCreateRequestApplianceSettingsRepairFullInterval
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNosqlCreateRequestApplianceSettingsRepairIncremental_EncodeDecode(t *testing.T) {
	var typ NosqlCreateRequestApplianceSettingsRepairIncremental
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateRequestApplianceSettingsRepairIncremental
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateRequestApplianceSettingsRepairIncrementalDaysOfWeekItem_EncodeDecode(t *testing.T) {
	var typ NosqlCreateRequestApplianceSettingsRepairIncrementalDaysOfWeekItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateRequestApplianceSettingsRepairIncrementalDaysOfWeekItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateRequestApplianceUserInterfacesItem_EncodeDecode(t *testing.T) {
	var typ NosqlCreateRequestApplianceUserInterfacesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateRequestApplianceUserInterfacesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateRequestApplianceUserInterfacesItemSwitch_EncodeDecode(t *testing.T) {
	var typ NosqlCreateRequestApplianceUserInterfacesItemSwitch
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateRequestApplianceUserInterfacesItemSwitch
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateRequestApplianceUserInterfacesItemUserSubnet_EncodeDecode(t *testing.T) {
	var typ NosqlCreateRequestApplianceUserInterfacesItemUserSubnet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateRequestApplianceUserInterfacesItemUserSubnet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateResponse_EncodeDecode(t *testing.T) {
	var typ NosqlCreateResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateResponseAccount_EncodeDecode(t *testing.T) {
	var typ NosqlCreateResponseAccount
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateResponseAccount
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateResponseHiddenRemark_EncodeDecode(t *testing.T) {
	var typ NosqlCreateResponseHiddenRemark
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateResponseHiddenRemark
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateResponseHiddenRemarkEncrypted_EncodeDecode(t *testing.T) {
	var typ NosqlCreateResponseHiddenRemarkEncrypted
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateResponseHiddenRemarkEncrypted
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateResponseHiddenRemarkPlanSpec_EncodeDecode(t *testing.T) {
	var typ NosqlCreateResponseHiddenRemarkPlanSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateResponseHiddenRemarkPlanSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlCreateResponseHiddenRemarkPlanSpecNote_EncodeDecode(t *testing.T) {
	var typ NosqlCreateResponseHiddenRemarkPlanSpecNote
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlCreateResponseHiddenRemarkPlanSpecNote
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlGetParameter_EncodeDecode(t *testing.T) {
	var typ NosqlGetParameter
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlGetParameter
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlGetResponse_EncodeDecode(t *testing.T) {
	var typ NosqlGetResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlGetResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlGetVersionResponse_EncodeDecode(t *testing.T) {
	var typ NosqlGetVersionResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlGetVersionResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlGetVersionResponseNosql_EncodeDecode(t *testing.T) {
	var typ NosqlGetVersionResponseNosql
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlGetVersionResponseNosql
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlGetVersionResponseNosqlUpgradableVersionsItem_EncodeDecode(t *testing.T) {
	var typ NosqlGetVersionResponseNosqlUpgradableVersionsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlGetVersionResponseNosqlUpgradableVersionsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlIsOkResponse_EncodeDecode(t *testing.T) {
	var typ NosqlIsOkResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlIsOkResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlIsOkResponseNosql_EncodeDecode(t *testing.T) {
	var typ NosqlIsOkResponseNosql
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlIsOkResponseNosql
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlListResponse_EncodeDecode(t *testing.T) {
	var typ NosqlListResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlListResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlNodeAppliance_EncodeDecode(t *testing.T) {
	var typ NosqlNodeAppliance
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlNodeAppliance
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlNodeApplianceZone_EncodeDecode(t *testing.T) {
	var typ NosqlNodeApplianceZone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlNodeApplianceZone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlOkResponse_EncodeDecode(t *testing.T) {
	var typ NosqlOkResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlOkResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlOkResponseNosql_EncodeDecode(t *testing.T) {
	var typ NosqlOkResponseNosql
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlOkResponseNosql
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlPutParameter_EncodeDecode(t *testing.T) {
	var typ NosqlPutParameter
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlPutParameter
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlPutVersionRequest_EncodeDecode(t *testing.T) {
	var typ NosqlPutVersionRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlPutVersionRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlPutVersionResponse_EncodeDecode(t *testing.T) {
	var typ NosqlPutVersionResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlPutVersionResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlRemark_EncodeDecode(t *testing.T) {
	var typ NosqlRemark
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlRemark
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlRemarkNosql_EncodeDecode(t *testing.T) {
	var typ NosqlRemarkNosql
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlRemarkNosql
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlRemarkNosqlDatabaseEngine_EncodeDecode(t *testing.T) {
	var typ NosqlRemarkNosqlDatabaseEngine
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlRemarkNosqlDatabaseEngine
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNosqlRemarkNosqlDatabaseEngine_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"Cassandra\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NosqlRemarkNosqlDatabaseEngine

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NosqlRemarkNosqlDatabaseEngine
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNosqlRemarkNosqlDiskSize_EncodeDecode(t *testing.T) {
	var typ NosqlRemarkNosqlDiskSize
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlRemarkNosqlDiskSize
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNosqlRemarkNosqlDiskSize_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "102400"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NosqlRemarkNosqlDiskSize

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NosqlRemarkNosqlDiskSize
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNosqlRemarkNosqlMemory_EncodeDecode(t *testing.T) {
	var typ NosqlRemarkNosqlMemory
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlRemarkNosqlMemory
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNosqlRemarkNosqlMemory_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "8192"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NosqlRemarkNosqlMemory

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NosqlRemarkNosqlMemory
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNosqlRemarkNosqlPrimaryNodes_EncodeDecode(t *testing.T) {
	var typ NosqlRemarkNosqlPrimaryNodes
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlRemarkNosqlPrimaryNodes
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlRemarkNosqlPrimaryNodesAppliance_EncodeDecode(t *testing.T) {
	var typ NosqlRemarkNosqlPrimaryNodesAppliance
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlRemarkNosqlPrimaryNodesAppliance
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlRemarkNosqlPrimaryNodesApplianceZone_EncodeDecode(t *testing.T) {
	var typ NosqlRemarkNosqlPrimaryNodesApplianceZone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlRemarkNosqlPrimaryNodesApplianceZone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlRemarkNosqlStorage_EncodeDecode(t *testing.T) {
	var typ NosqlRemarkNosqlStorage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlRemarkNosqlStorage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNosqlRemarkNosqlStorage_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"SSD\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NosqlRemarkNosqlStorage

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NosqlRemarkNosqlStorage
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNosqlRemarkNosqlVirtualcore_EncodeDecode(t *testing.T) {
	var typ NosqlRemarkNosqlVirtualcore
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlRemarkNosqlVirtualcore
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNosqlRemarkNosqlVirtualcore_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "3"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NosqlRemarkNosqlVirtualcore

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NosqlRemarkNosqlVirtualcore
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNosqlRemarkServersItem_EncodeDecode(t *testing.T) {
	var typ NosqlRemarkServersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlRemarkServersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlRepairRequest_EncodeDecode(t *testing.T) {
	var typ NosqlRepairRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlRepairRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlRepairRequestNosql_EncodeDecode(t *testing.T) {
	var typ NosqlRepairRequestNosql
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlRepairRequestNosql
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlRepairRequestNosqlRepairType_EncodeDecode(t *testing.T) {
	var typ NosqlRepairRequestNosqlRepairType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlRepairRequestNosqlRepairType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNosqlRepairRequestNosqlRepairType_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"Incremental\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NosqlRepairRequestNosqlRepairType

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NosqlRepairRequestNosqlRepairType
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNosqlSettings_EncodeDecode(t *testing.T) {
	var typ NosqlSettings
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlSettings
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlSettingsBackup_EncodeDecode(t *testing.T) {
	var typ NosqlSettingsBackup
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlSettingsBackup
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlSettingsBackupDayOfWeekItem_EncodeDecode(t *testing.T) {
	var typ NosqlSettingsBackupDayOfWeekItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlSettingsBackupDayOfWeekItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlSettingsRepair_EncodeDecode(t *testing.T) {
	var typ NosqlSettingsRepair
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlSettingsRepair
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlSettingsRepairFull_EncodeDecode(t *testing.T) {
	var typ NosqlSettingsRepairFull
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlSettingsRepairFull
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlSettingsRepairFullDayOfWeek_EncodeDecode(t *testing.T) {
	var typ NosqlSettingsRepairFullDayOfWeek
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlSettingsRepairFullDayOfWeek
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNosqlSettingsRepairFullDayOfWeek_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"sun\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NosqlSettingsRepairFullDayOfWeek

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NosqlSettingsRepairFullDayOfWeek
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNosqlSettingsRepairFullInterval_EncodeDecode(t *testing.T) {
	var typ NosqlSettingsRepairFullInterval
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlSettingsRepairFullInterval
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNosqlSettingsRepairFullInterval_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "7"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NosqlSettingsRepairFullInterval

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NosqlSettingsRepairFullInterval
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNosqlSettingsRepairIncremental_EncodeDecode(t *testing.T) {
	var typ NosqlSettingsRepairIncremental
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlSettingsRepairIncremental
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlSettingsRepairIncrementalDaysOfWeekItem_EncodeDecode(t *testing.T) {
	var typ NosqlSettingsRepairIncrementalDaysOfWeekItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlSettingsRepairIncrementalDaysOfWeekItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlStatusResponse_EncodeDecode(t *testing.T) {
	var typ NosqlStatusResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlStatusResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlStatusResponseAppliance_EncodeDecode(t *testing.T) {
	var typ NosqlStatusResponseAppliance
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlStatusResponseAppliance
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlStatusResponseApplianceSettingsResponse_EncodeDecode(t *testing.T) {
	var typ NosqlStatusResponseApplianceSettingsResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlStatusResponseApplianceSettingsResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlStatusResponseApplianceSettingsResponseNosql_EncodeDecode(t *testing.T) {
	var typ NosqlStatusResponseApplianceSettingsResponseNosql
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlStatusResponseApplianceSettingsResponseNosql
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlStatusResponseApplianceSettingsResponseNosqlAddNodesItem_EncodeDecode(t *testing.T) {
	var typ NosqlStatusResponseApplianceSettingsResponseNosqlAddNodesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlStatusResponseApplianceSettingsResponseNosqlAddNodesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlStatusResponseApplianceSettingsResponseNosqlJobsItem_EncodeDecode(t *testing.T) {
	var typ NosqlStatusResponseApplianceSettingsResponseNosqlJobsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlStatusResponseApplianceSettingsResponseNosqlJobsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlStatusResponseApplianceSettingsResponseNosqlPrimaryNodes_EncodeDecode(t *testing.T) {
	var typ NosqlStatusResponseApplianceSettingsResponseNosqlPrimaryNodes
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlStatusResponseApplianceSettingsResponseNosqlPrimaryNodes
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlSuccessResponse_EncodeDecode(t *testing.T) {
	var typ NosqlSuccessResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlSuccessResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlUpdateRequest_EncodeDecode(t *testing.T) {
	var typ NosqlUpdateRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlUpdateRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlUpdateRequestAppliance_EncodeDecode(t *testing.T) {
	var typ NosqlUpdateRequestAppliance
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlUpdateRequestAppliance
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlUpdateRequestApplianceSettings_EncodeDecode(t *testing.T) {
	var typ NosqlUpdateRequestApplianceSettings
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlUpdateRequestApplianceSettings
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlUpdateRequestApplianceSettingsBackup_EncodeDecode(t *testing.T) {
	var typ NosqlUpdateRequestApplianceSettingsBackup
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlUpdateRequestApplianceSettingsBackup
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem_EncodeDecode(t *testing.T) {
	var typ NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlUpdateRequestApplianceSettingsRepair_EncodeDecode(t *testing.T) {
	var typ NosqlUpdateRequestApplianceSettingsRepair
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlUpdateRequestApplianceSettingsRepair
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlUpdateRequestApplianceSettingsRepairFull_EncodeDecode(t *testing.T) {
	var typ NosqlUpdateRequestApplianceSettingsRepairFull
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlUpdateRequestApplianceSettingsRepairFull
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlUpdateRequestApplianceSettingsRepairFullDayOfWeek_EncodeDecode(t *testing.T) {
	var typ NosqlUpdateRequestApplianceSettingsRepairFullDayOfWeek
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlUpdateRequestApplianceSettingsRepairFullDayOfWeek
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNosqlUpdateRequestApplianceSettingsRepairFullDayOfWeek_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"sun\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NosqlUpdateRequestApplianceSettingsRepairFullDayOfWeek

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NosqlUpdateRequestApplianceSettingsRepairFullDayOfWeek
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNosqlUpdateRequestApplianceSettingsRepairFullInterval_EncodeDecode(t *testing.T) {
	var typ NosqlUpdateRequestApplianceSettingsRepairFullInterval
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlUpdateRequestApplianceSettingsRepairFullInterval
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNosqlUpdateRequestApplianceSettingsRepairFullInterval_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "7"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NosqlUpdateRequestApplianceSettingsRepairFullInterval

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NosqlUpdateRequestApplianceSettingsRepairFullInterval
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNosqlUpdateRequestApplianceSettingsRepairIncremental_EncodeDecode(t *testing.T) {
	var typ NosqlUpdateRequestApplianceSettingsRepairIncremental
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlUpdateRequestApplianceSettingsRepairIncremental
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlUpdateRequestApplianceSettingsRepairIncrementalDaysOfWeekItem_EncodeDecode(t *testing.T) {
	var typ NosqlUpdateRequestApplianceSettingsRepairIncrementalDaysOfWeekItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlUpdateRequestApplianceSettingsRepairIncrementalDaysOfWeekItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqlVersion_EncodeDecode(t *testing.T) {
	var typ NosqlVersion
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqlVersion
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqldbNodeStatus_EncodeDecode(t *testing.T) {
	var typ NosqldbNodeStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqldbNodeStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNosqldbNodeStatusNodeType_EncodeDecode(t *testing.T) {
	var typ NosqldbNodeStatusNodeType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NosqldbNodeStatusNodeType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNosqldbNodeStatusNodeType_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"0\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NosqldbNodeStatusNodeType

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NosqldbNodeStatusNodeType
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNotFoundResponse_EncodeDecode(t *testing.T) {
	var typ NotFoundResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NotFoundResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPassword_EncodeDecode(t *testing.T) {
	var typ Password
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Password
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPlan_EncodeDecode(t *testing.T) {
	var typ Plan
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Plan
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPutParameterRequest_EncodeDecode(t *testing.T) {
	var typ PutParameterRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PutParameterRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPutParameterRequestNosql_EncodeDecode(t *testing.T) {
	var typ PutParameterRequestNosql
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PutParameterRequestNosql
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPutParameterResponse_EncodeDecode(t *testing.T) {
	var typ PutParameterResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PutParameterResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPutParameterResponseNosql_EncodeDecode(t *testing.T) {
	var typ PutParameterResponseNosql
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PutParameterResponseNosql
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRecoverNoSQLNodeAccepted_EncodeDecode(t *testing.T) {
	var typ RecoverNoSQLNodeAccepted
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RecoverNoSQLNodeAccepted
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRecoverNoSQLNodeOK_EncodeDecode(t *testing.T) {
	var typ RecoverNoSQLNodeOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RecoverNoSQLNodeOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestServerErrorResponse_EncodeDecode(t *testing.T) {
	var typ ServerErrorResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ServerErrorResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestServiceClass_EncodeDecode(t *testing.T) {
	var typ ServiceClass
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ServiceClass
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSuccess_EncodeDecode(t *testing.T) {
	var typ Success
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Success
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSuccessResponse_EncodeDecode(t *testing.T) {
	var typ SuccessResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SuccessResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTags_EncodeDecode(t *testing.T) {
	var typ Tags
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Tags
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUnauthorizedResponse_EncodeDecode(t *testing.T) {
	var typ UnauthorizedResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UnauthorizedResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
