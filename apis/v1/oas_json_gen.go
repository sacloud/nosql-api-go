// Code generated by ogen, DO NOT EDIT.

package v1

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode encodes Availability as json.
func (s Availability) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes Availability from json.
func (s *Availability) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Availability to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Availability(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Availability) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Availability) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BadRequestResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BadRequestResponse) encodeFields(e *jx.Encoder) {
	{
		if s.IsFatal.Set {
			e.FieldStart("is_fatal")
			s.IsFatal.Encode(e)
		}
	}
	{
		if s.Serial.Set {
			e.FieldStart("serial")
			s.Serial.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("error_code")
			s.ErrorCode.Encode(e)
		}
	}
	{
		if s.ErrorMsg.Set {
			e.FieldStart("error_msg")
			s.ErrorMsg.Encode(e)
		}
	}
}

var jsonFieldsNameOfBadRequestResponse = [5]string{
	0: "is_fatal",
	1: "serial",
	2: "status",
	3: "error_code",
	4: "error_msg",
}

// Decode decodes BadRequestResponse from json.
func (s *BadRequestResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BadRequestResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "is_fatal":
			if err := func() error {
				s.IsFatal.Reset()
				if err := s.IsFatal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_fatal\"")
			}
		case "serial":
			if err := func() error {
				s.Serial.Reset()
				if err := s.Serial.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serial\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "error_code":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_code\"")
			}
		case "error_msg":
			if err := func() error {
				s.ErrorMsg.Reset()
				if err := s.ErrorMsg.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_msg\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BadRequestResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BadRequestResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BadRequestResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConflictResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConflictResponse) encodeFields(e *jx.Encoder) {
	{
		if s.IsFatal.Set {
			e.FieldStart("is_fatal")
			s.IsFatal.Encode(e)
		}
	}
	{
		if s.Serial.Set {
			e.FieldStart("serial")
			s.Serial.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("error_code")
			s.ErrorCode.Encode(e)
		}
	}
	{
		if s.ErrorMsg.Set {
			e.FieldStart("error_msg")
			s.ErrorMsg.Encode(e)
		}
	}
}

var jsonFieldsNameOfConflictResponse = [5]string{
	0: "is_fatal",
	1: "serial",
	2: "status",
	3: "error_code",
	4: "error_msg",
}

// Decode decodes ConflictResponse from json.
func (s *ConflictResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConflictResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "is_fatal":
			if err := func() error {
				s.IsFatal.Reset()
				if err := s.IsFatal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_fatal\"")
			}
		case "serial":
			if err := func() error {
				s.Serial.Reset()
				if err := s.Serial.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serial\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "error_code":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_code\"")
			}
		case "error_msg":
			if err := func() error {
				s.ErrorMsg.Reset()
				if err := s.ErrorMsg.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_msg\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConflictResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConflictResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConflictResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetParameterResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetParameterResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Nosql.Set {
			e.FieldStart("nosql")
			s.Nosql.Encode(e)
		}
	}
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetParameterResponse = [2]string{
	0: "nosql",
	1: "is_ok",
}

// Decode decodes GetParameterResponse from json.
func (s *GetParameterResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParameterResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nosql":
			if err := func() error {
				s.Nosql.Reset()
				if err := s.Nosql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nosql\"")
			}
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetParameterResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParameterResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParameterResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetParameterResponseNosql) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetParameterResponseNosql) encodeFields(e *jx.Encoder) {
	{
		if s.Parameters != nil {
			e.FieldStart("parameters")
			e.ArrStart()
			for _, elem := range s.Parameters {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGetParameterResponseNosql = [1]string{
	0: "parameters",
}

// Decode decodes GetParameterResponseNosql from json.
func (s *GetParameterResponseNosql) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParameterResponseNosql to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "parameters":
			if err := func() error {
				s.Parameters = make([]NosqlGetParameter, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NosqlGetParameter
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Parameters = append(s.Parameters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetParameterResponseNosql")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParameterResponseNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParameterResponseNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Instance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Instance) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("Status")
			s.Status.Encode(e)
		}
	}
	{
		if s.StatusChangedAt.Set {
			e.FieldStart("StatusChangedAt")
			s.StatusChangedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Host.Set {
			e.FieldStart("Host")
			s.Host.Encode(e)
		}
	}
	{
		if s.Hosts != nil {
			e.FieldStart("Hosts")
			e.ArrStart()
			for _, elem := range s.Hosts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfInstance = [4]string{
	0: "Status",
	1: "StatusChangedAt",
	2: "Host",
	3: "Hosts",
}

// Decode decodes Instance from json.
func (s *Instance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Instance to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Status\"")
			}
		case "StatusChangedAt":
			if err := func() error {
				s.StatusChangedAt.Reset()
				if err := s.StatusChangedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"StatusChangedAt\"")
			}
		case "Host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Host\"")
			}
		case "Hosts":
			if err := func() error {
				s.Hosts = make([]InstanceHostsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InstanceHostsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Hosts = append(s.Hosts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Hosts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Instance")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Instance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Instance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InstanceHost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InstanceHost) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("Name")
			s.Name.Encode(e)
		}
	}
	{
		if s.InfoURL.Set {
			e.FieldStart("InfoURL")
			s.InfoURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfInstanceHost = [2]string{
	0: "Name",
	1: "InfoURL",
}

// Decode decodes InstanceHost from json.
func (s *InstanceHost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstanceHost to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Name\"")
			}
		case "InfoURL":
			if err := func() error {
				s.InfoURL.Reset()
				if err := s.InfoURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"InfoURL\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InstanceHost")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InstanceHost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InstanceHost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InstanceHostsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InstanceHostsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("Name")
			s.Name.Encode(e)
		}
	}
	{
		if s.InfoURL.Set {
			e.FieldStart("InfoURL")
			s.InfoURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfInstanceHostsItem = [2]string{
	0: "Name",
	1: "InfoURL",
}

// Decode decodes InstanceHostsItem from json.
func (s *InstanceHostsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstanceHostsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Name\"")
			}
		case "InfoURL":
			if err := func() error {
				s.InfoURL.Reset()
				if err := s.InfoURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"InfoURL\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InstanceHostsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InstanceHostsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InstanceHostsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IsOk as json.
func (s IsOk) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes IsOk from json.
func (s *IsOk) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IsOk to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IsOk(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IsOk) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IsOk) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlAppliance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlAppliance) encodeFields(e *jx.Encoder) {
	{
		if s.Class.Set {
			e.FieldStart("Class")
			s.Class.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("Name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("Description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Tags.Set {
			e.FieldStart("Tags")
			s.Tags.Encode(e)
		}
	}
	{
		e.FieldStart("ID")
		e.Str(s.ID)
	}
	{
		if s.Plan.Set {
			e.FieldStart("Plan")
			s.Plan.Encode(e)
		}
	}
	{
		if s.Settings.Set {
			e.FieldStart("Settings")
			s.Settings.Encode(e)
		}
	}
	{
		if s.SettingsHash.Set {
			e.FieldStart("SettingsHash")
			s.SettingsHash.Encode(e)
		}
	}
	{
		if s.Remark.Set {
			e.FieldStart("Remark")
			s.Remark.Encode(e)
		}
	}
	{
		if s.Availability.Set {
			e.FieldStart("Availability")
			s.Availability.Encode(e)
		}
	}
	{
		if s.Instance.Set {
			e.FieldStart("Instance")
			s.Instance.Encode(e)
		}
	}
	{
		if s.Disk.Set {
			e.FieldStart("Disk")
			s.Disk.Encode(e)
		}
	}
	{
		if s.ServiceClass.Set {
			e.FieldStart("ServiceClass")
			s.ServiceClass.Encode(e)
		}
	}
	{
		if s.Generation.Set {
			e.FieldStart("Generation")
			s.Generation.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("CreatedAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Interfaces != nil {
			e.FieldStart("Interfaces")
			e.ArrStart()
			for _, elem := range s.Interfaces {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNosqlAppliance = [16]string{
	0:  "Class",
	1:  "Name",
	2:  "Description",
	3:  "Tags",
	4:  "ID",
	5:  "Plan",
	6:  "Settings",
	7:  "SettingsHash",
	8:  "Remark",
	9:  "Availability",
	10: "Instance",
	11: "Disk",
	12: "ServiceClass",
	13: "Generation",
	14: "CreatedAt",
	15: "Interfaces",
}

// Decode decodes NosqlAppliance from json.
func (s *NosqlAppliance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlAppliance to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Class":
			if err := func() error {
				s.Class.Reset()
				if err := s.Class.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Class\"")
			}
		case "Name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Name\"")
			}
		case "Description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Description\"")
			}
		case "Tags":
			if err := func() error {
				s.Tags.Reset()
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Tags\"")
			}
		case "ID":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		case "Plan":
			if err := func() error {
				s.Plan.Reset()
				if err := s.Plan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Plan\"")
			}
		case "Settings":
			if err := func() error {
				s.Settings.Reset()
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Settings\"")
			}
		case "SettingsHash":
			if err := func() error {
				s.SettingsHash.Reset()
				if err := s.SettingsHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SettingsHash\"")
			}
		case "Remark":
			if err := func() error {
				s.Remark.Reset()
				if err := s.Remark.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Remark\"")
			}
		case "Availability":
			if err := func() error {
				s.Availability.Reset()
				if err := s.Availability.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Availability\"")
			}
		case "Instance":
			if err := func() error {
				s.Instance.Reset()
				if err := s.Instance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Instance\"")
			}
		case "Disk":
			if err := func() error {
				s.Disk.Reset()
				if err := s.Disk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Disk\"")
			}
		case "ServiceClass":
			if err := func() error {
				s.ServiceClass.Reset()
				if err := s.ServiceClass.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ServiceClass\"")
			}
		case "Generation":
			if err := func() error {
				s.Generation.Reset()
				if err := s.Generation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Generation\"")
			}
		case "CreatedAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"CreatedAt\"")
			}
		case "Interfaces":
			if err := func() error {
				s.Interfaces = make([]NosqlApplianceInterfacesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NosqlApplianceInterfacesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Interfaces = append(s.Interfaces, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Interfaces\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlAppliance")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlAppliance) {
					name = jsonFieldsNameOfNosqlAppliance[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlAppliance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlAppliance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlApplianceDisk) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlApplianceDisk) encodeFields(e *jx.Encoder) {
	{
		if s.EncryptionAlgorithm.Set {
			e.FieldStart("EncryptionAlgorithm")
			s.EncryptionAlgorithm.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlApplianceDisk = [1]string{
	0: "EncryptionAlgorithm",
}

// Decode decodes NosqlApplianceDisk from json.
func (s *NosqlApplianceDisk) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceDisk to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "EncryptionAlgorithm":
			if err := func() error {
				s.EncryptionAlgorithm.Reset()
				if err := s.EncryptionAlgorithm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"EncryptionAlgorithm\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlApplianceDisk")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlApplianceDisk) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceDisk) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlApplianceInterfacesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlApplianceInterfacesItem) encodeFields(e *jx.Encoder) {
	{
		if s.IPAddress.Set {
			e.FieldStart("IPAddress")
			s.IPAddress.Encode(e)
		}
	}
	{
		if s.UserIPAddress.Set {
			e.FieldStart("UserIPAddress")
			s.UserIPAddress.Encode(e)
		}
	}
	{
		if s.HostName.Set {
			e.FieldStart("HostName")
			s.HostName.Encode(e)
		}
	}
	{
		if s.Switch.Set {
			e.FieldStart("Switch")
			s.Switch.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlApplianceInterfacesItem = [4]string{
	0: "IPAddress",
	1: "UserIPAddress",
	2: "HostName",
	3: "Switch",
}

// Decode decodes NosqlApplianceInterfacesItem from json.
func (s *NosqlApplianceInterfacesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceInterfacesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "IPAddress":
			if err := func() error {
				s.IPAddress.Reset()
				if err := s.IPAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"IPAddress\"")
			}
		case "UserIPAddress":
			if err := func() error {
				s.UserIPAddress.Reset()
				if err := s.UserIPAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UserIPAddress\"")
			}
		case "HostName":
			if err := func() error {
				s.HostName.Reset()
				if err := s.HostName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"HostName\"")
			}
		case "Switch":
			if err := func() error {
				s.Switch.Reset()
				if err := s.Switch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Switch\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlApplianceInterfacesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlApplianceInterfacesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceInterfacesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlApplianceInterfacesItemSwitch) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlApplianceInterfacesItemSwitch) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ID")
		e.Str(s.ID)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Scope.Set {
			e.FieldStart("Scope")
			s.Scope.Encode(e)
		}
	}
	{
		if s.Subnet.Set {
			e.FieldStart("Subnet")
			s.Subnet.Encode(e)
		}
	}
	{
		if s.UserSubnet.Set {
			e.FieldStart("UserSubnet")
			s.UserSubnet.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlApplianceInterfacesItemSwitch = [5]string{
	0: "ID",
	1: "name",
	2: "Scope",
	3: "Subnet",
	4: "UserSubnet",
}

// Decode decodes NosqlApplianceInterfacesItemSwitch from json.
func (s *NosqlApplianceInterfacesItemSwitch) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceInterfacesItemSwitch to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ID":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "Scope":
			if err := func() error {
				s.Scope.Reset()
				if err := s.Scope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Scope\"")
			}
		case "Subnet":
			if err := func() error {
				s.Subnet.Reset()
				if err := s.Subnet.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Subnet\"")
			}
		case "UserSubnet":
			if err := func() error {
				s.UserSubnet.Reset()
				if err := s.UserSubnet.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UserSubnet\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlApplianceInterfacesItemSwitch")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlApplianceInterfacesItemSwitch) {
					name = jsonFieldsNameOfNosqlApplianceInterfacesItemSwitch[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlApplianceInterfacesItemSwitch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceInterfacesItemSwitch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlApplianceInterfacesItemSwitchSubnet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlApplianceInterfacesItemSwitchSubnet) encodeFields(e *jx.Encoder) {
	{
		if s.NetworkAddress.Set {
			e.FieldStart("NetworkAddress")
			s.NetworkAddress.Encode(e)
		}
	}
	{
		if s.NetworkMaskLen.Set {
			e.FieldStart("NetworkMaskLen")
			s.NetworkMaskLen.Encode(e)
		}
	}
	{
		if s.DefaultRoute.Set {
			e.FieldStart("DefaultRoute")
			s.DefaultRoute.Encode(e)
		}
	}
	{
		if s.Internet.Set {
			e.FieldStart("Internet")
			s.Internet.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlApplianceInterfacesItemSwitchSubnet = [4]string{
	0: "NetworkAddress",
	1: "NetworkMaskLen",
	2: "DefaultRoute",
	3: "Internet",
}

// Decode decodes NosqlApplianceInterfacesItemSwitchSubnet from json.
func (s *NosqlApplianceInterfacesItemSwitchSubnet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceInterfacesItemSwitchSubnet to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "NetworkAddress":
			if err := func() error {
				s.NetworkAddress.Reset()
				if err := s.NetworkAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"NetworkAddress\"")
			}
		case "NetworkMaskLen":
			if err := func() error {
				s.NetworkMaskLen.Reset()
				if err := s.NetworkMaskLen.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"NetworkMaskLen\"")
			}
		case "DefaultRoute":
			if err := func() error {
				s.DefaultRoute.Reset()
				if err := s.DefaultRoute.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DefaultRoute\"")
			}
		case "Internet":
			if err := func() error {
				s.Internet.Reset()
				if err := s.Internet.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Internet\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlApplianceInterfacesItemSwitchSubnet")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlApplianceInterfacesItemSwitchSubnet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceInterfacesItemSwitchSubnet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlApplianceInterfacesItemSwitchSubnetInternet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlApplianceInterfacesItemSwitchSubnetInternet) encodeFields(e *jx.Encoder) {
	{
		if s.BandWidthMbps.Set {
			e.FieldStart("BandWidthMbps")
			s.BandWidthMbps.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlApplianceInterfacesItemSwitchSubnetInternet = [1]string{
	0: "BandWidthMbps",
}

// Decode decodes NosqlApplianceInterfacesItemSwitchSubnetInternet from json.
func (s *NosqlApplianceInterfacesItemSwitchSubnetInternet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceInterfacesItemSwitchSubnetInternet to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "BandWidthMbps":
			if err := func() error {
				s.BandWidthMbps.Reset()
				if err := s.BandWidthMbps.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"BandWidthMbps\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlApplianceInterfacesItemSwitchSubnetInternet")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlApplianceInterfacesItemSwitchSubnetInternet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceInterfacesItemSwitchSubnetInternet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlApplianceInterfacesItemSwitchUserSubnet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlApplianceInterfacesItemSwitchUserSubnet) encodeFields(e *jx.Encoder) {
	{
		if s.DefaultRoute.Set {
			e.FieldStart("DefaultRoute")
			s.DefaultRoute.Encode(e)
		}
	}
	{
		if s.NetworkMaskLen.Set {
			e.FieldStart("NetworkMaskLen")
			s.NetworkMaskLen.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlApplianceInterfacesItemSwitchUserSubnet = [2]string{
	0: "DefaultRoute",
	1: "NetworkMaskLen",
}

// Decode decodes NosqlApplianceInterfacesItemSwitchUserSubnet from json.
func (s *NosqlApplianceInterfacesItemSwitchUserSubnet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceInterfacesItemSwitchUserSubnet to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "DefaultRoute":
			if err := func() error {
				s.DefaultRoute.Reset()
				if err := s.DefaultRoute.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DefaultRoute\"")
			}
		case "NetworkMaskLen":
			if err := func() error {
				s.NetworkMaskLen.Reset()
				if err := s.NetworkMaskLen.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"NetworkMaskLen\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlApplianceInterfacesItemSwitchUserSubnet")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlApplianceInterfacesItemSwitchUserSubnet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceInterfacesItemSwitchUserSubnet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlApplianceRemark) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlApplianceRemark) encodeFields(e *jx.Encoder) {
	{
		if s.Nosql.Set {
			e.FieldStart("Nosql")
			s.Nosql.Encode(e)
		}
	}
	{
		if s.Servers != nil {
			e.FieldStart("Servers")
			e.ArrStart()
			for _, elem := range s.Servers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Zone.Set {
			e.FieldStart("Zone")
			s.Zone.Encode(e)
		}
	}
	{
		if s.ServiceClass.Set {
			e.FieldStart("ServiceClass")
			s.ServiceClass.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlApplianceRemark = [4]string{
	0: "Nosql",
	1: "Servers",
	2: "Zone",
	3: "ServiceClass",
}

// Decode decodes NosqlApplianceRemark from json.
func (s *NosqlApplianceRemark) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceRemark to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Nosql":
			if err := func() error {
				s.Nosql.Reset()
				if err := s.Nosql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Nosql\"")
			}
		case "Servers":
			if err := func() error {
				s.Servers = make([]NosqlApplianceRemarkServersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NosqlApplianceRemarkServersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Servers = append(s.Servers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Servers\"")
			}
		case "Zone":
			if err := func() error {
				s.Zone.Reset()
				if err := s.Zone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Zone\"")
			}
		case "ServiceClass":
			if err := func() error {
				s.ServiceClass.Reset()
				if err := s.ServiceClass.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ServiceClass\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlApplianceRemark")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlApplianceRemark) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceRemark) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlApplianceRemarkNosql) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlApplianceRemarkNosql) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("DatabaseEngine")
		s.DatabaseEngine.Encode(e)
	}
	{
		e.FieldStart("DatabaseVersion")
		e.Str(s.DatabaseVersion)
	}
	{
		e.FieldStart("DefaultUser")
		e.Str(s.DefaultUser)
	}
	{
		e.FieldStart("DiskSize")
		s.DiskSize.Encode(e)
	}
	{
		e.FieldStart("Memory")
		s.Memory.Encode(e)
	}
	{
		e.FieldStart("Nodes")
		e.Int(s.Nodes)
	}
	{
		e.FieldStart("Port")
		e.Int(s.Port)
	}
	{
		e.FieldStart("Storage")
		s.Storage.Encode(e)
	}
	{
		e.FieldStart("Virtualcore")
		s.Virtualcore.Encode(e)
	}
	{
		e.FieldStart("Zone")
		e.Str(s.Zone)
	}
}

var jsonFieldsNameOfNosqlApplianceRemarkNosql = [10]string{
	0: "DatabaseEngine",
	1: "DatabaseVersion",
	2: "DefaultUser",
	3: "DiskSize",
	4: "Memory",
	5: "Nodes",
	6: "Port",
	7: "Storage",
	8: "Virtualcore",
	9: "Zone",
}

// Decode decodes NosqlApplianceRemarkNosql from json.
func (s *NosqlApplianceRemarkNosql) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceRemarkNosql to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "DatabaseEngine":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.DatabaseEngine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DatabaseEngine\"")
			}
		case "DatabaseVersion":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DatabaseVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DatabaseVersion\"")
			}
		case "DefaultUser":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DefaultUser = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DefaultUser\"")
			}
		case "DiskSize":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.DiskSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DiskSize\"")
			}
		case "Memory":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Memory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Memory\"")
			}
		case "Nodes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Nodes = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Nodes\"")
			}
		case "Port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Port\"")
			}
		case "Storage":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Storage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Storage\"")
			}
		case "Virtualcore":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Virtualcore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Virtualcore\"")
			}
		case "Zone":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Zone = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Zone\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlApplianceRemarkNosql")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlApplianceRemarkNosql) {
					name = jsonFieldsNameOfNosqlApplianceRemarkNosql[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlApplianceRemarkNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceRemarkNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceRemarkNosqlDatabaseEngine as json.
func (s NosqlApplianceRemarkNosqlDatabaseEngine) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NosqlApplianceRemarkNosqlDatabaseEngine from json.
func (s *NosqlApplianceRemarkNosqlDatabaseEngine) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceRemarkNosqlDatabaseEngine to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NosqlApplianceRemarkNosqlDatabaseEngine(v) {
	case NosqlApplianceRemarkNosqlDatabaseEngineCassandra:
		*s = NosqlApplianceRemarkNosqlDatabaseEngineCassandra
	default:
		*s = NosqlApplianceRemarkNosqlDatabaseEngine(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlApplianceRemarkNosqlDatabaseEngine) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceRemarkNosqlDatabaseEngine) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceRemarkNosqlDiskSize as json.
func (s NosqlApplianceRemarkNosqlDiskSize) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes NosqlApplianceRemarkNosqlDiskSize from json.
func (s *NosqlApplianceRemarkNosqlDiskSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceRemarkNosqlDiskSize to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = NosqlApplianceRemarkNosqlDiskSize(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlApplianceRemarkNosqlDiskSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceRemarkNosqlDiskSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceRemarkNosqlMemory as json.
func (s NosqlApplianceRemarkNosqlMemory) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes NosqlApplianceRemarkNosqlMemory from json.
func (s *NosqlApplianceRemarkNosqlMemory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceRemarkNosqlMemory to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = NosqlApplianceRemarkNosqlMemory(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlApplianceRemarkNosqlMemory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceRemarkNosqlMemory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceRemarkNosqlStorage as json.
func (s NosqlApplianceRemarkNosqlStorage) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NosqlApplianceRemarkNosqlStorage from json.
func (s *NosqlApplianceRemarkNosqlStorage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceRemarkNosqlStorage to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NosqlApplianceRemarkNosqlStorage(v) {
	case NosqlApplianceRemarkNosqlStorageSSD:
		*s = NosqlApplianceRemarkNosqlStorageSSD
	default:
		*s = NosqlApplianceRemarkNosqlStorage(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlApplianceRemarkNosqlStorage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceRemarkNosqlStorage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceRemarkNosqlVirtualcore as json.
func (s NosqlApplianceRemarkNosqlVirtualcore) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes NosqlApplianceRemarkNosqlVirtualcore from json.
func (s *NosqlApplianceRemarkNosqlVirtualcore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceRemarkNosqlVirtualcore to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = NosqlApplianceRemarkNosqlVirtualcore(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlApplianceRemarkNosqlVirtualcore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceRemarkNosqlVirtualcore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlApplianceRemarkServersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlApplianceRemarkServersItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("UserIPAddress")
		json.EncodeIPv4(e, s.UserIPAddress)
	}
}

var jsonFieldsNameOfNosqlApplianceRemarkServersItem = [1]string{
	0: "UserIPAddress",
}

// Decode decodes NosqlApplianceRemarkServersItem from json.
func (s *NosqlApplianceRemarkServersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceRemarkServersItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "UserIPAddress":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeIPv4(d)
				s.UserIPAddress = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UserIPAddress\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlApplianceRemarkServersItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlApplianceRemarkServersItem) {
					name = jsonFieldsNameOfNosqlApplianceRemarkServersItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlApplianceRemarkServersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceRemarkServersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlApplianceRemarkZone) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlApplianceRemarkZone) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("ID")
			s.ID.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlApplianceRemarkZone = [1]string{
	0: "ID",
}

// Decode decodes NosqlApplianceRemarkZone from json.
func (s *NosqlApplianceRemarkZone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceRemarkZone to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ID":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlApplianceRemarkZone")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlApplianceRemarkZone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceRemarkZone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlBackup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlBackup) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("backupId")
		json.EncodeUUID(e, s.BackupId)
	}
	{
		e.FieldStart("backupDestination")
		e.Str(s.BackupDestination)
	}
	{
		e.FieldStart("backupAt")
		json.EncodeDateTime(e, s.BackupAt)
	}
	{
		if s.RestoreAt.Set {
			e.FieldStart("restoreAt")
			s.RestoreAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("size")
		e.Int64(s.Size)
	}
	{
		if s.DeleteStatus.Set {
			e.FieldStart("deleteStatus")
			s.DeleteStatus.Encode(e)
		}
	}
	{
		if s.RestoreStatus.Set {
			e.FieldStart("restoreStatus")
			s.RestoreStatus.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlBackup = [7]string{
	0: "backupId",
	1: "backupDestination",
	2: "backupAt",
	3: "restoreAt",
	4: "size",
	5: "deleteStatus",
	6: "restoreStatus",
}

// Decode decodes NosqlBackup from json.
func (s *NosqlBackup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlBackup to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "backupId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.BackupId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backupId\"")
			}
		case "backupDestination":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.BackupDestination = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backupDestination\"")
			}
		case "backupAt":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.BackupAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backupAt\"")
			}
		case "restoreAt":
			if err := func() error {
				s.RestoreAt.Reset()
				if err := s.RestoreAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"restoreAt\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int64()
				s.Size = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "deleteStatus":
			if err := func() error {
				s.DeleteStatus.Reset()
				if err := s.DeleteStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deleteStatus\"")
			}
		case "restoreStatus":
			if err := func() error {
				s.RestoreStatus.Reset()
				if err := s.RestoreStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"restoreStatus\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlBackup")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlBackup) {
					name = jsonFieldsNameOfNosqlBackup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlBackup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlBackup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlBackupResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlBackupResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Nosql.Set {
			e.FieldStart("nosql")
			s.Nosql.Encode(e)
		}
	}
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlBackupResponse = [2]string{
	0: "nosql",
	1: "is_ok",
}

// Decode decodes NosqlBackupResponse from json.
func (s *NosqlBackupResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlBackupResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nosql":
			if err := func() error {
				s.Nosql.Reset()
				if err := s.Nosql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nosql\"")
			}
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlBackupResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlBackupResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlBackupResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlBackupResponseNosql) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlBackupResponseNosql) encodeFields(e *jx.Encoder) {
	{
		if s.Backups != nil {
			e.FieldStart("backups")
			e.ArrStart()
			for _, elem := range s.Backups {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNosqlBackupResponseNosql = [1]string{
	0: "backups",
}

// Decode decodes NosqlBackupResponseNosql from json.
func (s *NosqlBackupResponseNosql) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlBackupResponseNosql to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "backups":
			if err := func() error {
				s.Backups = make([]NosqlBackup, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NosqlBackup
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Backups = append(s.Backups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backups\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlBackupResponseNosql")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlBackupResponseNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlBackupResponseNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Appliance")
		s.Appliance.Encode(e)
	}
}

var jsonFieldsNameOfNosqlCreateRequest = [1]string{
	0: "Appliance",
}

// Decode decodes NosqlCreateRequest from json.
func (s *NosqlCreateRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Appliance":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Appliance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Appliance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlCreateRequest) {
					name = jsonFieldsNameOfNosqlCreateRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateRequestAppliance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateRequestAppliance) encodeFields(e *jx.Encoder) {
	{
		if s.Class.Set {
			e.FieldStart("Class")
			s.Class.Encode(e)
		}
	}
	{
		e.FieldStart("Name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("Description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Tags.Set {
			e.FieldStart("Tags")
			s.Tags.Encode(e)
		}
	}
	{
		if s.ServiceClass.Set {
			e.FieldStart("ServiceClass")
			s.ServiceClass.Encode(e)
		}
	}
	{
		if s.Plan.Set {
			e.FieldStart("Plan")
			s.Plan.Encode(e)
		}
	}
	{
		e.FieldStart("Settings")
		s.Settings.Encode(e)
	}
	{
		e.FieldStart("Remark")
		s.Remark.Encode(e)
	}
	{
		e.FieldStart("UserInterfaces")
		e.ArrStart()
		for _, elem := range s.UserInterfaces {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfNosqlCreateRequestAppliance = [9]string{
	0: "Class",
	1: "Name",
	2: "Description",
	3: "Tags",
	4: "ServiceClass",
	5: "Plan",
	6: "Settings",
	7: "Remark",
	8: "UserInterfaces",
}

// Decode decodes NosqlCreateRequestAppliance from json.
func (s *NosqlCreateRequestAppliance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateRequestAppliance to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Class":
			if err := func() error {
				s.Class.Reset()
				if err := s.Class.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Class\"")
			}
		case "Name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Name\"")
			}
		case "Description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Description\"")
			}
		case "Tags":
			if err := func() error {
				s.Tags.Reset()
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Tags\"")
			}
		case "ServiceClass":
			if err := func() error {
				s.ServiceClass.Reset()
				if err := s.ServiceClass.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ServiceClass\"")
			}
		case "Plan":
			if err := func() error {
				s.Plan.Reset()
				if err := s.Plan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Plan\"")
			}
		case "Settings":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Settings\"")
			}
		case "Remark":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Remark.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Remark\"")
			}
		case "UserInterfaces":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				s.UserInterfaces = make([]NosqlCreateRequestApplianceUserInterfacesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NosqlCreateRequestApplianceUserInterfacesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.UserInterfaces = append(s.UserInterfaces, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UserInterfaces\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateRequestAppliance")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11000010,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlCreateRequestAppliance) {
					name = jsonFieldsNameOfNosqlCreateRequestAppliance[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateRequestAppliance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateRequestAppliance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateRequestApplianceSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateRequestApplianceSettings) encodeFields(e *jx.Encoder) {
	{
		if s.Backup.Set {
			e.FieldStart("Backup")
			s.Backup.Encode(e)
		}
	}
	{
		if s.SourceNetwork != nil {
			e.FieldStart("SourceNetwork")
			e.ArrStart()
			for _, elem := range s.SourceNetwork {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("Password")
		s.Password.Encode(e)
	}
	{
		e.FieldStart("ReserveIPAddress")
		json.EncodeIPv4(e, s.ReserveIPAddress)
	}
}

var jsonFieldsNameOfNosqlCreateRequestApplianceSettings = [4]string{
	0: "Backup",
	1: "SourceNetwork",
	2: "Password",
	3: "ReserveIPAddress",
}

// Decode decodes NosqlCreateRequestApplianceSettings from json.
func (s *NosqlCreateRequestApplianceSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateRequestApplianceSettings to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Backup":
			if err := func() error {
				s.Backup.Reset()
				if err := s.Backup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Backup\"")
			}
		case "SourceNetwork":
			if err := func() error {
				s.SourceNetwork = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SourceNetwork = append(s.SourceNetwork, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SourceNetwork\"")
			}
		case "Password":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Password\"")
			}
		case "ReserveIPAddress":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeIPv4(d)
				s.ReserveIPAddress = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ReserveIPAddress\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateRequestApplianceSettings")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlCreateRequestApplianceSettings) {
					name = jsonFieldsNameOfNosqlCreateRequestApplianceSettings[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateRequestApplianceSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateRequestApplianceSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateRequestApplianceSettingsBackup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateRequestApplianceSettingsBackup) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Connect")
		e.Str(s.Connect)
	}
	{
		if s.DayOfWeek.Set {
			e.FieldStart("DayOfWeek")
			s.DayOfWeek.Encode(e)
		}
	}
	{
		if s.Time.Set {
			e.FieldStart("Time")
			s.Time.Encode(e)
		}
	}
	{
		if s.Rotate.Set {
			e.FieldStart("Rotate")
			s.Rotate.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlCreateRequestApplianceSettingsBackup = [4]string{
	0: "Connect",
	1: "DayOfWeek",
	2: "Time",
	3: "Rotate",
}

// Decode decodes NosqlCreateRequestApplianceSettingsBackup from json.
func (s *NosqlCreateRequestApplianceSettingsBackup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateRequestApplianceSettingsBackup to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Connect":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Connect = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Connect\"")
			}
		case "DayOfWeek":
			if err := func() error {
				s.DayOfWeek.Reset()
				if err := s.DayOfWeek.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DayOfWeek\"")
			}
		case "Time":
			if err := func() error {
				s.Time.Reset()
				if err := s.Time.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Time\"")
			}
		case "Rotate":
			if err := func() error {
				s.Rotate.Reset()
				if err := s.Rotate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Rotate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateRequestApplianceSettingsBackup")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlCreateRequestApplianceSettingsBackup) {
					name = jsonFieldsNameOfNosqlCreateRequestApplianceSettingsBackup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateRequestApplianceSettingsBackup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateRequestApplianceSettingsBackup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem as json.
func (s NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem from json.
func (s *NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem(v) {
	case NosqlCreateRequestApplianceSettingsBackupDayOfWeekItemSun:
		*s = NosqlCreateRequestApplianceSettingsBackupDayOfWeekItemSun
	case NosqlCreateRequestApplianceSettingsBackupDayOfWeekItemMon:
		*s = NosqlCreateRequestApplianceSettingsBackupDayOfWeekItemMon
	case NosqlCreateRequestApplianceSettingsBackupDayOfWeekItemTue:
		*s = NosqlCreateRequestApplianceSettingsBackupDayOfWeekItemTue
	case NosqlCreateRequestApplianceSettingsBackupDayOfWeekItemWed:
		*s = NosqlCreateRequestApplianceSettingsBackupDayOfWeekItemWed
	case NosqlCreateRequestApplianceSettingsBackupDayOfWeekItemThu:
		*s = NosqlCreateRequestApplianceSettingsBackupDayOfWeekItemThu
	case NosqlCreateRequestApplianceSettingsBackupDayOfWeekItemFri:
		*s = NosqlCreateRequestApplianceSettingsBackupDayOfWeekItemFri
	case NosqlCreateRequestApplianceSettingsBackupDayOfWeekItemSat:
		*s = NosqlCreateRequestApplianceSettingsBackupDayOfWeekItemSat
	default:
		*s = NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateRequestApplianceUserInterfacesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateRequestApplianceUserInterfacesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Switch")
		s.Switch.Encode(e)
	}
	{
		e.FieldStart("UserIPAddress1")
		json.EncodeIPv4(e, s.UserIPAddress1)
	}
	{
		if s.UserIPAddress2.Set {
			e.FieldStart("UserIPAddress2")
			s.UserIPAddress2.Encode(e)
		}
	}
	{
		if s.UserIPAddress3.Set {
			e.FieldStart("UserIPAddress3")
			s.UserIPAddress3.Encode(e)
		}
	}
	{
		if s.UserSubnet.Set {
			e.FieldStart("UserSubnet")
			s.UserSubnet.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlCreateRequestApplianceUserInterfacesItem = [5]string{
	0: "Switch",
	1: "UserIPAddress1",
	2: "UserIPAddress2",
	3: "UserIPAddress3",
	4: "UserSubnet",
}

// Decode decodes NosqlCreateRequestApplianceUserInterfacesItem from json.
func (s *NosqlCreateRequestApplianceUserInterfacesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateRequestApplianceUserInterfacesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Switch":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Switch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Switch\"")
			}
		case "UserIPAddress1":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeIPv4(d)
				s.UserIPAddress1 = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UserIPAddress1\"")
			}
		case "UserIPAddress2":
			if err := func() error {
				s.UserIPAddress2.Reset()
				if err := s.UserIPAddress2.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UserIPAddress2\"")
			}
		case "UserIPAddress3":
			if err := func() error {
				s.UserIPAddress3.Reset()
				if err := s.UserIPAddress3.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UserIPAddress3\"")
			}
		case "UserSubnet":
			if err := func() error {
				s.UserSubnet.Reset()
				if err := s.UserSubnet.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UserSubnet\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateRequestApplianceUserInterfacesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlCreateRequestApplianceUserInterfacesItem) {
					name = jsonFieldsNameOfNosqlCreateRequestApplianceUserInterfacesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateRequestApplianceUserInterfacesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateRequestApplianceUserInterfacesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateRequestApplianceUserInterfacesItemSwitch) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateRequestApplianceUserInterfacesItemSwitch) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ID")
		e.Str(s.ID)
	}
}

var jsonFieldsNameOfNosqlCreateRequestApplianceUserInterfacesItemSwitch = [1]string{
	0: "ID",
}

// Decode decodes NosqlCreateRequestApplianceUserInterfacesItemSwitch from json.
func (s *NosqlCreateRequestApplianceUserInterfacesItemSwitch) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateRequestApplianceUserInterfacesItemSwitch to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ID":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateRequestApplianceUserInterfacesItemSwitch")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlCreateRequestApplianceUserInterfacesItemSwitch) {
					name = jsonFieldsNameOfNosqlCreateRequestApplianceUserInterfacesItemSwitch[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateRequestApplianceUserInterfacesItemSwitch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateRequestApplianceUserInterfacesItemSwitch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateRequestApplianceUserInterfacesItemUserSubnet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateRequestApplianceUserInterfacesItemUserSubnet) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("DefaultRoute")
		e.Str(s.DefaultRoute)
	}
	{
		e.FieldStart("NetworkMaskLen")
		e.Int(s.NetworkMaskLen)
	}
}

var jsonFieldsNameOfNosqlCreateRequestApplianceUserInterfacesItemUserSubnet = [2]string{
	0: "DefaultRoute",
	1: "NetworkMaskLen",
}

// Decode decodes NosqlCreateRequestApplianceUserInterfacesItemUserSubnet from json.
func (s *NosqlCreateRequestApplianceUserInterfacesItemUserSubnet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateRequestApplianceUserInterfacesItemUserSubnet to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "DefaultRoute":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DefaultRoute = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DefaultRoute\"")
			}
		case "NetworkMaskLen":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.NetworkMaskLen = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"NetworkMaskLen\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateRequestApplianceUserInterfacesItemUserSubnet")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlCreateRequestApplianceUserInterfacesItemUserSubnet) {
					name = jsonFieldsNameOfNosqlCreateRequestApplianceUserInterfacesItemUserSubnet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateRequestApplianceUserInterfacesItemUserSubnet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateRequestApplianceUserInterfacesItemUserSubnet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Appliance")
		s.Appliance.Encode(e)
	}
	{
		if s.Class.Set {
			e.FieldStart("Class")
			s.Class.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("Name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("Description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Plan.Set {
			e.FieldStart("Plan")
			s.Plan.Encode(e)
		}
	}
	{
		if s.Settings.Set {
			e.FieldStart("Settings")
			s.Settings.Encode(e)
		}
	}
	{
		if s.Remark.Set {
			e.FieldStart("Remark")
			s.Remark.Encode(e)
		}
	}
	{
		e.FieldStart("ID")
		e.Str(s.ID)
	}
	{
		if s.Account.Set {
			e.FieldStart("Account")
			s.Account.Encode(e)
		}
	}
	{
		if s.Tags.Set {
			e.FieldStart("Tags")
			s.Tags.Encode(e)
		}
	}
	{
		if s.Availability.Set {
			e.FieldStart("Availability")
			s.Availability.Encode(e)
		}
	}
	{
		if s.ServerCount.Set {
			e.FieldStart("ServerCount")
			s.ServerCount.Encode(e)
		}
	}
	{
		if s.HiddenRemark.Set {
			e.FieldStart("HiddenRemark")
			s.HiddenRemark.Encode(e)
		}
	}
	{
		if s.Success.Set {
			e.FieldStart("Success")
			s.Success.Encode(e)
		}
	}
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlCreateResponse = [15]string{
	0:  "Appliance",
	1:  "Class",
	2:  "Name",
	3:  "Description",
	4:  "Plan",
	5:  "Settings",
	6:  "Remark",
	7:  "ID",
	8:  "Account",
	9:  "Tags",
	10: "Availability",
	11: "ServerCount",
	12: "HiddenRemark",
	13: "Success",
	14: "is_ok",
}

// Decode decodes NosqlCreateResponse from json.
func (s *NosqlCreateResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateResponse to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Appliance":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Appliance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Appliance\"")
			}
		case "Class":
			if err := func() error {
				s.Class.Reset()
				if err := s.Class.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Class\"")
			}
		case "Name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Name\"")
			}
		case "Description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Description\"")
			}
		case "Plan":
			if err := func() error {
				s.Plan.Reset()
				if err := s.Plan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Plan\"")
			}
		case "Settings":
			if err := func() error {
				s.Settings.Reset()
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Settings\"")
			}
		case "Remark":
			if err := func() error {
				s.Remark.Reset()
				if err := s.Remark.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Remark\"")
			}
		case "ID":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		case "Account":
			if err := func() error {
				s.Account.Reset()
				if err := s.Account.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Account\"")
			}
		case "Tags":
			if err := func() error {
				s.Tags.Reset()
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Tags\"")
			}
		case "Availability":
			if err := func() error {
				s.Availability.Reset()
				if err := s.Availability.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Availability\"")
			}
		case "ServerCount":
			if err := func() error {
				s.ServerCount.Reset()
				if err := s.ServerCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ServerCount\"")
			}
		case "HiddenRemark":
			if err := func() error {
				s.HiddenRemark.Reset()
				if err := s.HiddenRemark.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"HiddenRemark\"")
			}
		case "Success":
			if err := func() error {
				s.Success.Reset()
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Success\"")
			}
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlCreateResponse) {
					name = jsonFieldsNameOfNosqlCreateResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateResponseAccount) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateResponseAccount) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("ID")
			s.ID.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlCreateResponseAccount = [1]string{
	0: "ID",
}

// Decode decodes NosqlCreateResponseAccount from json.
func (s *NosqlCreateResponseAccount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateResponseAccount to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ID":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateResponseAccount")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateResponseAccount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateResponseAccount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateResponseHiddenRemark) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateResponseHiddenRemark) encodeFields(e *jx.Encoder) {
	{
		if s.PlanSpec.Set {
			e.FieldStart("PlanSpec")
			s.PlanSpec.Encode(e)
		}
	}
	{
		if s.Encripted.Set {
			e.FieldStart("Encripted")
			s.Encripted.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlCreateResponseHiddenRemark = [2]string{
	0: "PlanSpec",
	1: "Encripted",
}

// Decode decodes NosqlCreateResponseHiddenRemark from json.
func (s *NosqlCreateResponseHiddenRemark) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateResponseHiddenRemark to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "PlanSpec":
			if err := func() error {
				s.PlanSpec.Reset()
				if err := s.PlanSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PlanSpec\"")
			}
		case "Encripted":
			if err := func() error {
				s.Encripted.Reset()
				if err := s.Encripted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Encripted\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateResponseHiddenRemark")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateResponseHiddenRemark) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateResponseHiddenRemark) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateResponseHiddenRemarkEncripted) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateResponseHiddenRemarkEncripted) encodeFields(e *jx.Encoder) {
	{
		if s.Algorithm.Set {
			e.FieldStart("Algorithm")
			s.Algorithm.Encode(e)
		}
	}
	{
		if s.IV.Set {
			e.FieldStart("IV")
			s.IV.Encode(e)
		}
	}
	{
		if s.MD5.Set {
			e.FieldStart("md5")
			s.MD5.Encode(e)
		}
	}
	{
		if s.Associative.Set {
			e.FieldStart("Associative")
			s.Associative.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("Data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlCreateResponseHiddenRemarkEncripted = [5]string{
	0: "Algorithm",
	1: "IV",
	2: "md5",
	3: "Associative",
	4: "Data",
}

// Decode decodes NosqlCreateResponseHiddenRemarkEncripted from json.
func (s *NosqlCreateResponseHiddenRemarkEncripted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateResponseHiddenRemarkEncripted to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Algorithm":
			if err := func() error {
				s.Algorithm.Reset()
				if err := s.Algorithm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Algorithm\"")
			}
		case "IV":
			if err := func() error {
				s.IV.Reset()
				if err := s.IV.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"IV\"")
			}
		case "md5":
			if err := func() error {
				s.MD5.Reset()
				if err := s.MD5.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"md5\"")
			}
		case "Associative":
			if err := func() error {
				s.Associative.Reset()
				if err := s.Associative.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Associative\"")
			}
		case "Data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateResponseHiddenRemarkEncripted")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateResponseHiddenRemarkEncripted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateResponseHiddenRemarkEncripted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateResponseHiddenRemarkPlanSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateResponseHiddenRemarkPlanSpec) encodeFields(e *jx.Encoder) {
	{
		if s.Note.Set {
			e.FieldStart("Note")
			s.Note.Encode(e)
		}
	}
	{
		if s.ServiceClass.Set {
			e.FieldStart("ServiceClass")
			s.ServiceClass.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlCreateResponseHiddenRemarkPlanSpec = [2]string{
	0: "Note",
	1: "ServiceClass",
}

// Decode decodes NosqlCreateResponseHiddenRemarkPlanSpec from json.
func (s *NosqlCreateResponseHiddenRemarkPlanSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateResponseHiddenRemarkPlanSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Note":
			if err := func() error {
				s.Note.Reset()
				if err := s.Note.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Note\"")
			}
		case "ServiceClass":
			if err := func() error {
				s.ServiceClass.Reset()
				if err := s.ServiceClass.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ServiceClass\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateResponseHiddenRemarkPlanSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateResponseHiddenRemarkPlanSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateResponseHiddenRemarkPlanSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateResponseHiddenRemarkPlanSpecNote) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateResponseHiddenRemarkPlanSpecNote) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("ID")
			s.ID.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlCreateResponseHiddenRemarkPlanSpecNote = [1]string{
	0: "ID",
}

// Decode decodes NosqlCreateResponseHiddenRemarkPlanSpecNote from json.
func (s *NosqlCreateResponseHiddenRemarkPlanSpecNote) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateResponseHiddenRemarkPlanSpecNote to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ID":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateResponseHiddenRemarkPlanSpecNote")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateResponseHiddenRemarkPlanSpecNote) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateResponseHiddenRemarkPlanSpecNote) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlGetParameter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlGetParameter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("settingItemId")
		e.Str(s.SettingItemId)
	}
	{
		e.FieldStart("settingItem")
		e.Str(s.SettingItem)
	}
	{
		if s.DefaultValue.Set {
			e.FieldStart("defaultValue")
			s.DefaultValue.Encode(e)
		}
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.ParameterOptions != nil {
			e.FieldStart("parameterOptions")
			e.ArrStart()
			for _, elem := range s.ParameterOptions {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SettingValue.Set {
			e.FieldStart("settingValue")
			s.SettingValue.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlGetParameter = [6]string{
	0: "settingItemId",
	1: "settingItem",
	2: "defaultValue",
	3: "description",
	4: "parameterOptions",
	5: "settingValue",
}

// Decode decodes NosqlGetParameter from json.
func (s *NosqlGetParameter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlGetParameter to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "settingItemId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SettingItemId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settingItemId\"")
			}
		case "settingItem":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SettingItem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settingItem\"")
			}
		case "defaultValue":
			if err := func() error {
				s.DefaultValue.Reset()
				if err := s.DefaultValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultValue\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "parameterOptions":
			if err := func() error {
				s.ParameterOptions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ParameterOptions = append(s.ParameterOptions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameterOptions\"")
			}
		case "settingValue":
			if err := func() error {
				s.SettingValue.Reset()
				if err := s.SettingValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settingValue\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlGetParameter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlGetParameter) {
					name = jsonFieldsNameOfNosqlGetParameter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlGetParameter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlGetParameter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlGetResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlGetResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Appliance.Set {
			e.FieldStart("Appliance")
			s.Appliance.Encode(e)
		}
	}
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlGetResponse = [2]string{
	0: "Appliance",
	1: "is_ok",
}

// Decode decodes NosqlGetResponse from json.
func (s *NosqlGetResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlGetResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Appliance":
			if err := func() error {
				s.Appliance.Reset()
				if err := s.Appliance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Appliance\"")
			}
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlGetResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlGetResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlGetResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlGetVersionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlGetVersionResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Nosql.Set {
			e.FieldStart("nosql")
			s.Nosql.Encode(e)
		}
	}
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlGetVersionResponse = [2]string{
	0: "nosql",
	1: "is_ok",
}

// Decode decodes NosqlGetVersionResponse from json.
func (s *NosqlGetVersionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlGetVersionResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nosql":
			if err := func() error {
				s.Nosql.Reset()
				if err := s.Nosql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nosql\"")
			}
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlGetVersionResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlGetVersionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlGetVersionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlGetVersionResponseNosql) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlGetVersionResponseNosql) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("DatabaseVersion")
		e.Str(s.DatabaseVersion)
	}
	{
		e.FieldStart("UpgradableVersions")
		e.ArrStart()
		for _, elem := range s.UpgradableVersions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfNosqlGetVersionResponseNosql = [2]string{
	0: "DatabaseVersion",
	1: "UpgradableVersions",
}

// Decode decodes NosqlGetVersionResponseNosql from json.
func (s *NosqlGetVersionResponseNosql) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlGetVersionResponseNosql to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "DatabaseVersion":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DatabaseVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DatabaseVersion\"")
			}
		case "UpgradableVersions":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.UpgradableVersions = make([]NosqlGetVersionResponseNosqlUpgradableVersionsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NosqlGetVersionResponseNosqlUpgradableVersionsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.UpgradableVersions = append(s.UpgradableVersions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UpgradableVersions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlGetVersionResponseNosql")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlGetVersionResponseNosql) {
					name = jsonFieldsNameOfNosqlGetVersionResponseNosql[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlGetVersionResponseNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlGetVersionResponseNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlGetVersionResponseNosqlUpgradableVersionsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlGetVersionResponseNosqlUpgradableVersionsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
}

var jsonFieldsNameOfNosqlGetVersionResponseNosqlUpgradableVersionsItem = [1]string{
	0: "version",
}

// Decode decodes NosqlGetVersionResponseNosqlUpgradableVersionsItem from json.
func (s *NosqlGetVersionResponseNosqlUpgradableVersionsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlGetVersionResponseNosqlUpgradableVersionsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlGetVersionResponseNosqlUpgradableVersionsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlGetVersionResponseNosqlUpgradableVersionsItem) {
					name = jsonFieldsNameOfNosqlGetVersionResponseNosqlUpgradableVersionsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlGetVersionResponseNosqlUpgradableVersionsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlGetVersionResponseNosqlUpgradableVersionsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlIsOkResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlIsOkResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Nosql.Set {
			e.FieldStart("Nosql")
			s.Nosql.Encode(e)
		}
	}
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlIsOkResponse = [2]string{
	0: "Nosql",
	1: "is_ok",
}

// Decode decodes NosqlIsOkResponse from json.
func (s *NosqlIsOkResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlIsOkResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Nosql":
			if err := func() error {
				s.Nosql.Reset()
				if err := s.Nosql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Nosql\"")
			}
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlIsOkResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlIsOkResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlIsOkResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlIsOkResponseNosql) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlIsOkResponseNosql) encodeFields(e *jx.Encoder) {
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlIsOkResponseNosql = [1]string{
	0: "is_ok",
}

// Decode decodes NosqlIsOkResponseNosql from json.
func (s *NosqlIsOkResponseNosql) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlIsOkResponseNosql to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlIsOkResponseNosql")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlIsOkResponseNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlIsOkResponseNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlListResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("From")
		e.Int(s.From)
	}
	{
		e.FieldStart("Count")
		e.Int(s.Count)
	}
	{
		e.FieldStart("Total")
		e.Int(s.Total)
	}
	{
		e.FieldStart("Appliances")
		e.ArrStart()
		for _, elem := range s.Appliances {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlListResponse = [5]string{
	0: "From",
	1: "Count",
	2: "Total",
	3: "Appliances",
	4: "is_ok",
}

// Decode decodes NosqlListResponse from json.
func (s *NosqlListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlListResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "From":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.From = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"From\"")
			}
		case "Count":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Count = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Count\"")
			}
		case "Total":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Total\"")
			}
		case "Appliances":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Appliances = make([]NosqlAppliance, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NosqlAppliance
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Appliances = append(s.Appliances, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Appliances\"")
			}
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlListResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlListResponse) {
					name = jsonFieldsNameOfNosqlListResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlOkResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlOkResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Nosql.Set {
			e.FieldStart("nosql")
			s.Nosql.Encode(e)
		}
	}
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlOkResponse = [2]string{
	0: "nosql",
	1: "is_ok",
}

// Decode decodes NosqlOkResponse from json.
func (s *NosqlOkResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlOkResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nosql":
			if err := func() error {
				s.Nosql.Reset()
				if err := s.Nosql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nosql\"")
			}
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlOkResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlOkResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlOkResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlOkResponseNosql) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlOkResponseNosql) encodeFields(e *jx.Encoder) {
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlOkResponseNosql = [1]string{
	0: "is_ok",
}

// Decode decodes NosqlOkResponseNosql from json.
func (s *NosqlOkResponseNosql) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlOkResponseNosql to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlOkResponseNosql")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlOkResponseNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlOkResponseNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlPutParameter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlPutParameter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("settingItemId")
		e.Str(s.SettingItemId)
	}
	{
		e.FieldStart("settingValue")
		e.Str(s.SettingValue)
	}
}

var jsonFieldsNameOfNosqlPutParameter = [2]string{
	0: "settingItemId",
	1: "settingValue",
}

// Decode decodes NosqlPutParameter from json.
func (s *NosqlPutParameter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlPutParameter to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "settingItemId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SettingItemId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settingItemId\"")
			}
		case "settingValue":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SettingValue = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settingValue\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlPutParameter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlPutParameter) {
					name = jsonFieldsNameOfNosqlPutParameter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlPutParameter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlPutParameter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlPutVersionRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlPutVersionRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nosql")
		s.Nosql.Encode(e)
	}
}

var jsonFieldsNameOfNosqlPutVersionRequest = [1]string{
	0: "nosql",
}

// Decode decodes NosqlPutVersionRequest from json.
func (s *NosqlPutVersionRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlPutVersionRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nosql":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Nosql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nosql\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlPutVersionRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlPutVersionRequest) {
					name = jsonFieldsNameOfNosqlPutVersionRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlPutVersionRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlPutVersionRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlPutVersionRequestNosql) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlPutVersionRequestNosql) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
}

var jsonFieldsNameOfNosqlPutVersionRequestNosql = [1]string{
	0: "version",
}

// Decode decodes NosqlPutVersionRequestNosql from json.
func (s *NosqlPutVersionRequestNosql) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlPutVersionRequestNosql to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlPutVersionRequestNosql")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlPutVersionRequestNosql) {
					name = jsonFieldsNameOfNosqlPutVersionRequestNosql[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlPutVersionRequestNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlPutVersionRequestNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlPutVersionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlPutVersionResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Nosql.Set {
			e.FieldStart("nosql")
			s.Nosql.Encode(e)
		}
	}
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlPutVersionResponse = [2]string{
	0: "nosql",
	1: "is_ok",
}

// Decode decodes NosqlPutVersionResponse from json.
func (s *NosqlPutVersionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlPutVersionResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nosql":
			if err := func() error {
				s.Nosql.Reset()
				if err := s.Nosql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nosql\"")
			}
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlPutVersionResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlPutVersionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlPutVersionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlPutVersionResponseNosql) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlPutVersionResponseNosql) encodeFields(e *jx.Encoder) {
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlPutVersionResponseNosql = [1]string{
	0: "version",
}

// Decode decodes NosqlPutVersionResponseNosql from json.
func (s *NosqlPutVersionResponseNosql) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlPutVersionResponseNosql to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlPutVersionResponseNosql")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlPutVersionResponseNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlPutVersionResponseNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlRemark) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlRemark) encodeFields(e *jx.Encoder) {
	{
		if s.Nosql.Set {
			e.FieldStart("Nosql")
			s.Nosql.Encode(e)
		}
	}
	{
		if s.Servers != nil {
			e.FieldStart("Servers")
			e.ArrStart()
			for _, elem := range s.Servers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNosqlRemark = [2]string{
	0: "Nosql",
	1: "Servers",
}

// Decode decodes NosqlRemark from json.
func (s *NosqlRemark) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlRemark to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Nosql":
			if err := func() error {
				s.Nosql.Reset()
				if err := s.Nosql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Nosql\"")
			}
		case "Servers":
			if err := func() error {
				s.Servers = make([]NosqlRemarkServersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NosqlRemarkServersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Servers = append(s.Servers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Servers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlRemark")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlRemark) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlRemark) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlRemarkNosql) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlRemarkNosql) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("DatabaseEngine")
		s.DatabaseEngine.Encode(e)
	}
	{
		e.FieldStart("DatabaseVersion")
		e.Str(s.DatabaseVersion)
	}
	{
		e.FieldStart("DefaultUser")
		e.Str(s.DefaultUser)
	}
	{
		e.FieldStart("DiskSize")
		s.DiskSize.Encode(e)
	}
	{
		e.FieldStart("Memory")
		s.Memory.Encode(e)
	}
	{
		e.FieldStart("Nodes")
		e.Int(s.Nodes)
	}
	{
		e.FieldStart("Port")
		e.Int(s.Port)
	}
	{
		e.FieldStart("Storage")
		s.Storage.Encode(e)
	}
	{
		e.FieldStart("Virtualcore")
		s.Virtualcore.Encode(e)
	}
	{
		e.FieldStart("Zone")
		e.Str(s.Zone)
	}
}

var jsonFieldsNameOfNosqlRemarkNosql = [10]string{
	0: "DatabaseEngine",
	1: "DatabaseVersion",
	2: "DefaultUser",
	3: "DiskSize",
	4: "Memory",
	5: "Nodes",
	6: "Port",
	7: "Storage",
	8: "Virtualcore",
	9: "Zone",
}

// Decode decodes NosqlRemarkNosql from json.
func (s *NosqlRemarkNosql) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlRemarkNosql to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "DatabaseEngine":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.DatabaseEngine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DatabaseEngine\"")
			}
		case "DatabaseVersion":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DatabaseVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DatabaseVersion\"")
			}
		case "DefaultUser":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DefaultUser = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DefaultUser\"")
			}
		case "DiskSize":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.DiskSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DiskSize\"")
			}
		case "Memory":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Memory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Memory\"")
			}
		case "Nodes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Nodes = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Nodes\"")
			}
		case "Port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Port\"")
			}
		case "Storage":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Storage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Storage\"")
			}
		case "Virtualcore":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Virtualcore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Virtualcore\"")
			}
		case "Zone":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Zone = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Zone\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlRemarkNosql")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlRemarkNosql) {
					name = jsonFieldsNameOfNosqlRemarkNosql[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlRemarkNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlRemarkNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlRemarkNosqlDatabaseEngine as json.
func (s NosqlRemarkNosqlDatabaseEngine) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NosqlRemarkNosqlDatabaseEngine from json.
func (s *NosqlRemarkNosqlDatabaseEngine) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlRemarkNosqlDatabaseEngine to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NosqlRemarkNosqlDatabaseEngine(v) {
	case NosqlRemarkNosqlDatabaseEngineCassandra:
		*s = NosqlRemarkNosqlDatabaseEngineCassandra
	default:
		*s = NosqlRemarkNosqlDatabaseEngine(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlRemarkNosqlDatabaseEngine) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlRemarkNosqlDatabaseEngine) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlRemarkNosqlDiskSize as json.
func (s NosqlRemarkNosqlDiskSize) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes NosqlRemarkNosqlDiskSize from json.
func (s *NosqlRemarkNosqlDiskSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlRemarkNosqlDiskSize to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = NosqlRemarkNosqlDiskSize(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlRemarkNosqlDiskSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlRemarkNosqlDiskSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlRemarkNosqlMemory as json.
func (s NosqlRemarkNosqlMemory) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes NosqlRemarkNosqlMemory from json.
func (s *NosqlRemarkNosqlMemory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlRemarkNosqlMemory to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = NosqlRemarkNosqlMemory(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlRemarkNosqlMemory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlRemarkNosqlMemory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlRemarkNosqlStorage as json.
func (s NosqlRemarkNosqlStorage) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NosqlRemarkNosqlStorage from json.
func (s *NosqlRemarkNosqlStorage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlRemarkNosqlStorage to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NosqlRemarkNosqlStorage(v) {
	case NosqlRemarkNosqlStorageSSD:
		*s = NosqlRemarkNosqlStorageSSD
	default:
		*s = NosqlRemarkNosqlStorage(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlRemarkNosqlStorage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlRemarkNosqlStorage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlRemarkNosqlVirtualcore as json.
func (s NosqlRemarkNosqlVirtualcore) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes NosqlRemarkNosqlVirtualcore from json.
func (s *NosqlRemarkNosqlVirtualcore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlRemarkNosqlVirtualcore to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = NosqlRemarkNosqlVirtualcore(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlRemarkNosqlVirtualcore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlRemarkNosqlVirtualcore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlRemarkServersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlRemarkServersItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("UserIPAddress")
		json.EncodeIPv4(e, s.UserIPAddress)
	}
}

var jsonFieldsNameOfNosqlRemarkServersItem = [1]string{
	0: "UserIPAddress",
}

// Decode decodes NosqlRemarkServersItem from json.
func (s *NosqlRemarkServersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlRemarkServersItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "UserIPAddress":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeIPv4(d)
				s.UserIPAddress = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UserIPAddress\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlRemarkServersItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlRemarkServersItem) {
					name = jsonFieldsNameOfNosqlRemarkServersItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlRemarkServersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlRemarkServersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlSettings) encodeFields(e *jx.Encoder) {
	{
		if s.Backup.Set {
			e.FieldStart("Backup")
			s.Backup.Encode(e)
		}
	}
	{
		if s.SourceNetwork != nil {
			e.FieldStart("SourceNetwork")
			e.ArrStart()
			for _, elem := range s.SourceNetwork {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNosqlSettings = [2]string{
	0: "Backup",
	1: "SourceNetwork",
}

// Decode decodes NosqlSettings from json.
func (s *NosqlSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Backup":
			if err := func() error {
				s.Backup.Reset()
				if err := s.Backup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Backup\"")
			}
		case "SourceNetwork":
			if err := func() error {
				s.SourceNetwork = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SourceNetwork = append(s.SourceNetwork, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SourceNetwork\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlSettingsBackup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlSettingsBackup) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Connect")
		e.Str(s.Connect)
	}
	{
		if s.DayOfWeek.Set {
			e.FieldStart("DayOfWeek")
			s.DayOfWeek.Encode(e)
		}
	}
	{
		if s.Time.Set {
			e.FieldStart("Time")
			s.Time.Encode(e)
		}
	}
	{
		if s.Rotate.Set {
			e.FieldStart("Rotate")
			s.Rotate.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlSettingsBackup = [4]string{
	0: "Connect",
	1: "DayOfWeek",
	2: "Time",
	3: "Rotate",
}

// Decode decodes NosqlSettingsBackup from json.
func (s *NosqlSettingsBackup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlSettingsBackup to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Connect":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Connect = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Connect\"")
			}
		case "DayOfWeek":
			if err := func() error {
				s.DayOfWeek.Reset()
				if err := s.DayOfWeek.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DayOfWeek\"")
			}
		case "Time":
			if err := func() error {
				s.Time.Reset()
				if err := s.Time.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Time\"")
			}
		case "Rotate":
			if err := func() error {
				s.Rotate.Reset()
				if err := s.Rotate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Rotate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlSettingsBackup")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlSettingsBackup) {
					name = jsonFieldsNameOfNosqlSettingsBackup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlSettingsBackup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlSettingsBackup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlSettingsBackupDayOfWeekItem as json.
func (s NosqlSettingsBackupDayOfWeekItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NosqlSettingsBackupDayOfWeekItem from json.
func (s *NosqlSettingsBackupDayOfWeekItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlSettingsBackupDayOfWeekItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NosqlSettingsBackupDayOfWeekItem(v) {
	case NosqlSettingsBackupDayOfWeekItemSun:
		*s = NosqlSettingsBackupDayOfWeekItemSun
	case NosqlSettingsBackupDayOfWeekItemMon:
		*s = NosqlSettingsBackupDayOfWeekItemMon
	case NosqlSettingsBackupDayOfWeekItemTue:
		*s = NosqlSettingsBackupDayOfWeekItemTue
	case NosqlSettingsBackupDayOfWeekItemWed:
		*s = NosqlSettingsBackupDayOfWeekItemWed
	case NosqlSettingsBackupDayOfWeekItemThu:
		*s = NosqlSettingsBackupDayOfWeekItemThu
	case NosqlSettingsBackupDayOfWeekItemFri:
		*s = NosqlSettingsBackupDayOfWeekItemFri
	case NosqlSettingsBackupDayOfWeekItemSat:
		*s = NosqlSettingsBackupDayOfWeekItemSat
	default:
		*s = NosqlSettingsBackupDayOfWeekItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlSettingsBackupDayOfWeekItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlSettingsBackupDayOfWeekItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlStatusResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlStatusResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Appliance")
		s.Appliance.Encode(e)
	}
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlStatusResponse = [2]string{
	0: "Appliance",
	1: "is_ok",
}

// Decode decodes NosqlStatusResponse from json.
func (s *NosqlStatusResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlStatusResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Appliance":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Appliance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Appliance\"")
			}
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlStatusResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlStatusResponse) {
					name = jsonFieldsNameOfNosqlStatusResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlStatusResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlStatusResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlStatusResponseAppliance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlStatusResponseAppliance) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ID")
		e.Str(s.ID)
	}
	{
		e.FieldStart("SettingsResponse")
		s.SettingsResponse.Encode(e)
	}
}

var jsonFieldsNameOfNosqlStatusResponseAppliance = [2]string{
	0: "ID",
	1: "SettingsResponse",
}

// Decode decodes NosqlStatusResponseAppliance from json.
func (s *NosqlStatusResponseAppliance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlStatusResponseAppliance to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ID":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		case "SettingsResponse":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.SettingsResponse.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SettingsResponse\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlStatusResponseAppliance")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlStatusResponseAppliance) {
					name = jsonFieldsNameOfNosqlStatusResponseAppliance[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlStatusResponseAppliance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlStatusResponseAppliance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlStatusResponseApplianceSettingsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlStatusResponseApplianceSettingsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Nosql.Set {
			e.FieldStart("Nosql")
			s.Nosql.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlStatusResponseApplianceSettingsResponse = [1]string{
	0: "Nosql",
}

// Decode decodes NosqlStatusResponseApplianceSettingsResponse from json.
func (s *NosqlStatusResponseApplianceSettingsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlStatusResponseApplianceSettingsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Nosql":
			if err := func() error {
				s.Nosql.Reset()
				if err := s.Nosql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Nosql\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlStatusResponseApplianceSettingsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlStatusResponseApplianceSettingsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlStatusResponseApplianceSettingsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlStatusResponseApplianceSettingsResponseNosql) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlStatusResponseApplianceSettingsResponseNosql) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("BootStatus")
		e.Str(s.BootStatus)
	}
	{
		e.FieldStart("DatabaseVersion")
		e.Str(s.DatabaseVersion)
	}
	{
		if s.UpgradeVersion.Set {
			e.FieldStart("UpgradeVersion")
			s.UpgradeVersion.Encode(e)
		}
	}
	{
		e.FieldStart("Jobs")
		e.ArrStart()
		for _, elem := range s.Jobs {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfNosqlStatusResponseApplianceSettingsResponseNosql = [5]string{
	0: "Enabled",
	1: "BootStatus",
	2: "DatabaseVersion",
	3: "UpgradeVersion",
	4: "Jobs",
}

// Decode decodes NosqlStatusResponseApplianceSettingsResponseNosql from json.
func (s *NosqlStatusResponseApplianceSettingsResponseNosql) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlStatusResponseApplianceSettingsResponseNosql to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Enabled\"")
			}
		case "BootStatus":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.BootStatus = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"BootStatus\"")
			}
		case "DatabaseVersion":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DatabaseVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DatabaseVersion\"")
			}
		case "UpgradeVersion":
			if err := func() error {
				s.UpgradeVersion.Reset()
				if err := s.UpgradeVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UpgradeVersion\"")
			}
		case "Jobs":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Jobs = make([]NosqlStatusResponseApplianceSettingsResponseNosqlJobsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NosqlStatusResponseApplianceSettingsResponseNosqlJobsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Jobs = append(s.Jobs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Jobs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlStatusResponseApplianceSettingsResponseNosql")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlStatusResponseApplianceSettingsResponseNosql) {
					name = jsonFieldsNameOfNosqlStatusResponseApplianceSettingsResponseNosql[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlStatusResponseApplianceSettingsResponseNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlStatusResponseApplianceSettingsResponseNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlStatusResponseApplianceSettingsResponseNosqlJobsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlStatusResponseApplianceSettingsResponseNosqlJobsItem) encodeFields(e *jx.Encoder) {
	{
		if s.JobType.Set {
			e.FieldStart("JobType")
			s.JobType.Encode(e)
		}
	}
	{
		if s.JobStatus.Set {
			e.FieldStart("JobStatus")
			s.JobStatus.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlStatusResponseApplianceSettingsResponseNosqlJobsItem = [2]string{
	0: "JobType",
	1: "JobStatus",
}

// Decode decodes NosqlStatusResponseApplianceSettingsResponseNosqlJobsItem from json.
func (s *NosqlStatusResponseApplianceSettingsResponseNosqlJobsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlStatusResponseApplianceSettingsResponseNosqlJobsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "JobType":
			if err := func() error {
				s.JobType.Reset()
				if err := s.JobType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"JobType\"")
			}
		case "JobStatus":
			if err := func() error {
				s.JobStatus.Reset()
				if err := s.JobStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"JobStatus\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlStatusResponseApplianceSettingsResponseNosqlJobsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlStatusResponseApplianceSettingsResponseNosqlJobsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlStatusResponseApplianceSettingsResponseNosqlJobsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlSuccessResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlSuccessResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Appliance.Set {
			e.FieldStart("Appliance")
			s.Appliance.Encode(e)
		}
	}
	{
		if s.Success.Set {
			e.FieldStart("Success")
			s.Success.Encode(e)
		}
	}
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlSuccessResponse = [3]string{
	0: "Appliance",
	1: "Success",
	2: "is_ok",
}

// Decode decodes NosqlSuccessResponse from json.
func (s *NosqlSuccessResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlSuccessResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Appliance":
			if err := func() error {
				s.Appliance.Reset()
				if err := s.Appliance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Appliance\"")
			}
		case "Success":
			if err := func() error {
				s.Success.Reset()
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Success\"")
			}
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlSuccessResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlSuccessResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlSuccessResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlUpdateRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlUpdateRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Appliance")
		s.Appliance.Encode(e)
	}
}

var jsonFieldsNameOfNosqlUpdateRequest = [1]string{
	0: "Appliance",
}

// Decode decodes NosqlUpdateRequest from json.
func (s *NosqlUpdateRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlUpdateRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Appliance":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Appliance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Appliance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlUpdateRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlUpdateRequest) {
					name = jsonFieldsNameOfNosqlUpdateRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlUpdateRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlUpdateRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlUpdateRequestAppliance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlUpdateRequestAppliance) encodeFields(e *jx.Encoder) {
	{
		if s.Class.Set {
			e.FieldStart("Class")
			s.Class.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("Name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("Description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Tags.Set {
			e.FieldStart("Tags")
			s.Tags.Encode(e)
		}
	}
	{
		e.FieldStart("ID")
		e.Str(s.ID)
	}
	{
		e.FieldStart("Settings")
		s.Settings.Encode(e)
	}
}

var jsonFieldsNameOfNosqlUpdateRequestAppliance = [6]string{
	0: "Class",
	1: "Name",
	2: "Description",
	3: "Tags",
	4: "ID",
	5: "Settings",
}

// Decode decodes NosqlUpdateRequestAppliance from json.
func (s *NosqlUpdateRequestAppliance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlUpdateRequestAppliance to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Class":
			if err := func() error {
				s.Class.Reset()
				if err := s.Class.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Class\"")
			}
		case "Name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Name\"")
			}
		case "Description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Description\"")
			}
		case "Tags":
			if err := func() error {
				s.Tags.Reset()
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Tags\"")
			}
		case "ID":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		case "Settings":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlUpdateRequestAppliance")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlUpdateRequestAppliance) {
					name = jsonFieldsNameOfNosqlUpdateRequestAppliance[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlUpdateRequestAppliance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlUpdateRequestAppliance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlUpdateRequestApplianceSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlUpdateRequestApplianceSettings) encodeFields(e *jx.Encoder) {
	{
		if s.Backup.Set {
			e.FieldStart("Backup")
			s.Backup.Encode(e)
		}
	}
	{
		if s.SourceNetwork != nil {
			e.FieldStart("SourceNetwork")
			e.ArrStart()
			for _, elem := range s.SourceNetwork {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("Password:")
			s.Password.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlUpdateRequestApplianceSettings = [3]string{
	0: "Backup",
	1: "SourceNetwork",
	2: "Password:",
}

// Decode decodes NosqlUpdateRequestApplianceSettings from json.
func (s *NosqlUpdateRequestApplianceSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlUpdateRequestApplianceSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Backup":
			if err := func() error {
				s.Backup.Reset()
				if err := s.Backup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Backup\"")
			}
		case "SourceNetwork":
			if err := func() error {
				s.SourceNetwork = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SourceNetwork = append(s.SourceNetwork, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SourceNetwork\"")
			}
		case "Password:":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Password:\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlUpdateRequestApplianceSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlUpdateRequestApplianceSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlUpdateRequestApplianceSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlUpdateRequestApplianceSettingsBackup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlUpdateRequestApplianceSettingsBackup) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Connect")
		e.Str(s.Connect)
	}
	{
		if s.DayOfWeek.Set {
			e.FieldStart("DayOfWeek")
			s.DayOfWeek.Encode(e)
		}
	}
	{
		if s.Time.Set {
			e.FieldStart("Time")
			s.Time.Encode(e)
		}
	}
	{
		if s.Rotate.Set {
			e.FieldStart("Rotate")
			s.Rotate.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlUpdateRequestApplianceSettingsBackup = [4]string{
	0: "Connect",
	1: "DayOfWeek",
	2: "Time",
	3: "Rotate",
}

// Decode decodes NosqlUpdateRequestApplianceSettingsBackup from json.
func (s *NosqlUpdateRequestApplianceSettingsBackup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlUpdateRequestApplianceSettingsBackup to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Connect":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Connect = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Connect\"")
			}
		case "DayOfWeek":
			if err := func() error {
				s.DayOfWeek.Reset()
				if err := s.DayOfWeek.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DayOfWeek\"")
			}
		case "Time":
			if err := func() error {
				s.Time.Reset()
				if err := s.Time.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Time\"")
			}
		case "Rotate":
			if err := func() error {
				s.Rotate.Reset()
				if err := s.Rotate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Rotate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlUpdateRequestApplianceSettingsBackup")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlUpdateRequestApplianceSettingsBackup) {
					name = jsonFieldsNameOfNosqlUpdateRequestApplianceSettingsBackup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlUpdateRequestApplianceSettingsBackup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlUpdateRequestApplianceSettingsBackup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem as json.
func (s NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem from json.
func (s *NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem(v) {
	case NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemSun:
		*s = NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemSun
	case NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemMon:
		*s = NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemMon
	case NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemTue:
		*s = NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemTue
	case NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemWed:
		*s = NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemWed
	case NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemThu:
		*s = NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemThu
	case NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemFri:
		*s = NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemFri
	case NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemSat:
		*s = NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemSat
	default:
		*s = NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NotFoundResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NotFoundResponse) encodeFields(e *jx.Encoder) {
	{
		if s.IsFatal.Set {
			e.FieldStart("is_fatal")
			s.IsFatal.Encode(e)
		}
	}
	{
		if s.Serial.Set {
			e.FieldStart("serial")
			s.Serial.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("error_code")
			s.ErrorCode.Encode(e)
		}
	}
	{
		if s.ErrorMsg.Set {
			e.FieldStart("error_msg")
			s.ErrorMsg.Encode(e)
		}
	}
}

var jsonFieldsNameOfNotFoundResponse = [5]string{
	0: "is_fatal",
	1: "serial",
	2: "status",
	3: "error_code",
	4: "error_msg",
}

// Decode decodes NotFoundResponse from json.
func (s *NotFoundResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotFoundResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "is_fatal":
			if err := func() error {
				s.IsFatal.Reset()
				if err := s.IsFatal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_fatal\"")
			}
		case "serial":
			if err := func() error {
				s.Serial.Reset()
				if err := s.Serial.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serial\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "error_code":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_code\"")
			}
		case "error_msg":
			if err := func() error {
				s.ErrorMsg.Reset()
				if err := s.ErrorMsg.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_msg\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotFoundResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NotFoundResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotFoundResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Availability as json.
func (o OptAvailability) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Availability from json.
func (o *OptAvailability) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAvailability to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAvailability) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAvailability) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes GetParameterResponseNosql as json.
func (o OptGetParameterResponseNosql) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetParameterResponseNosql from json.
func (o *OptGetParameterResponseNosql) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetParameterResponseNosql to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetParameterResponseNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetParameterResponseNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes netip.Addr as json.
func (o OptIPv4) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeIPv4(e, o.Value)
}

// Decode decodes netip.Addr from json.
func (o *OptIPv4) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIPv4 to nil")
	}
	o.Set = true
	v, err := json.DecodeIPv4(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIPv4) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIPv4) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Instance as json.
func (o OptInstance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Instance from json.
func (o *OptInstance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInstance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInstance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInstance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IsOk as json.
func (o OptIsOk) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IsOk from json.
func (o *OptIsOk) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIsOk to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIsOk) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIsOk) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InstanceHost as json.
func (o OptNilInstanceHost) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes InstanceHost from json.
func (o *OptNilInstanceHost) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInstanceHost to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v InstanceHost
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInstanceHost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInstanceHost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceDisk as json.
func (o OptNilNosqlApplianceDisk) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlApplianceDisk from json.
func (o *OptNilNosqlApplianceDisk) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNosqlApplianceDisk to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NosqlApplianceDisk
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNosqlApplianceDisk) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNosqlApplianceDisk) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceInterfacesItemSwitchSubnet as json.
func (o OptNilNosqlApplianceInterfacesItemSwitchSubnet) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlApplianceInterfacesItemSwitchSubnet from json.
func (o *OptNilNosqlApplianceInterfacesItemSwitchSubnet) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNosqlApplianceInterfacesItemSwitchSubnet to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NosqlApplianceInterfacesItemSwitchSubnet
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNosqlApplianceInterfacesItemSwitchSubnet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNosqlApplianceInterfacesItemSwitchSubnet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlCreateRequestApplianceSettingsBackup as json.
func (o OptNilNosqlCreateRequestApplianceSettingsBackup) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlCreateRequestApplianceSettingsBackup from json.
func (o *OptNilNosqlCreateRequestApplianceSettingsBackup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNosqlCreateRequestApplianceSettingsBackup to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NosqlCreateRequestApplianceSettingsBackup
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNosqlCreateRequestApplianceSettingsBackup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNosqlCreateRequestApplianceSettingsBackup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem as json.
func (o OptNilNosqlCreateRequestApplianceSettingsBackupDayOfWeekItemArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem from json.
func (o *OptNilNosqlCreateRequestApplianceSettingsBackupDayOfWeekItemArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNosqlCreateRequestApplianceSettingsBackupDayOfWeekItemArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNosqlCreateRequestApplianceSettingsBackupDayOfWeekItemArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNosqlCreateRequestApplianceSettingsBackupDayOfWeekItemArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlSettingsBackup as json.
func (o OptNilNosqlSettingsBackup) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlSettingsBackup from json.
func (o *OptNilNosqlSettingsBackup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNosqlSettingsBackup to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NosqlSettingsBackup
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNosqlSettingsBackup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNosqlSettingsBackup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []NosqlSettingsBackupDayOfWeekItem as json.
func (o OptNilNosqlSettingsBackupDayOfWeekItemArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []NosqlSettingsBackupDayOfWeekItem from json.
func (o *OptNilNosqlSettingsBackupDayOfWeekItemArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNosqlSettingsBackupDayOfWeekItemArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []NosqlSettingsBackupDayOfWeekItem
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]NosqlSettingsBackupDayOfWeekItem, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem NosqlSettingsBackupDayOfWeekItem
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNosqlSettingsBackupDayOfWeekItemArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNosqlSettingsBackupDayOfWeekItemArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlUpdateRequestApplianceSettingsBackup as json.
func (o OptNilNosqlUpdateRequestApplianceSettingsBackup) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlUpdateRequestApplianceSettingsBackup from json.
func (o *OptNilNosqlUpdateRequestApplianceSettingsBackup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNosqlUpdateRequestApplianceSettingsBackup to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NosqlUpdateRequestApplianceSettingsBackup
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNosqlUpdateRequestApplianceSettingsBackup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNosqlUpdateRequestApplianceSettingsBackup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem as json.
func (o OptNilNosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem from json.
func (o *OptNilNosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Tags as json.
func (o OptNilTags) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Tags from json.
func (o *OptNilTags) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilTags to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v Tags
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilTags) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilTags) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlAppliance as json.
func (o OptNosqlAppliance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlAppliance from json.
func (o *OptNosqlAppliance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlAppliance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlAppliance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlAppliance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceInterfacesItemSwitch as json.
func (o OptNosqlApplianceInterfacesItemSwitch) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlApplianceInterfacesItemSwitch from json.
func (o *OptNosqlApplianceInterfacesItemSwitch) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlApplianceInterfacesItemSwitch to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlApplianceInterfacesItemSwitch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlApplianceInterfacesItemSwitch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceInterfacesItemSwitchSubnetInternet as json.
func (o OptNosqlApplianceInterfacesItemSwitchSubnetInternet) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlApplianceInterfacesItemSwitchSubnetInternet from json.
func (o *OptNosqlApplianceInterfacesItemSwitchSubnetInternet) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlApplianceInterfacesItemSwitchSubnetInternet to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlApplianceInterfacesItemSwitchSubnetInternet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlApplianceInterfacesItemSwitchSubnetInternet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceInterfacesItemSwitchUserSubnet as json.
func (o OptNosqlApplianceInterfacesItemSwitchUserSubnet) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlApplianceInterfacesItemSwitchUserSubnet from json.
func (o *OptNosqlApplianceInterfacesItemSwitchUserSubnet) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlApplianceInterfacesItemSwitchUserSubnet to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlApplianceInterfacesItemSwitchUserSubnet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlApplianceInterfacesItemSwitchUserSubnet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceRemark as json.
func (o OptNosqlApplianceRemark) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlApplianceRemark from json.
func (o *OptNosqlApplianceRemark) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlApplianceRemark to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlApplianceRemark) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlApplianceRemark) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceRemarkNosql as json.
func (o OptNosqlApplianceRemarkNosql) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlApplianceRemarkNosql from json.
func (o *OptNosqlApplianceRemarkNosql) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlApplianceRemarkNosql to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlApplianceRemarkNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlApplianceRemarkNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceRemarkZone as json.
func (o OptNosqlApplianceRemarkZone) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlApplianceRemarkZone from json.
func (o *OptNosqlApplianceRemarkZone) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlApplianceRemarkZone to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlApplianceRemarkZone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlApplianceRemarkZone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlBackupResponseNosql as json.
func (o OptNosqlBackupResponseNosql) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlBackupResponseNosql from json.
func (o *OptNosqlBackupResponseNosql) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlBackupResponseNosql to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlBackupResponseNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlBackupResponseNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlCreateRequestApplianceUserInterfacesItemUserSubnet as json.
func (o OptNosqlCreateRequestApplianceUserInterfacesItemUserSubnet) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlCreateRequestApplianceUserInterfacesItemUserSubnet from json.
func (o *OptNosqlCreateRequestApplianceUserInterfacesItemUserSubnet) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlCreateRequestApplianceUserInterfacesItemUserSubnet to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlCreateRequestApplianceUserInterfacesItemUserSubnet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlCreateRequestApplianceUserInterfacesItemUserSubnet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlCreateResponseAccount as json.
func (o OptNosqlCreateResponseAccount) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlCreateResponseAccount from json.
func (o *OptNosqlCreateResponseAccount) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlCreateResponseAccount to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlCreateResponseAccount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlCreateResponseAccount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlCreateResponseHiddenRemark as json.
func (o OptNosqlCreateResponseHiddenRemark) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlCreateResponseHiddenRemark from json.
func (o *OptNosqlCreateResponseHiddenRemark) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlCreateResponseHiddenRemark to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlCreateResponseHiddenRemark) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlCreateResponseHiddenRemark) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlCreateResponseHiddenRemarkEncripted as json.
func (o OptNosqlCreateResponseHiddenRemarkEncripted) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlCreateResponseHiddenRemarkEncripted from json.
func (o *OptNosqlCreateResponseHiddenRemarkEncripted) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlCreateResponseHiddenRemarkEncripted to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlCreateResponseHiddenRemarkEncripted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlCreateResponseHiddenRemarkEncripted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlCreateResponseHiddenRemarkPlanSpec as json.
func (o OptNosqlCreateResponseHiddenRemarkPlanSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlCreateResponseHiddenRemarkPlanSpec from json.
func (o *OptNosqlCreateResponseHiddenRemarkPlanSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlCreateResponseHiddenRemarkPlanSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlCreateResponseHiddenRemarkPlanSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlCreateResponseHiddenRemarkPlanSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlCreateResponseHiddenRemarkPlanSpecNote as json.
func (o OptNosqlCreateResponseHiddenRemarkPlanSpecNote) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlCreateResponseHiddenRemarkPlanSpecNote from json.
func (o *OptNosqlCreateResponseHiddenRemarkPlanSpecNote) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlCreateResponseHiddenRemarkPlanSpecNote to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlCreateResponseHiddenRemarkPlanSpecNote) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlCreateResponseHiddenRemarkPlanSpecNote) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlGetVersionResponseNosql as json.
func (o OptNosqlGetVersionResponseNosql) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlGetVersionResponseNosql from json.
func (o *OptNosqlGetVersionResponseNosql) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlGetVersionResponseNosql to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlGetVersionResponseNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlGetVersionResponseNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlIsOkResponseNosql as json.
func (o OptNosqlIsOkResponseNosql) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlIsOkResponseNosql from json.
func (o *OptNosqlIsOkResponseNosql) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlIsOkResponseNosql to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlIsOkResponseNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlIsOkResponseNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlOkResponseNosql as json.
func (o OptNosqlOkResponseNosql) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlOkResponseNosql from json.
func (o *OptNosqlOkResponseNosql) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlOkResponseNosql to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlOkResponseNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlOkResponseNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlPutVersionResponseNosql as json.
func (o OptNosqlPutVersionResponseNosql) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlPutVersionResponseNosql from json.
func (o *OptNosqlPutVersionResponseNosql) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlPutVersionResponseNosql to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlPutVersionResponseNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlPutVersionResponseNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlRemark as json.
func (o OptNosqlRemark) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlRemark from json.
func (o *OptNosqlRemark) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlRemark to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlRemark) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlRemark) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlRemarkNosql as json.
func (o OptNosqlRemarkNosql) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlRemarkNosql from json.
func (o *OptNosqlRemarkNosql) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlRemarkNosql to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlRemarkNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlRemarkNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlSettings as json.
func (o OptNosqlSettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlSettings from json.
func (o *OptNosqlSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlSettings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlStatusResponseApplianceSettingsResponseNosql as json.
func (o OptNosqlStatusResponseApplianceSettingsResponseNosql) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlStatusResponseApplianceSettingsResponseNosql from json.
func (o *OptNosqlStatusResponseApplianceSettingsResponseNosql) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlStatusResponseApplianceSettingsResponseNosql to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlStatusResponseApplianceSettingsResponseNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlStatusResponseApplianceSettingsResponseNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Password as json.
func (o OptPassword) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Password from json.
func (o *OptPassword) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPassword to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPassword) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPassword) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Plan as json.
func (o OptPlan) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Plan from json.
func (o *OptPlan) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPlan to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPlan) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPlan) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PutParameterResponseNosql as json.
func (o OptPutParameterResponseNosql) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PutParameterResponseNosql from json.
func (o *OptPutParameterResponseNosql) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPutParameterResponseNosql to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPutParameterResponseNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPutParameterResponseNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ServiceClass as json.
func (o OptServiceClass) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ServiceClass from json.
func (o *OptServiceClass) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptServiceClass to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptServiceClass) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptServiceClass) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Success as json.
func (o OptSuccess) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Success from json.
func (o *OptSuccess) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSuccess to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Password as json.
func (s Password) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes Password from json.
func (s *Password) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Password to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Password(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Password) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Password) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Plan) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Plan) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("ID")
			s.ID.Encode(e)
		}
	}
}

var jsonFieldsNameOfPlan = [1]string{
	0: "ID",
}

// Decode decodes Plan from json.
func (s *Plan) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Plan to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ID":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Plan")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Plan) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Plan) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PutParameterRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PutParameterRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nosql")
		s.Nosql.Encode(e)
	}
}

var jsonFieldsNameOfPutParameterRequest = [1]string{
	0: "nosql",
}

// Decode decodes PutParameterRequest from json.
func (s *PutParameterRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PutParameterRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nosql":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Nosql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nosql\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PutParameterRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPutParameterRequest) {
					name = jsonFieldsNameOfPutParameterRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PutParameterRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PutParameterRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PutParameterRequestNosql) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PutParameterRequestNosql) encodeFields(e *jx.Encoder) {
	{
		if s.Parameters != nil {
			e.FieldStart("parameters")
			e.ArrStart()
			for _, elem := range s.Parameters {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPutParameterRequestNosql = [1]string{
	0: "parameters",
}

// Decode decodes PutParameterRequestNosql from json.
func (s *PutParameterRequestNosql) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PutParameterRequestNosql to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "parameters":
			if err := func() error {
				s.Parameters = make([]NosqlPutParameter, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NosqlPutParameter
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Parameters = append(s.Parameters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PutParameterRequestNosql")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PutParameterRequestNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PutParameterRequestNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PutParameterResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PutParameterResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Nosql.Set {
			e.FieldStart("nosql")
			s.Nosql.Encode(e)
		}
	}
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfPutParameterResponse = [2]string{
	0: "nosql",
	1: "is_ok",
}

// Decode decodes PutParameterResponse from json.
func (s *PutParameterResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PutParameterResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nosql":
			if err := func() error {
				s.Nosql.Reset()
				if err := s.Nosql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nosql\"")
			}
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PutParameterResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PutParameterResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PutParameterResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PutParameterResponseNosql) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PutParameterResponseNosql) encodeFields(e *jx.Encoder) {
	{
		if s.Parameters != nil {
			e.FieldStart("parameters")
			e.ArrStart()
			for _, elem := range s.Parameters {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPutParameterResponseNosql = [1]string{
	0: "parameters",
}

// Decode decodes PutParameterResponseNosql from json.
func (s *PutParameterResponseNosql) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PutParameterResponseNosql to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "parameters":
			if err := func() error {
				s.Parameters = make([]NosqlPutParameter, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NosqlPutParameter
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Parameters = append(s.Parameters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PutParameterResponseNosql")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PutParameterResponseNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PutParameterResponseNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ServerErrorResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ServerErrorResponse) encodeFields(e *jx.Encoder) {
	{
		if s.IsFatal.Set {
			e.FieldStart("is_fatal")
			s.IsFatal.Encode(e)
		}
	}
	{
		if s.Serial.Set {
			e.FieldStart("serial")
			s.Serial.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("error_code")
			s.ErrorCode.Encode(e)
		}
	}
	{
		if s.ErrorMsg.Set {
			e.FieldStart("error_msg")
			s.ErrorMsg.Encode(e)
		}
	}
}

var jsonFieldsNameOfServerErrorResponse = [5]string{
	0: "is_fatal",
	1: "serial",
	2: "status",
	3: "error_code",
	4: "error_msg",
}

// Decode decodes ServerErrorResponse from json.
func (s *ServerErrorResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServerErrorResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "is_fatal":
			if err := func() error {
				s.IsFatal.Reset()
				if err := s.IsFatal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_fatal\"")
			}
		case "serial":
			if err := func() error {
				s.Serial.Reset()
				if err := s.Serial.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serial\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "error_code":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_code\"")
			}
		case "error_msg":
			if err := func() error {
				s.ErrorMsg.Reset()
				if err := s.ErrorMsg.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_msg\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServerErrorResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ServerErrorResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServerErrorResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ServiceClass as json.
func (s ServiceClass) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes ServiceClass from json.
func (s *ServiceClass) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServiceClass to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ServiceClass(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ServiceClass) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServiceClass) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Success as json.
func (s Success) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes Success from json.
func (s *Success) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Success to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Success(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Success) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Success) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Success.Set {
			e.FieldStart("Success")
			s.Success.Encode(e)
		}
	}
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessResponse = [2]string{
	0: "Success",
	1: "is_ok",
}

// Decode decodes SuccessResponse from json.
func (s *SuccessResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Success":
			if err := func() error {
				s.Success.Reset()
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Success\"")
			}
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Tags as json.
func (s Tags) Encode(e *jx.Encoder) {
	unwrapped := []string(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes Tags from json.
func (s *Tags) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Tags to nil")
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Tags(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Tags) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Tags) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnauthorizedResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnauthorizedResponse) encodeFields(e *jx.Encoder) {
	{
		if s.IsFatal.Set {
			e.FieldStart("is_fatal")
			s.IsFatal.Encode(e)
		}
	}
	{
		if s.Serial.Set {
			e.FieldStart("serial")
			s.Serial.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("error_code")
			s.ErrorCode.Encode(e)
		}
	}
	{
		if s.ErrorMsg.Set {
			e.FieldStart("error_msg")
			s.ErrorMsg.Encode(e)
		}
	}
}

var jsonFieldsNameOfUnauthorizedResponse = [5]string{
	0: "is_fatal",
	1: "serial",
	2: "status",
	3: "error_code",
	4: "error_msg",
}

// Decode decodes UnauthorizedResponse from json.
func (s *UnauthorizedResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnauthorizedResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "is_fatal":
			if err := func() error {
				s.IsFatal.Reset()
				if err := s.IsFatal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_fatal\"")
			}
		case "serial":
			if err := func() error {
				s.Serial.Reset()
				if err := s.Serial.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serial\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "error_code":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_code\"")
			}
		case "error_msg":
			if err := func() error {
				s.ErrorMsg.Reset()
				if err := s.ErrorMsg.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_msg\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnauthorizedResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnauthorizedResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnauthorizedResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
