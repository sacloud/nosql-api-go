// Code generated by ogen, DO NOT EDIT.

package v1

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode encodes Availability as json.
func (s Availability) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes Availability from json.
func (s *Availability) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Availability to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch Availability(v) {
	case AvailabilityMigrating:
		*s = AvailabilityMigrating
	case AvailabilityAvailable:
		*s = AvailabilityAvailable
	case AvailabilityFailed:
		*s = AvailabilityFailed
	default:
		*s = Availability(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Availability) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Availability) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BadRequestResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BadRequestResponse) encodeFields(e *jx.Encoder) {
	{
		if s.IsFatal.Set {
			e.FieldStart("is_fatal")
			s.IsFatal.Encode(e)
		}
	}
	{
		if s.Serial.Set {
			e.FieldStart("serial")
			s.Serial.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("error_code")
			s.ErrorCode.Encode(e)
		}
	}
	{
		if s.ErrorMsg.Set {
			e.FieldStart("error_msg")
			s.ErrorMsg.Encode(e)
		}
	}
}

var jsonFieldsNameOfBadRequestResponse = [5]string{
	0: "is_fatal",
	1: "serial",
	2: "status",
	3: "error_code",
	4: "error_msg",
}

// Decode decodes BadRequestResponse from json.
func (s *BadRequestResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BadRequestResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "is_fatal":
			if err := func() error {
				s.IsFatal.Reset()
				if err := s.IsFatal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_fatal\"")
			}
		case "serial":
			if err := func() error {
				s.Serial.Reset()
				if err := s.Serial.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serial\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "error_code":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_code\"")
			}
		case "error_msg":
			if err := func() error {
				s.ErrorMsg.Reset()
				if err := s.ErrorMsg.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_msg\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BadRequestResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BadRequestResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BadRequestResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConflictErrorResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConflictErrorResponse) encodeFields(e *jx.Encoder) {
	{
		if s.IsFatal.Set {
			e.FieldStart("is_fatal")
			s.IsFatal.Encode(e)
		}
	}
	{
		if s.Serial.Set {
			e.FieldStart("serial")
			s.Serial.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("error_code")
			s.ErrorCode.Encode(e)
		}
	}
	{
		if s.ErrorMsg.Set {
			e.FieldStart("error_msg")
			s.ErrorMsg.Encode(e)
		}
	}
}

var jsonFieldsNameOfConflictErrorResponse = [5]string{
	0: "is_fatal",
	1: "serial",
	2: "status",
	3: "error_code",
	4: "error_msg",
}

// Decode decodes ConflictErrorResponse from json.
func (s *ConflictErrorResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConflictErrorResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "is_fatal":
			if err := func() error {
				s.IsFatal.Reset()
				if err := s.IsFatal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_fatal\"")
			}
		case "serial":
			if err := func() error {
				s.Serial.Reset()
				if err := s.Serial.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serial\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "error_code":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_code\"")
			}
		case "error_msg":
			if err := func() error {
				s.ErrorMsg.Reset()
				if err := s.ErrorMsg.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_msg\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConflictErrorResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConflictErrorResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConflictErrorResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNosqlAppliance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNosqlAppliance) encodeFields(e *jx.Encoder) {
	{
		if s.Class.Set {
			e.FieldStart("Class")
			s.Class.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("Name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("Description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Tags.Set {
			e.FieldStart("Tags")
			s.Tags.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("ID")
			s.ID.Encode(e)
		}
	}
	{
		if s.Plan.Set {
			e.FieldStart("Plan")
			s.Plan.Encode(e)
		}
	}
	{
		if s.Settings.Set {
			e.FieldStart("Settings")
			s.Settings.Encode(e)
		}
	}
	{
		if s.SettingsHash.Set {
			e.FieldStart("SettingsHash")
			s.SettingsHash.Encode(e)
		}
	}
	{
		if s.Remark.Set {
			e.FieldStart("Remark")
			s.Remark.Encode(e)
		}
	}
	{
		if s.Availability.Set {
			e.FieldStart("Availability")
			s.Availability.Encode(e)
		}
	}
	{
		if s.Instance.Set {
			e.FieldStart("Instance")
			s.Instance.Encode(e)
		}
	}
	{
		if s.Disk.Set {
			e.FieldStart("Disk")
			s.Disk.Encode(e)
		}
	}
	{
		if s.ServiceClass.Set {
			e.FieldStart("ServiceClass")
			s.ServiceClass.Encode(e)
		}
	}
	{
		if s.Generation.Set {
			e.FieldStart("Generation")
			s.Generation.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("CreatedAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Interfaces != nil {
			e.FieldStart("Interfaces")
			e.ArrStart()
			for _, elem := range s.Interfaces {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGetNosqlAppliance = [16]string{
	0:  "Class",
	1:  "Name",
	2:  "Description",
	3:  "Tags",
	4:  "ID",
	5:  "Plan",
	6:  "Settings",
	7:  "SettingsHash",
	8:  "Remark",
	9:  "Availability",
	10: "Instance",
	11: "Disk",
	12: "ServiceClass",
	13: "Generation",
	14: "CreatedAt",
	15: "Interfaces",
}

// Decode decodes GetNosqlAppliance from json.
func (s *GetNosqlAppliance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNosqlAppliance to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Class":
			if err := func() error {
				s.Class.Reset()
				if err := s.Class.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Class\"")
			}
		case "Name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Name\"")
			}
		case "Description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Description\"")
			}
		case "Tags":
			if err := func() error {
				s.Tags.Reset()
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Tags\"")
			}
		case "ID":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		case "Plan":
			if err := func() error {
				s.Plan.Reset()
				if err := s.Plan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Plan\"")
			}
		case "Settings":
			if err := func() error {
				s.Settings.Reset()
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Settings\"")
			}
		case "SettingsHash":
			if err := func() error {
				s.SettingsHash.Reset()
				if err := s.SettingsHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SettingsHash\"")
			}
		case "Remark":
			if err := func() error {
				s.Remark.Reset()
				if err := s.Remark.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Remark\"")
			}
		case "Availability":
			if err := func() error {
				s.Availability.Reset()
				if err := s.Availability.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Availability\"")
			}
		case "Instance":
			if err := func() error {
				s.Instance.Reset()
				if err := s.Instance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Instance\"")
			}
		case "Disk":
			if err := func() error {
				s.Disk.Reset()
				if err := s.Disk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Disk\"")
			}
		case "ServiceClass":
			if err := func() error {
				s.ServiceClass.Reset()
				if err := s.ServiceClass.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ServiceClass\"")
			}
		case "Generation":
			if err := func() error {
				s.Generation.Reset()
				if err := s.Generation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Generation\"")
			}
		case "CreatedAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"CreatedAt\"")
			}
		case "Interfaces":
			if err := func() error {
				s.Interfaces = make([]GetNosqlApplianceInterfacesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetNosqlApplianceInterfacesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Interfaces = append(s.Interfaces, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Interfaces\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNosqlAppliance")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNosqlAppliance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNosqlAppliance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNosqlApplianceDisk) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNosqlApplianceDisk) encodeFields(e *jx.Encoder) {
	{
		if s.EncryptionKey.Set {
			e.FieldStart("EncryptionKey")
			s.EncryptionKey.Encode(e)
		}
	}
	{
		if s.EncryptionAlgorithm.Set {
			e.FieldStart("EncryptionAlgorithm")
			s.EncryptionAlgorithm.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetNosqlApplianceDisk = [2]string{
	0: "EncryptionKey",
	1: "EncryptionAlgorithm",
}

// Decode decodes GetNosqlApplianceDisk from json.
func (s *GetNosqlApplianceDisk) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNosqlApplianceDisk to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "EncryptionKey":
			if err := func() error {
				s.EncryptionKey.Reset()
				if err := s.EncryptionKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"EncryptionKey\"")
			}
		case "EncryptionAlgorithm":
			if err := func() error {
				s.EncryptionAlgorithm.Reset()
				if err := s.EncryptionAlgorithm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"EncryptionAlgorithm\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNosqlApplianceDisk")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNosqlApplianceDisk) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNosqlApplianceDisk) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNosqlApplianceDiskEncryptionKey) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNosqlApplianceDiskEncryptionKey) encodeFields(e *jx.Encoder) {
	{
		if s.KMSKeyID.Set {
			e.FieldStart("KMSKeyID")
			s.KMSKeyID.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetNosqlApplianceDiskEncryptionKey = [1]string{
	0: "KMSKeyID",
}

// Decode decodes GetNosqlApplianceDiskEncryptionKey from json.
func (s *GetNosqlApplianceDiskEncryptionKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNosqlApplianceDiskEncryptionKey to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "KMSKeyID":
			if err := func() error {
				s.KMSKeyID.Reset()
				if err := s.KMSKeyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"KMSKeyID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNosqlApplianceDiskEncryptionKey")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNosqlApplianceDiskEncryptionKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNosqlApplianceDiskEncryptionKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNosqlApplianceInterfacesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNosqlApplianceInterfacesItem) encodeFields(e *jx.Encoder) {
	{
		if s.IPAddress.Set {
			e.FieldStart("IPAddress")
			s.IPAddress.Encode(e)
		}
	}
	{
		if s.UserIPAddress.Set {
			e.FieldStart("UserIPAddress")
			s.UserIPAddress.Encode(e)
		}
	}
	{
		if s.HostName.Set {
			e.FieldStart("HostName")
			s.HostName.Encode(e)
		}
	}
	{
		if s.Switch.Set {
			e.FieldStart("Switch")
			s.Switch.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetNosqlApplianceInterfacesItem = [4]string{
	0: "IPAddress",
	1: "UserIPAddress",
	2: "HostName",
	3: "Switch",
}

// Decode decodes GetNosqlApplianceInterfacesItem from json.
func (s *GetNosqlApplianceInterfacesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNosqlApplianceInterfacesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "IPAddress":
			if err := func() error {
				s.IPAddress.Reset()
				if err := s.IPAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"IPAddress\"")
			}
		case "UserIPAddress":
			if err := func() error {
				s.UserIPAddress.Reset()
				if err := s.UserIPAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UserIPAddress\"")
			}
		case "HostName":
			if err := func() error {
				s.HostName.Reset()
				if err := s.HostName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"HostName\"")
			}
		case "Switch":
			if err := func() error {
				s.Switch.Reset()
				if err := s.Switch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Switch\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNosqlApplianceInterfacesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNosqlApplianceInterfacesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNosqlApplianceInterfacesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNosqlApplianceInterfacesItemSwitch) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNosqlApplianceInterfacesItemSwitch) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("ID")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Scope.Set {
			e.FieldStart("Scope")
			s.Scope.Encode(e)
		}
	}
	{
		if s.Subnet.Set {
			e.FieldStart("Subnet")
			s.Subnet.Encode(e)
		}
	}
	{
		if s.UserSubnet.Set {
			e.FieldStart("UserSubnet")
			s.UserSubnet.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetNosqlApplianceInterfacesItemSwitch = [5]string{
	0: "ID",
	1: "name",
	2: "Scope",
	3: "Subnet",
	4: "UserSubnet",
}

// Decode decodes GetNosqlApplianceInterfacesItemSwitch from json.
func (s *GetNosqlApplianceInterfacesItemSwitch) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNosqlApplianceInterfacesItemSwitch to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ID":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "Scope":
			if err := func() error {
				s.Scope.Reset()
				if err := s.Scope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Scope\"")
			}
		case "Subnet":
			if err := func() error {
				s.Subnet.Reset()
				if err := s.Subnet.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Subnet\"")
			}
		case "UserSubnet":
			if err := func() error {
				s.UserSubnet.Reset()
				if err := s.UserSubnet.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UserSubnet\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNosqlApplianceInterfacesItemSwitch")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNosqlApplianceInterfacesItemSwitch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNosqlApplianceInterfacesItemSwitch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNosqlApplianceInterfacesItemSwitchSubnet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNosqlApplianceInterfacesItemSwitchSubnet) encodeFields(e *jx.Encoder) {
	{
		if s.NetworkAddress.Set {
			e.FieldStart("NetworkAddress")
			s.NetworkAddress.Encode(e)
		}
	}
	{
		if s.NetworkMaskLen.Set {
			e.FieldStart("NetworkMaskLen")
			s.NetworkMaskLen.Encode(e)
		}
	}
	{
		if s.DefaultRoute.Set {
			e.FieldStart("DefaultRoute")
			s.DefaultRoute.Encode(e)
		}
	}
	{
		if s.Internet.Set {
			e.FieldStart("Internet")
			s.Internet.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetNosqlApplianceInterfacesItemSwitchSubnet = [4]string{
	0: "NetworkAddress",
	1: "NetworkMaskLen",
	2: "DefaultRoute",
	3: "Internet",
}

// Decode decodes GetNosqlApplianceInterfacesItemSwitchSubnet from json.
func (s *GetNosqlApplianceInterfacesItemSwitchSubnet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNosqlApplianceInterfacesItemSwitchSubnet to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "NetworkAddress":
			if err := func() error {
				s.NetworkAddress.Reset()
				if err := s.NetworkAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"NetworkAddress\"")
			}
		case "NetworkMaskLen":
			if err := func() error {
				s.NetworkMaskLen.Reset()
				if err := s.NetworkMaskLen.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"NetworkMaskLen\"")
			}
		case "DefaultRoute":
			if err := func() error {
				s.DefaultRoute.Reset()
				if err := s.DefaultRoute.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DefaultRoute\"")
			}
		case "Internet":
			if err := func() error {
				s.Internet.Reset()
				if err := s.Internet.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Internet\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNosqlApplianceInterfacesItemSwitchSubnet")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNosqlApplianceInterfacesItemSwitchSubnet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNosqlApplianceInterfacesItemSwitchSubnet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNosqlApplianceInterfacesItemSwitchSubnetInternet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNosqlApplianceInterfacesItemSwitchSubnetInternet) encodeFields(e *jx.Encoder) {
	{
		if s.BandWidthMbps.Set {
			e.FieldStart("BandWidthMbps")
			s.BandWidthMbps.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetNosqlApplianceInterfacesItemSwitchSubnetInternet = [1]string{
	0: "BandWidthMbps",
}

// Decode decodes GetNosqlApplianceInterfacesItemSwitchSubnetInternet from json.
func (s *GetNosqlApplianceInterfacesItemSwitchSubnetInternet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNosqlApplianceInterfacesItemSwitchSubnetInternet to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "BandWidthMbps":
			if err := func() error {
				s.BandWidthMbps.Reset()
				if err := s.BandWidthMbps.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"BandWidthMbps\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNosqlApplianceInterfacesItemSwitchSubnetInternet")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNosqlApplianceInterfacesItemSwitchSubnetInternet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNosqlApplianceInterfacesItemSwitchSubnetInternet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNosqlApplianceInterfacesItemSwitchUserSubnet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNosqlApplianceInterfacesItemSwitchUserSubnet) encodeFields(e *jx.Encoder) {
	{
		if s.DefaultRoute.Set {
			e.FieldStart("DefaultRoute")
			s.DefaultRoute.Encode(e)
		}
	}
	{
		if s.NetworkMaskLen.Set {
			e.FieldStart("NetworkMaskLen")
			s.NetworkMaskLen.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetNosqlApplianceInterfacesItemSwitchUserSubnet = [2]string{
	0: "DefaultRoute",
	1: "NetworkMaskLen",
}

// Decode decodes GetNosqlApplianceInterfacesItemSwitchUserSubnet from json.
func (s *GetNosqlApplianceInterfacesItemSwitchUserSubnet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNosqlApplianceInterfacesItemSwitchUserSubnet to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "DefaultRoute":
			if err := func() error {
				s.DefaultRoute.Reset()
				if err := s.DefaultRoute.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DefaultRoute\"")
			}
		case "NetworkMaskLen":
			if err := func() error {
				s.NetworkMaskLen.Reset()
				if err := s.NetworkMaskLen.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"NetworkMaskLen\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNosqlApplianceInterfacesItemSwitchUserSubnet")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNosqlApplianceInterfacesItemSwitchUserSubnet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNosqlApplianceInterfacesItemSwitchUserSubnet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNosqlApplianceRemark) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNosqlApplianceRemark) encodeFields(e *jx.Encoder) {
	{
		if s.Nosql.Set {
			e.FieldStart("Nosql")
			s.Nosql.Encode(e)
		}
	}
	{
		if s.Servers != nil {
			e.FieldStart("Servers")
			e.ArrStart()
			for _, elem := range s.Servers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Zone.Set {
			e.FieldStart("Zone")
			s.Zone.Encode(e)
		}
	}
	{
		if s.ServiceClass.Set {
			e.FieldStart("ServiceClass")
			s.ServiceClass.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetNosqlApplianceRemark = [4]string{
	0: "Nosql",
	1: "Servers",
	2: "Zone",
	3: "ServiceClass",
}

// Decode decodes GetNosqlApplianceRemark from json.
func (s *GetNosqlApplianceRemark) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNosqlApplianceRemark to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Nosql":
			if err := func() error {
				s.Nosql.Reset()
				if err := s.Nosql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Nosql\"")
			}
		case "Servers":
			if err := func() error {
				s.Servers = make([]GetNosqlApplianceRemarkServersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetNosqlApplianceRemarkServersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Servers = append(s.Servers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Servers\"")
			}
		case "Zone":
			if err := func() error {
				s.Zone.Reset()
				if err := s.Zone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Zone\"")
			}
		case "ServiceClass":
			if err := func() error {
				s.ServiceClass.Reset()
				if err := s.ServiceClass.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ServiceClass\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNosqlApplianceRemark")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNosqlApplianceRemark) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNosqlApplianceRemark) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNosqlApplianceRemarkNosql) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNosqlApplianceRemarkNosql) encodeFields(e *jx.Encoder) {
	{
		if s.PrimaryNodes.Set {
			e.FieldStart("PrimaryNodes")
			s.PrimaryNodes.Encode(e)
		}
	}
	{
		if s.DatabaseEngine.Set {
			e.FieldStart("DatabaseEngine")
			s.DatabaseEngine.Encode(e)
		}
	}
	{
		if s.DatabaseVersion.Set {
			e.FieldStart("DatabaseVersion")
			s.DatabaseVersion.Encode(e)
		}
	}
	{
		if s.DefaultUser.Set {
			e.FieldStart("DefaultUser")
			s.DefaultUser.Encode(e)
		}
	}
	{
		if s.DiskSize.Set {
			e.FieldStart("DiskSize")
			s.DiskSize.Encode(e)
		}
	}
	{
		if s.Memory.Set {
			e.FieldStart("Memory")
			s.Memory.Encode(e)
		}
	}
	{
		if s.Nodes.Set {
			e.FieldStart("Nodes")
			s.Nodes.Encode(e)
		}
	}
	{
		if s.Port.Set {
			e.FieldStart("Port")
			s.Port.Encode(e)
		}
	}
	{
		if s.Storage.Set {
			e.FieldStart("Storage")
			s.Storage.Encode(e)
		}
	}
	{
		if s.Virtualcore.Set {
			e.FieldStart("Virtualcore")
			s.Virtualcore.Encode(e)
		}
	}
	{
		if s.Zone.Set {
			e.FieldStart("Zone")
			s.Zone.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetNosqlApplianceRemarkNosql = [11]string{
	0:  "PrimaryNodes",
	1:  "DatabaseEngine",
	2:  "DatabaseVersion",
	3:  "DefaultUser",
	4:  "DiskSize",
	5:  "Memory",
	6:  "Nodes",
	7:  "Port",
	8:  "Storage",
	9:  "Virtualcore",
	10: "Zone",
}

// Decode decodes GetNosqlApplianceRemarkNosql from json.
func (s *GetNosqlApplianceRemarkNosql) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNosqlApplianceRemarkNosql to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "PrimaryNodes":
			if err := func() error {
				s.PrimaryNodes.Reset()
				if err := s.PrimaryNodes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PrimaryNodes\"")
			}
		case "DatabaseEngine":
			if err := func() error {
				s.DatabaseEngine.Reset()
				if err := s.DatabaseEngine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DatabaseEngine\"")
			}
		case "DatabaseVersion":
			if err := func() error {
				s.DatabaseVersion.Reset()
				if err := s.DatabaseVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DatabaseVersion\"")
			}
		case "DefaultUser":
			if err := func() error {
				s.DefaultUser.Reset()
				if err := s.DefaultUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DefaultUser\"")
			}
		case "DiskSize":
			if err := func() error {
				s.DiskSize.Reset()
				if err := s.DiskSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DiskSize\"")
			}
		case "Memory":
			if err := func() error {
				s.Memory.Reset()
				if err := s.Memory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Memory\"")
			}
		case "Nodes":
			if err := func() error {
				s.Nodes.Reset()
				if err := s.Nodes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Nodes\"")
			}
		case "Port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Port\"")
			}
		case "Storage":
			if err := func() error {
				s.Storage.Reset()
				if err := s.Storage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Storage\"")
			}
		case "Virtualcore":
			if err := func() error {
				s.Virtualcore.Reset()
				if err := s.Virtualcore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Virtualcore\"")
			}
		case "Zone":
			if err := func() error {
				s.Zone.Reset()
				if err := s.Zone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Zone\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNosqlApplianceRemarkNosql")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNosqlApplianceRemarkNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNosqlApplianceRemarkNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlApplianceRemarkNosqlDatabaseEngine as json.
func (s GetNosqlApplianceRemarkNosqlDatabaseEngine) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetNosqlApplianceRemarkNosqlDatabaseEngine from json.
func (s *GetNosqlApplianceRemarkNosqlDatabaseEngine) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNosqlApplianceRemarkNosqlDatabaseEngine to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetNosqlApplianceRemarkNosqlDatabaseEngine(v) {
	case GetNosqlApplianceRemarkNosqlDatabaseEngineCassandra:
		*s = GetNosqlApplianceRemarkNosqlDatabaseEngineCassandra
	default:
		*s = GetNosqlApplianceRemarkNosqlDatabaseEngine(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetNosqlApplianceRemarkNosqlDatabaseEngine) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNosqlApplianceRemarkNosqlDatabaseEngine) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlApplianceRemarkNosqlDiskSize as json.
func (s GetNosqlApplianceRemarkNosqlDiskSize) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes GetNosqlApplianceRemarkNosqlDiskSize from json.
func (s *GetNosqlApplianceRemarkNosqlDiskSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNosqlApplianceRemarkNosqlDiskSize to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = GetNosqlApplianceRemarkNosqlDiskSize(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetNosqlApplianceRemarkNosqlDiskSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNosqlApplianceRemarkNosqlDiskSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlApplianceRemarkNosqlMemory as json.
func (s GetNosqlApplianceRemarkNosqlMemory) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes GetNosqlApplianceRemarkNosqlMemory from json.
func (s *GetNosqlApplianceRemarkNosqlMemory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNosqlApplianceRemarkNosqlMemory to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = GetNosqlApplianceRemarkNosqlMemory(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetNosqlApplianceRemarkNosqlMemory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNosqlApplianceRemarkNosqlMemory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNosqlApplianceRemarkNosqlPrimaryNodes) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNosqlApplianceRemarkNosqlPrimaryNodes) encodeFields(e *jx.Encoder) {
	{
		if s.Appliance.Set {
			e.FieldStart("Appliance")
			s.Appliance.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetNosqlApplianceRemarkNosqlPrimaryNodes = [1]string{
	0: "Appliance",
}

// Decode decodes GetNosqlApplianceRemarkNosqlPrimaryNodes from json.
func (s *GetNosqlApplianceRemarkNosqlPrimaryNodes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNosqlApplianceRemarkNosqlPrimaryNodes to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Appliance":
			if err := func() error {
				s.Appliance.Reset()
				if err := s.Appliance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Appliance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNosqlApplianceRemarkNosqlPrimaryNodes")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNosqlApplianceRemarkNosqlPrimaryNodes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNosqlApplianceRemarkNosqlPrimaryNodes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNosqlApplianceRemarkNosqlPrimaryNodesAppliance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNosqlApplianceRemarkNosqlPrimaryNodesAppliance) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("ID")
			s.ID.Encode(e)
		}
	}
	{
		if s.Zone.Set {
			e.FieldStart("Zone")
			s.Zone.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetNosqlApplianceRemarkNosqlPrimaryNodesAppliance = [2]string{
	0: "ID",
	1: "Zone",
}

// Decode decodes GetNosqlApplianceRemarkNosqlPrimaryNodesAppliance from json.
func (s *GetNosqlApplianceRemarkNosqlPrimaryNodesAppliance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNosqlApplianceRemarkNosqlPrimaryNodesAppliance to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ID":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		case "Zone":
			if err := func() error {
				s.Zone.Reset()
				if err := s.Zone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Zone\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNosqlApplianceRemarkNosqlPrimaryNodesAppliance")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNosqlApplianceRemarkNosqlPrimaryNodesAppliance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNosqlApplianceRemarkNosqlPrimaryNodesAppliance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNosqlApplianceRemarkNosqlPrimaryNodesApplianceZone) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNosqlApplianceRemarkNosqlPrimaryNodesApplianceZone) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("Name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetNosqlApplianceRemarkNosqlPrimaryNodesApplianceZone = [1]string{
	0: "Name",
}

// Decode decodes GetNosqlApplianceRemarkNosqlPrimaryNodesApplianceZone from json.
func (s *GetNosqlApplianceRemarkNosqlPrimaryNodesApplianceZone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNosqlApplianceRemarkNosqlPrimaryNodesApplianceZone to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNosqlApplianceRemarkNosqlPrimaryNodesApplianceZone")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNosqlApplianceRemarkNosqlPrimaryNodesApplianceZone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNosqlApplianceRemarkNosqlPrimaryNodesApplianceZone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlApplianceRemarkNosqlStorage as json.
func (s GetNosqlApplianceRemarkNosqlStorage) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetNosqlApplianceRemarkNosqlStorage from json.
func (s *GetNosqlApplianceRemarkNosqlStorage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNosqlApplianceRemarkNosqlStorage to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetNosqlApplianceRemarkNosqlStorage(v) {
	case GetNosqlApplianceRemarkNosqlStorageSSD:
		*s = GetNosqlApplianceRemarkNosqlStorageSSD
	default:
		*s = GetNosqlApplianceRemarkNosqlStorage(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetNosqlApplianceRemarkNosqlStorage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNosqlApplianceRemarkNosqlStorage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlApplianceRemarkNosqlVirtualcore as json.
func (s GetNosqlApplianceRemarkNosqlVirtualcore) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes GetNosqlApplianceRemarkNosqlVirtualcore from json.
func (s *GetNosqlApplianceRemarkNosqlVirtualcore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNosqlApplianceRemarkNosqlVirtualcore to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = GetNosqlApplianceRemarkNosqlVirtualcore(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetNosqlApplianceRemarkNosqlVirtualcore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNosqlApplianceRemarkNosqlVirtualcore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNosqlApplianceRemarkServersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNosqlApplianceRemarkServersItem) encodeFields(e *jx.Encoder) {
	{
		if s.UserIPAddress.Set {
			e.FieldStart("UserIPAddress")
			s.UserIPAddress.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetNosqlApplianceRemarkServersItem = [1]string{
	0: "UserIPAddress",
}

// Decode decodes GetNosqlApplianceRemarkServersItem from json.
func (s *GetNosqlApplianceRemarkServersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNosqlApplianceRemarkServersItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "UserIPAddress":
			if err := func() error {
				s.UserIPAddress.Reset()
				if err := s.UserIPAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UserIPAddress\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNosqlApplianceRemarkServersItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNosqlApplianceRemarkServersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNosqlApplianceRemarkServersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNosqlApplianceRemarkZone) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNosqlApplianceRemarkZone) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("ID")
			s.ID.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetNosqlApplianceRemarkZone = [1]string{
	0: "ID",
}

// Decode decodes GetNosqlApplianceRemarkZone from json.
func (s *GetNosqlApplianceRemarkZone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNosqlApplianceRemarkZone to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ID":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNosqlApplianceRemarkZone")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNosqlApplianceRemarkZone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNosqlApplianceRemarkZone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNosqlSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNosqlSettings) encodeFields(e *jx.Encoder) {
	{
		if s.Backup.Set {
			e.FieldStart("Backup")
			s.Backup.Encode(e)
		}
	}
	{
		if s.SourceNetwork != nil {
			e.FieldStart("SourceNetwork")
			e.ArrStart()
			for _, elem := range s.SourceNetwork {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReserveIPAddress.Set {
			e.FieldStart("ReserveIPAddress")
			s.ReserveIPAddress.Encode(e)
		}
	}
	{
		if s.Repair.Set {
			e.FieldStart("Repair")
			s.Repair.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetNosqlSettings = [4]string{
	0: "Backup",
	1: "SourceNetwork",
	2: "ReserveIPAddress",
	3: "Repair",
}

// Decode decodes GetNosqlSettings from json.
func (s *GetNosqlSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNosqlSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Backup":
			if err := func() error {
				s.Backup.Reset()
				if err := s.Backup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Backup\"")
			}
		case "SourceNetwork":
			if err := func() error {
				s.SourceNetwork = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SourceNetwork = append(s.SourceNetwork, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SourceNetwork\"")
			}
		case "ReserveIPAddress":
			if err := func() error {
				s.ReserveIPAddress.Reset()
				if err := s.ReserveIPAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ReserveIPAddress\"")
			}
		case "Repair":
			if err := func() error {
				s.Repair.Reset()
				if err := s.Repair.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Repair\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNosqlSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNosqlSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNosqlSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNosqlSettingsBackup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNosqlSettingsBackup) encodeFields(e *jx.Encoder) {
	{
		if s.Connect.Set {
			e.FieldStart("Connect")
			s.Connect.Encode(e)
		}
	}
	{
		if s.DayOfWeek.Set {
			e.FieldStart("DayOfWeek")
			s.DayOfWeek.Encode(e)
		}
	}
	{
		if s.Time.Set {
			e.FieldStart("Time")
			s.Time.Encode(e)
		}
	}
	{
		if s.Rotate.Set {
			e.FieldStart("Rotate")
			s.Rotate.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetNosqlSettingsBackup = [4]string{
	0: "Connect",
	1: "DayOfWeek",
	2: "Time",
	3: "Rotate",
}

// Decode decodes GetNosqlSettingsBackup from json.
func (s *GetNosqlSettingsBackup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNosqlSettingsBackup to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Connect":
			if err := func() error {
				s.Connect.Reset()
				if err := s.Connect.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Connect\"")
			}
		case "DayOfWeek":
			if err := func() error {
				s.DayOfWeek.Reset()
				if err := s.DayOfWeek.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DayOfWeek\"")
			}
		case "Time":
			if err := func() error {
				s.Time.Reset()
				if err := s.Time.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Time\"")
			}
		case "Rotate":
			if err := func() error {
				s.Rotate.Reset()
				if err := s.Rotate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Rotate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNosqlSettingsBackup")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNosqlSettingsBackup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNosqlSettingsBackup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlSettingsBackupDayOfWeekItem as json.
func (s GetNosqlSettingsBackupDayOfWeekItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetNosqlSettingsBackupDayOfWeekItem from json.
func (s *GetNosqlSettingsBackupDayOfWeekItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNosqlSettingsBackupDayOfWeekItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetNosqlSettingsBackupDayOfWeekItem(v) {
	case GetNosqlSettingsBackupDayOfWeekItemSun:
		*s = GetNosqlSettingsBackupDayOfWeekItemSun
	case GetNosqlSettingsBackupDayOfWeekItemMon:
		*s = GetNosqlSettingsBackupDayOfWeekItemMon
	case GetNosqlSettingsBackupDayOfWeekItemTue:
		*s = GetNosqlSettingsBackupDayOfWeekItemTue
	case GetNosqlSettingsBackupDayOfWeekItemWed:
		*s = GetNosqlSettingsBackupDayOfWeekItemWed
	case GetNosqlSettingsBackupDayOfWeekItemThu:
		*s = GetNosqlSettingsBackupDayOfWeekItemThu
	case GetNosqlSettingsBackupDayOfWeekItemFri:
		*s = GetNosqlSettingsBackupDayOfWeekItemFri
	case GetNosqlSettingsBackupDayOfWeekItemSat:
		*s = GetNosqlSettingsBackupDayOfWeekItemSat
	default:
		*s = GetNosqlSettingsBackupDayOfWeekItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetNosqlSettingsBackupDayOfWeekItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNosqlSettingsBackupDayOfWeekItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNosqlSettingsRepair) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNosqlSettingsRepair) encodeFields(e *jx.Encoder) {
	{
		if s.Incremental.Set {
			e.FieldStart("Incremental")
			s.Incremental.Encode(e)
		}
	}
	{
		if s.Full.Set {
			e.FieldStart("Full")
			s.Full.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetNosqlSettingsRepair = [2]string{
	0: "Incremental",
	1: "Full",
}

// Decode decodes GetNosqlSettingsRepair from json.
func (s *GetNosqlSettingsRepair) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNosqlSettingsRepair to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Incremental":
			if err := func() error {
				s.Incremental.Reset()
				if err := s.Incremental.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Incremental\"")
			}
		case "Full":
			if err := func() error {
				s.Full.Reset()
				if err := s.Full.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Full\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNosqlSettingsRepair")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNosqlSettingsRepair) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNosqlSettingsRepair) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNosqlSettingsRepairFull) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNosqlSettingsRepairFull) encodeFields(e *jx.Encoder) {
	{
		if s.Interval.Set {
			e.FieldStart("Interval")
			s.Interval.Encode(e)
		}
	}
	{
		if s.DayOfWeek.Set {
			e.FieldStart("DayOfWeek")
			s.DayOfWeek.Encode(e)
		}
	}
	{
		if s.Time.Set {
			e.FieldStart("Time")
			s.Time.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetNosqlSettingsRepairFull = [3]string{
	0: "Interval",
	1: "DayOfWeek",
	2: "Time",
}

// Decode decodes GetNosqlSettingsRepairFull from json.
func (s *GetNosqlSettingsRepairFull) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNosqlSettingsRepairFull to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Interval":
			if err := func() error {
				s.Interval.Reset()
				if err := s.Interval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Interval\"")
			}
		case "DayOfWeek":
			if err := func() error {
				s.DayOfWeek.Reset()
				if err := s.DayOfWeek.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DayOfWeek\"")
			}
		case "Time":
			if err := func() error {
				s.Time.Reset()
				if err := s.Time.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNosqlSettingsRepairFull")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNosqlSettingsRepairFull) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNosqlSettingsRepairFull) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlSettingsRepairFullDayOfWeek as json.
func (s GetNosqlSettingsRepairFullDayOfWeek) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetNosqlSettingsRepairFullDayOfWeek from json.
func (s *GetNosqlSettingsRepairFullDayOfWeek) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNosqlSettingsRepairFullDayOfWeek to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetNosqlSettingsRepairFullDayOfWeek(v) {
	case GetNosqlSettingsRepairFullDayOfWeekSun:
		*s = GetNosqlSettingsRepairFullDayOfWeekSun
	case GetNosqlSettingsRepairFullDayOfWeekMon:
		*s = GetNosqlSettingsRepairFullDayOfWeekMon
	case GetNosqlSettingsRepairFullDayOfWeekTue:
		*s = GetNosqlSettingsRepairFullDayOfWeekTue
	case GetNosqlSettingsRepairFullDayOfWeekWed:
		*s = GetNosqlSettingsRepairFullDayOfWeekWed
	case GetNosqlSettingsRepairFullDayOfWeekThu:
		*s = GetNosqlSettingsRepairFullDayOfWeekThu
	case GetNosqlSettingsRepairFullDayOfWeekFri:
		*s = GetNosqlSettingsRepairFullDayOfWeekFri
	case GetNosqlSettingsRepairFullDayOfWeekSat:
		*s = GetNosqlSettingsRepairFullDayOfWeekSat
	default:
		*s = GetNosqlSettingsRepairFullDayOfWeek(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetNosqlSettingsRepairFullDayOfWeek) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNosqlSettingsRepairFullDayOfWeek) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlSettingsRepairFullInterval as json.
func (s GetNosqlSettingsRepairFullInterval) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes GetNosqlSettingsRepairFullInterval from json.
func (s *GetNosqlSettingsRepairFullInterval) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNosqlSettingsRepairFullInterval to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = GetNosqlSettingsRepairFullInterval(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetNosqlSettingsRepairFullInterval) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNosqlSettingsRepairFullInterval) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNosqlSettingsRepairIncremental) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNosqlSettingsRepairIncremental) encodeFields(e *jx.Encoder) {
	{
		if s.DaysOfWeek != nil {
			e.FieldStart("DaysOfWeek")
			e.ArrStart()
			for _, elem := range s.DaysOfWeek {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Time.Set {
			e.FieldStart("Time")
			s.Time.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetNosqlSettingsRepairIncremental = [2]string{
	0: "DaysOfWeek",
	1: "Time",
}

// Decode decodes GetNosqlSettingsRepairIncremental from json.
func (s *GetNosqlSettingsRepairIncremental) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNosqlSettingsRepairIncremental to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "DaysOfWeek":
			if err := func() error {
				s.DaysOfWeek = make([]GetNosqlSettingsRepairIncrementalDaysOfWeekItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetNosqlSettingsRepairIncrementalDaysOfWeekItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DaysOfWeek = append(s.DaysOfWeek, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DaysOfWeek\"")
			}
		case "Time":
			if err := func() error {
				s.Time.Reset()
				if err := s.Time.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNosqlSettingsRepairIncremental")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNosqlSettingsRepairIncremental) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNosqlSettingsRepairIncremental) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlSettingsRepairIncrementalDaysOfWeekItem as json.
func (s GetNosqlSettingsRepairIncrementalDaysOfWeekItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetNosqlSettingsRepairIncrementalDaysOfWeekItem from json.
func (s *GetNosqlSettingsRepairIncrementalDaysOfWeekItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNosqlSettingsRepairIncrementalDaysOfWeekItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetNosqlSettingsRepairIncrementalDaysOfWeekItem(v) {
	case GetNosqlSettingsRepairIncrementalDaysOfWeekItemSun:
		*s = GetNosqlSettingsRepairIncrementalDaysOfWeekItemSun
	case GetNosqlSettingsRepairIncrementalDaysOfWeekItemMon:
		*s = GetNosqlSettingsRepairIncrementalDaysOfWeekItemMon
	case GetNosqlSettingsRepairIncrementalDaysOfWeekItemTue:
		*s = GetNosqlSettingsRepairIncrementalDaysOfWeekItemTue
	case GetNosqlSettingsRepairIncrementalDaysOfWeekItemWed:
		*s = GetNosqlSettingsRepairIncrementalDaysOfWeekItemWed
	case GetNosqlSettingsRepairIncrementalDaysOfWeekItemThu:
		*s = GetNosqlSettingsRepairIncrementalDaysOfWeekItemThu
	case GetNosqlSettingsRepairIncrementalDaysOfWeekItemFri:
		*s = GetNosqlSettingsRepairIncrementalDaysOfWeekItemFri
	case GetNosqlSettingsRepairIncrementalDaysOfWeekItemSat:
		*s = GetNosqlSettingsRepairIncrementalDaysOfWeekItemSat
	default:
		*s = GetNosqlSettingsRepairIncrementalDaysOfWeekItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetNosqlSettingsRepairIncrementalDaysOfWeekItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNosqlSettingsRepairIncrementalDaysOfWeekItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetParameterResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetParameterResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Nosql.Set {
			e.FieldStart("nosql")
			s.Nosql.Encode(e)
		}
	}
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetParameterResponse = [2]string{
	0: "nosql",
	1: "is_ok",
}

// Decode decodes GetParameterResponse from json.
func (s *GetParameterResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParameterResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nosql":
			if err := func() error {
				s.Nosql.Reset()
				if err := s.Nosql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nosql\"")
			}
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetParameterResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParameterResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParameterResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetParameterResponseNosql) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetParameterResponseNosql) encodeFields(e *jx.Encoder) {
	{
		if s.Parameters != nil {
			e.FieldStart("parameters")
			e.ArrStart()
			for _, elem := range s.Parameters {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGetParameterResponseNosql = [1]string{
	0: "parameters",
}

// Decode decodes GetParameterResponseNosql from json.
func (s *GetParameterResponseNosql) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParameterResponseNosql to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "parameters":
			if err := func() error {
				s.Parameters = make([]NosqlGetParameter, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NosqlGetParameter
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Parameters = append(s.Parameters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetParameterResponseNosql")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParameterResponseNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParameterResponseNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPlan) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPlan) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("ID")
			s.ID.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetPlan = [1]string{
	0: "ID",
}

// Decode decodes GetPlan from json.
func (s *GetPlan) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPlan to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ID":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetPlan")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPlan) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPlan) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetServiceClass as json.
func (s GetServiceClass) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes GetServiceClass from json.
func (s *GetServiceClass) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetServiceClass to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetServiceClass(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetServiceClass) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetServiceClass) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Instance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Instance) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("Status")
			s.Status.Encode(e)
		}
	}
	{
		if s.StatusChangedAt.Set {
			e.FieldStart("StatusChangedAt")
			s.StatusChangedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Host.Set {
			e.FieldStart("Host")
			s.Host.Encode(e)
		}
	}
	{
		if s.Hosts != nil {
			e.FieldStart("Hosts")
			e.ArrStart()
			for _, elem := range s.Hosts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfInstance = [4]string{
	0: "Status",
	1: "StatusChangedAt",
	2: "Host",
	3: "Hosts",
}

// Decode decodes Instance from json.
func (s *Instance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Instance to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Status\"")
			}
		case "StatusChangedAt":
			if err := func() error {
				s.StatusChangedAt.Reset()
				if err := s.StatusChangedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"StatusChangedAt\"")
			}
		case "Host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Host\"")
			}
		case "Hosts":
			if err := func() error {
				s.Hosts = make([]InstanceHostsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InstanceHostsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Hosts = append(s.Hosts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Hosts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Instance")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Instance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Instance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InstanceHost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InstanceHost) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("Name")
			s.Name.Encode(e)
		}
	}
	{
		if s.InfoURL.Set {
			e.FieldStart("InfoURL")
			s.InfoURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfInstanceHost = [2]string{
	0: "Name",
	1: "InfoURL",
}

// Decode decodes InstanceHost from json.
func (s *InstanceHost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstanceHost to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Name\"")
			}
		case "InfoURL":
			if err := func() error {
				s.InfoURL.Reset()
				if err := s.InfoURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"InfoURL\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InstanceHost")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InstanceHost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InstanceHost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InstanceHostsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InstanceHostsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("Name")
			s.Name.Encode(e)
		}
	}
	{
		if s.InfoURL.Set {
			e.FieldStart("InfoURL")
			s.InfoURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfInstanceHostsItem = [2]string{
	0: "Name",
	1: "InfoURL",
}

// Decode decodes InstanceHostsItem from json.
func (s *InstanceHostsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstanceHostsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Name\"")
			}
		case "InfoURL":
			if err := func() error {
				s.InfoURL.Reset()
				if err := s.InfoURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"InfoURL\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InstanceHostsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InstanceHostsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InstanceHostsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IsOk as json.
func (s IsOk) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes IsOk from json.
func (s *IsOk) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IsOk to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IsOk(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IsOk) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IsOk) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodeHealth) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodeHealth) encodeFields(e *jx.Encoder) {
	{
		if s.Success.Set {
			e.FieldStart("Success")
			s.Success.Encode(e)
		}
	}
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
	{
		if s.Nosql.Set {
			e.FieldStart("Nosql")
			s.Nosql.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodeHealth = [3]string{
	0: "Success",
	1: "is_ok",
	2: "Nosql",
}

// Decode decodes NodeHealth from json.
func (s *NodeHealth) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodeHealth to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Success":
			if err := func() error {
				s.Success.Reset()
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Success\"")
			}
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		case "Nosql":
			if err := func() error {
				s.Nosql.Reset()
				if err := s.Nosql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Nosql\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodeHealth")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodeHealth) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodeHealth) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodeHealthNosql) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodeHealthNosql) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("Status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodeHealthNosql = [1]string{
	0: "Status",
}

// Decode decodes NodeHealthNosql from json.
func (s *NodeHealthNosql) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodeHealthNosql to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodeHealthNosql")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodeHealthNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodeHealthNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NodeHealthNosqlStatus as json.
func (s NodeHealthNosqlStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NodeHealthNosqlStatus from json.
func (s *NodeHealthNosqlStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodeHealthNosqlStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NodeHealthNosqlStatus(v) {
	case NodeHealthNosqlStatusHealthy:
		*s = NodeHealthNosqlStatusHealthy
	case NodeHealthNosqlStatusHealthyPartial:
		*s = NodeHealthNosqlStatusHealthyPartial
	case NodeHealthNosqlStatusUnhealthy:
		*s = NodeHealthNosqlStatusUnhealthy
	default:
		*s = NodeHealthNosqlStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NodeHealthNosqlStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodeHealthNosqlStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlAppliance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlAppliance) encodeFields(e *jx.Encoder) {
	{
		if s.Class.Set {
			e.FieldStart("Class")
			s.Class.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("Name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("Description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Tags.Set {
			e.FieldStart("Tags")
			s.Tags.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("ID")
			s.ID.Encode(e)
		}
	}
	{
		if s.Plan.Set {
			e.FieldStart("Plan")
			s.Plan.Encode(e)
		}
	}
	{
		if s.Settings.Set {
			e.FieldStart("Settings")
			s.Settings.Encode(e)
		}
	}
	{
		if s.SettingsHash.Set {
			e.FieldStart("SettingsHash")
			s.SettingsHash.Encode(e)
		}
	}
	{
		if s.Remark.Set {
			e.FieldStart("Remark")
			s.Remark.Encode(e)
		}
	}
	{
		if s.Availability.Set {
			e.FieldStart("Availability")
			s.Availability.Encode(e)
		}
	}
	{
		if s.Instance.Set {
			e.FieldStart("Instance")
			s.Instance.Encode(e)
		}
	}
	{
		if s.Disk.Set {
			e.FieldStart("Disk")
			s.Disk.Encode(e)
		}
	}
	{
		if s.ServiceClass.Set {
			e.FieldStart("ServiceClass")
			s.ServiceClass.Encode(e)
		}
	}
	{
		if s.Generation.Set {
			e.FieldStart("Generation")
			s.Generation.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("CreatedAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Interfaces != nil {
			e.FieldStart("Interfaces")
			e.ArrStart()
			for _, elem := range s.Interfaces {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNosqlAppliance = [16]string{
	0:  "Class",
	1:  "Name",
	2:  "Description",
	3:  "Tags",
	4:  "ID",
	5:  "Plan",
	6:  "Settings",
	7:  "SettingsHash",
	8:  "Remark",
	9:  "Availability",
	10: "Instance",
	11: "Disk",
	12: "ServiceClass",
	13: "Generation",
	14: "CreatedAt",
	15: "Interfaces",
}

// Decode decodes NosqlAppliance from json.
func (s *NosqlAppliance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlAppliance to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Class":
			if err := func() error {
				s.Class.Reset()
				if err := s.Class.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Class\"")
			}
		case "Name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Name\"")
			}
		case "Description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Description\"")
			}
		case "Tags":
			if err := func() error {
				s.Tags.Reset()
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Tags\"")
			}
		case "ID":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		case "Plan":
			if err := func() error {
				s.Plan.Reset()
				if err := s.Plan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Plan\"")
			}
		case "Settings":
			if err := func() error {
				s.Settings.Reset()
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Settings\"")
			}
		case "SettingsHash":
			if err := func() error {
				s.SettingsHash.Reset()
				if err := s.SettingsHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SettingsHash\"")
			}
		case "Remark":
			if err := func() error {
				s.Remark.Reset()
				if err := s.Remark.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Remark\"")
			}
		case "Availability":
			if err := func() error {
				s.Availability.Reset()
				if err := s.Availability.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Availability\"")
			}
		case "Instance":
			if err := func() error {
				s.Instance.Reset()
				if err := s.Instance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Instance\"")
			}
		case "Disk":
			if err := func() error {
				s.Disk.Reset()
				if err := s.Disk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Disk\"")
			}
		case "ServiceClass":
			if err := func() error {
				s.ServiceClass.Reset()
				if err := s.ServiceClass.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ServiceClass\"")
			}
		case "Generation":
			if err := func() error {
				s.Generation.Reset()
				if err := s.Generation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Generation\"")
			}
		case "CreatedAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"CreatedAt\"")
			}
		case "Interfaces":
			if err := func() error {
				s.Interfaces = make([]NosqlApplianceInterfacesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NosqlApplianceInterfacesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Interfaces = append(s.Interfaces, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Interfaces\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlAppliance")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlAppliance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlAppliance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlApplianceDisk) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlApplianceDisk) encodeFields(e *jx.Encoder) {
	{
		if s.EncryptionKey.Set {
			e.FieldStart("EncryptionKey")
			s.EncryptionKey.Encode(e)
		}
	}
	{
		if s.EncryptionAlgorithm.Set {
			e.FieldStart("EncryptionAlgorithm")
			s.EncryptionAlgorithm.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlApplianceDisk = [2]string{
	0: "EncryptionKey",
	1: "EncryptionAlgorithm",
}

// Decode decodes NosqlApplianceDisk from json.
func (s *NosqlApplianceDisk) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceDisk to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "EncryptionKey":
			if err := func() error {
				s.EncryptionKey.Reset()
				if err := s.EncryptionKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"EncryptionKey\"")
			}
		case "EncryptionAlgorithm":
			if err := func() error {
				s.EncryptionAlgorithm.Reset()
				if err := s.EncryptionAlgorithm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"EncryptionAlgorithm\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlApplianceDisk")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlApplianceDisk) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceDisk) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlApplianceDiskEncryptionKey) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlApplianceDiskEncryptionKey) encodeFields(e *jx.Encoder) {
	{
		if s.KMSKeyID.Set {
			e.FieldStart("KMSKeyID")
			s.KMSKeyID.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlApplianceDiskEncryptionKey = [1]string{
	0: "KMSKeyID",
}

// Decode decodes NosqlApplianceDiskEncryptionKey from json.
func (s *NosqlApplianceDiskEncryptionKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceDiskEncryptionKey to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "KMSKeyID":
			if err := func() error {
				s.KMSKeyID.Reset()
				if err := s.KMSKeyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"KMSKeyID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlApplianceDiskEncryptionKey")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlApplianceDiskEncryptionKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceDiskEncryptionKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlApplianceInterfacesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlApplianceInterfacesItem) encodeFields(e *jx.Encoder) {
	{
		if s.IPAddress.Set {
			e.FieldStart("IPAddress")
			s.IPAddress.Encode(e)
		}
	}
	{
		if s.UserIPAddress.Set {
			e.FieldStart("UserIPAddress")
			s.UserIPAddress.Encode(e)
		}
	}
	{
		if s.HostName.Set {
			e.FieldStart("HostName")
			s.HostName.Encode(e)
		}
	}
	{
		if s.Switch.Set {
			e.FieldStart("Switch")
			s.Switch.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlApplianceInterfacesItem = [4]string{
	0: "IPAddress",
	1: "UserIPAddress",
	2: "HostName",
	3: "Switch",
}

// Decode decodes NosqlApplianceInterfacesItem from json.
func (s *NosqlApplianceInterfacesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceInterfacesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "IPAddress":
			if err := func() error {
				s.IPAddress.Reset()
				if err := s.IPAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"IPAddress\"")
			}
		case "UserIPAddress":
			if err := func() error {
				s.UserIPAddress.Reset()
				if err := s.UserIPAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UserIPAddress\"")
			}
		case "HostName":
			if err := func() error {
				s.HostName.Reset()
				if err := s.HostName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"HostName\"")
			}
		case "Switch":
			if err := func() error {
				s.Switch.Reset()
				if err := s.Switch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Switch\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlApplianceInterfacesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlApplianceInterfacesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceInterfacesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlApplianceInterfacesItemSwitch) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlApplianceInterfacesItemSwitch) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ID")
		e.Str(s.ID)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Scope.Set {
			e.FieldStart("Scope")
			s.Scope.Encode(e)
		}
	}
	{
		if s.Subnet.Set {
			e.FieldStart("Subnet")
			s.Subnet.Encode(e)
		}
	}
	{
		if s.UserSubnet.Set {
			e.FieldStart("UserSubnet")
			s.UserSubnet.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlApplianceInterfacesItemSwitch = [5]string{
	0: "ID",
	1: "name",
	2: "Scope",
	3: "Subnet",
	4: "UserSubnet",
}

// Decode decodes NosqlApplianceInterfacesItemSwitch from json.
func (s *NosqlApplianceInterfacesItemSwitch) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceInterfacesItemSwitch to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ID":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "Scope":
			if err := func() error {
				s.Scope.Reset()
				if err := s.Scope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Scope\"")
			}
		case "Subnet":
			if err := func() error {
				s.Subnet.Reset()
				if err := s.Subnet.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Subnet\"")
			}
		case "UserSubnet":
			if err := func() error {
				s.UserSubnet.Reset()
				if err := s.UserSubnet.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UserSubnet\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlApplianceInterfacesItemSwitch")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlApplianceInterfacesItemSwitch) {
					name = jsonFieldsNameOfNosqlApplianceInterfacesItemSwitch[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlApplianceInterfacesItemSwitch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceInterfacesItemSwitch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlApplianceInterfacesItemSwitchSubnet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlApplianceInterfacesItemSwitchSubnet) encodeFields(e *jx.Encoder) {
	{
		if s.NetworkAddress.Set {
			e.FieldStart("NetworkAddress")
			s.NetworkAddress.Encode(e)
		}
	}
	{
		if s.NetworkMaskLen.Set {
			e.FieldStart("NetworkMaskLen")
			s.NetworkMaskLen.Encode(e)
		}
	}
	{
		if s.DefaultRoute.Set {
			e.FieldStart("DefaultRoute")
			s.DefaultRoute.Encode(e)
		}
	}
	{
		if s.Internet.Set {
			e.FieldStart("Internet")
			s.Internet.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlApplianceInterfacesItemSwitchSubnet = [4]string{
	0: "NetworkAddress",
	1: "NetworkMaskLen",
	2: "DefaultRoute",
	3: "Internet",
}

// Decode decodes NosqlApplianceInterfacesItemSwitchSubnet from json.
func (s *NosqlApplianceInterfacesItemSwitchSubnet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceInterfacesItemSwitchSubnet to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "NetworkAddress":
			if err := func() error {
				s.NetworkAddress.Reset()
				if err := s.NetworkAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"NetworkAddress\"")
			}
		case "NetworkMaskLen":
			if err := func() error {
				s.NetworkMaskLen.Reset()
				if err := s.NetworkMaskLen.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"NetworkMaskLen\"")
			}
		case "DefaultRoute":
			if err := func() error {
				s.DefaultRoute.Reset()
				if err := s.DefaultRoute.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DefaultRoute\"")
			}
		case "Internet":
			if err := func() error {
				s.Internet.Reset()
				if err := s.Internet.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Internet\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlApplianceInterfacesItemSwitchSubnet")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlApplianceInterfacesItemSwitchSubnet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceInterfacesItemSwitchSubnet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlApplianceInterfacesItemSwitchSubnetInternet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlApplianceInterfacesItemSwitchSubnetInternet) encodeFields(e *jx.Encoder) {
	{
		if s.BandWidthMbps.Set {
			e.FieldStart("BandWidthMbps")
			s.BandWidthMbps.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlApplianceInterfacesItemSwitchSubnetInternet = [1]string{
	0: "BandWidthMbps",
}

// Decode decodes NosqlApplianceInterfacesItemSwitchSubnetInternet from json.
func (s *NosqlApplianceInterfacesItemSwitchSubnetInternet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceInterfacesItemSwitchSubnetInternet to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "BandWidthMbps":
			if err := func() error {
				s.BandWidthMbps.Reset()
				if err := s.BandWidthMbps.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"BandWidthMbps\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlApplianceInterfacesItemSwitchSubnetInternet")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlApplianceInterfacesItemSwitchSubnetInternet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceInterfacesItemSwitchSubnetInternet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlApplianceInterfacesItemSwitchUserSubnet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlApplianceInterfacesItemSwitchUserSubnet) encodeFields(e *jx.Encoder) {
	{
		if s.DefaultRoute.Set {
			e.FieldStart("DefaultRoute")
			s.DefaultRoute.Encode(e)
		}
	}
	{
		if s.NetworkMaskLen.Set {
			e.FieldStart("NetworkMaskLen")
			s.NetworkMaskLen.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlApplianceInterfacesItemSwitchUserSubnet = [2]string{
	0: "DefaultRoute",
	1: "NetworkMaskLen",
}

// Decode decodes NosqlApplianceInterfacesItemSwitchUserSubnet from json.
func (s *NosqlApplianceInterfacesItemSwitchUserSubnet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceInterfacesItemSwitchUserSubnet to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "DefaultRoute":
			if err := func() error {
				s.DefaultRoute.Reset()
				if err := s.DefaultRoute.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DefaultRoute\"")
			}
		case "NetworkMaskLen":
			if err := func() error {
				s.NetworkMaskLen.Reset()
				if err := s.NetworkMaskLen.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"NetworkMaskLen\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlApplianceInterfacesItemSwitchUserSubnet")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlApplianceInterfacesItemSwitchUserSubnet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceInterfacesItemSwitchUserSubnet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlApplianceRemark) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlApplianceRemark) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Nosql")
		s.Nosql.Encode(e)
	}
	{
		if s.Servers != nil {
			e.FieldStart("Servers")
			e.ArrStart()
			for _, elem := range s.Servers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Zone.Set {
			e.FieldStart("Zone")
			s.Zone.Encode(e)
		}
	}
	{
		if s.ServiceClass.Set {
			e.FieldStart("ServiceClass")
			s.ServiceClass.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlApplianceRemark = [4]string{
	0: "Nosql",
	1: "Servers",
	2: "Zone",
	3: "ServiceClass",
}

// Decode decodes NosqlApplianceRemark from json.
func (s *NosqlApplianceRemark) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceRemark to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Nosql":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Nosql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Nosql\"")
			}
		case "Servers":
			if err := func() error {
				s.Servers = make([]NosqlApplianceRemarkServersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NosqlApplianceRemarkServersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Servers = append(s.Servers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Servers\"")
			}
		case "Zone":
			if err := func() error {
				s.Zone.Reset()
				if err := s.Zone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Zone\"")
			}
		case "ServiceClass":
			if err := func() error {
				s.ServiceClass.Reset()
				if err := s.ServiceClass.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ServiceClass\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlApplianceRemark")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlApplianceRemark) {
					name = jsonFieldsNameOfNosqlApplianceRemark[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlApplianceRemark) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceRemark) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlApplianceRemarkNosql) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlApplianceRemarkNosql) encodeFields(e *jx.Encoder) {
	{
		if s.PrimaryNodes.Set {
			e.FieldStart("PrimaryNodes")
			s.PrimaryNodes.Encode(e)
		}
	}
	{
		if s.DatabaseEngine.Set {
			e.FieldStart("DatabaseEngine")
			s.DatabaseEngine.Encode(e)
		}
	}
	{
		if s.DatabaseVersion.Set {
			e.FieldStart("DatabaseVersion")
			s.DatabaseVersion.Encode(e)
		}
	}
	{
		if s.DefaultUser.Set {
			e.FieldStart("DefaultUser")
			s.DefaultUser.Encode(e)
		}
	}
	{
		if s.DiskSize.Set {
			e.FieldStart("DiskSize")
			s.DiskSize.Encode(e)
		}
	}
	{
		if s.Memory.Set {
			e.FieldStart("Memory")
			s.Memory.Encode(e)
		}
	}
	{
		e.FieldStart("Nodes")
		e.Int(s.Nodes)
	}
	{
		if s.Port.Set {
			e.FieldStart("Port")
			s.Port.Encode(e)
		}
	}
	{
		if s.Storage.Set {
			e.FieldStart("Storage")
			s.Storage.Encode(e)
		}
	}
	{
		if s.Virtualcore.Set {
			e.FieldStart("Virtualcore")
			s.Virtualcore.Encode(e)
		}
	}
	{
		e.FieldStart("Zone")
		e.Str(s.Zone)
	}
}

var jsonFieldsNameOfNosqlApplianceRemarkNosql = [11]string{
	0:  "PrimaryNodes",
	1:  "DatabaseEngine",
	2:  "DatabaseVersion",
	3:  "DefaultUser",
	4:  "DiskSize",
	5:  "Memory",
	6:  "Nodes",
	7:  "Port",
	8:  "Storage",
	9:  "Virtualcore",
	10: "Zone",
}

// Decode decodes NosqlApplianceRemarkNosql from json.
func (s *NosqlApplianceRemarkNosql) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceRemarkNosql to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "PrimaryNodes":
			if err := func() error {
				s.PrimaryNodes.Reset()
				if err := s.PrimaryNodes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PrimaryNodes\"")
			}
		case "DatabaseEngine":
			if err := func() error {
				s.DatabaseEngine.Reset()
				if err := s.DatabaseEngine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DatabaseEngine\"")
			}
		case "DatabaseVersion":
			if err := func() error {
				s.DatabaseVersion.Reset()
				if err := s.DatabaseVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DatabaseVersion\"")
			}
		case "DefaultUser":
			if err := func() error {
				s.DefaultUser.Reset()
				if err := s.DefaultUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DefaultUser\"")
			}
		case "DiskSize":
			if err := func() error {
				s.DiskSize.Reset()
				if err := s.DiskSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DiskSize\"")
			}
		case "Memory":
			if err := func() error {
				s.Memory.Reset()
				if err := s.Memory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Memory\"")
			}
		case "Nodes":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Nodes = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Nodes\"")
			}
		case "Port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Port\"")
			}
		case "Storage":
			if err := func() error {
				s.Storage.Reset()
				if err := s.Storage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Storage\"")
			}
		case "Virtualcore":
			if err := func() error {
				s.Virtualcore.Reset()
				if err := s.Virtualcore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Virtualcore\"")
			}
		case "Zone":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Zone = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Zone\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlApplianceRemarkNosql")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01000000,
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlApplianceRemarkNosql) {
					name = jsonFieldsNameOfNosqlApplianceRemarkNosql[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlApplianceRemarkNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceRemarkNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceRemarkNosqlDatabaseEngine as json.
func (s NosqlApplianceRemarkNosqlDatabaseEngine) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NosqlApplianceRemarkNosqlDatabaseEngine from json.
func (s *NosqlApplianceRemarkNosqlDatabaseEngine) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceRemarkNosqlDatabaseEngine to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NosqlApplianceRemarkNosqlDatabaseEngine(v) {
	case NosqlApplianceRemarkNosqlDatabaseEngineCassandra:
		*s = NosqlApplianceRemarkNosqlDatabaseEngineCassandra
	default:
		*s = NosqlApplianceRemarkNosqlDatabaseEngine(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlApplianceRemarkNosqlDatabaseEngine) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceRemarkNosqlDatabaseEngine) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceRemarkNosqlDiskSize as json.
func (s NosqlApplianceRemarkNosqlDiskSize) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes NosqlApplianceRemarkNosqlDiskSize from json.
func (s *NosqlApplianceRemarkNosqlDiskSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceRemarkNosqlDiskSize to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = NosqlApplianceRemarkNosqlDiskSize(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlApplianceRemarkNosqlDiskSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceRemarkNosqlDiskSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceRemarkNosqlMemory as json.
func (s NosqlApplianceRemarkNosqlMemory) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes NosqlApplianceRemarkNosqlMemory from json.
func (s *NosqlApplianceRemarkNosqlMemory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceRemarkNosqlMemory to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = NosqlApplianceRemarkNosqlMemory(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlApplianceRemarkNosqlMemory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceRemarkNosqlMemory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlApplianceRemarkNosqlPrimaryNodes) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlApplianceRemarkNosqlPrimaryNodes) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Appliance")
		s.Appliance.Encode(e)
	}
}

var jsonFieldsNameOfNosqlApplianceRemarkNosqlPrimaryNodes = [1]string{
	0: "Appliance",
}

// Decode decodes NosqlApplianceRemarkNosqlPrimaryNodes from json.
func (s *NosqlApplianceRemarkNosqlPrimaryNodes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceRemarkNosqlPrimaryNodes to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Appliance":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Appliance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Appliance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlApplianceRemarkNosqlPrimaryNodes")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlApplianceRemarkNosqlPrimaryNodes) {
					name = jsonFieldsNameOfNosqlApplianceRemarkNosqlPrimaryNodes[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlApplianceRemarkNosqlPrimaryNodes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceRemarkNosqlPrimaryNodes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlApplianceRemarkNosqlPrimaryNodesAppliance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlApplianceRemarkNosqlPrimaryNodesAppliance) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ID")
		e.Str(s.ID)
	}
	{
		e.FieldStart("Zone")
		s.Zone.Encode(e)
	}
}

var jsonFieldsNameOfNosqlApplianceRemarkNosqlPrimaryNodesAppliance = [2]string{
	0: "ID",
	1: "Zone",
}

// Decode decodes NosqlApplianceRemarkNosqlPrimaryNodesAppliance from json.
func (s *NosqlApplianceRemarkNosqlPrimaryNodesAppliance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceRemarkNosqlPrimaryNodesAppliance to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ID":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		case "Zone":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Zone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Zone\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlApplianceRemarkNosqlPrimaryNodesAppliance")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlApplianceRemarkNosqlPrimaryNodesAppliance) {
					name = jsonFieldsNameOfNosqlApplianceRemarkNosqlPrimaryNodesAppliance[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlApplianceRemarkNosqlPrimaryNodesAppliance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceRemarkNosqlPrimaryNodesAppliance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlApplianceRemarkNosqlPrimaryNodesApplianceZone) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlApplianceRemarkNosqlPrimaryNodesApplianceZone) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfNosqlApplianceRemarkNosqlPrimaryNodesApplianceZone = [1]string{
	0: "Name",
}

// Decode decodes NosqlApplianceRemarkNosqlPrimaryNodesApplianceZone from json.
func (s *NosqlApplianceRemarkNosqlPrimaryNodesApplianceZone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceRemarkNosqlPrimaryNodesApplianceZone to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlApplianceRemarkNosqlPrimaryNodesApplianceZone")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlApplianceRemarkNosqlPrimaryNodesApplianceZone) {
					name = jsonFieldsNameOfNosqlApplianceRemarkNosqlPrimaryNodesApplianceZone[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlApplianceRemarkNosqlPrimaryNodesApplianceZone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceRemarkNosqlPrimaryNodesApplianceZone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceRemarkNosqlStorage as json.
func (s NosqlApplianceRemarkNosqlStorage) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NosqlApplianceRemarkNosqlStorage from json.
func (s *NosqlApplianceRemarkNosqlStorage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceRemarkNosqlStorage to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NosqlApplianceRemarkNosqlStorage(v) {
	case NosqlApplianceRemarkNosqlStorageSSD:
		*s = NosqlApplianceRemarkNosqlStorageSSD
	default:
		*s = NosqlApplianceRemarkNosqlStorage(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlApplianceRemarkNosqlStorage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceRemarkNosqlStorage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceRemarkNosqlVirtualcore as json.
func (s NosqlApplianceRemarkNosqlVirtualcore) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes NosqlApplianceRemarkNosqlVirtualcore from json.
func (s *NosqlApplianceRemarkNosqlVirtualcore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceRemarkNosqlVirtualcore to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = NosqlApplianceRemarkNosqlVirtualcore(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlApplianceRemarkNosqlVirtualcore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceRemarkNosqlVirtualcore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlApplianceRemarkServersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlApplianceRemarkServersItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("UserIPAddress")
		json.EncodeIPv4(e, s.UserIPAddress)
	}
}

var jsonFieldsNameOfNosqlApplianceRemarkServersItem = [1]string{
	0: "UserIPAddress",
}

// Decode decodes NosqlApplianceRemarkServersItem from json.
func (s *NosqlApplianceRemarkServersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceRemarkServersItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "UserIPAddress":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeIPv4(d)
				s.UserIPAddress = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UserIPAddress\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlApplianceRemarkServersItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlApplianceRemarkServersItem) {
					name = jsonFieldsNameOfNosqlApplianceRemarkServersItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlApplianceRemarkServersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceRemarkServersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlApplianceRemarkZone) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlApplianceRemarkZone) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("ID")
			s.ID.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlApplianceRemarkZone = [1]string{
	0: "ID",
}

// Decode decodes NosqlApplianceRemarkZone from json.
func (s *NosqlApplianceRemarkZone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlApplianceRemarkZone to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ID":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlApplianceRemarkZone")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlApplianceRemarkZone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlApplianceRemarkZone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlBackup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlBackup) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("backupId")
		json.EncodeUUID(e, s.BackupId)
	}
	{
		e.FieldStart("backupDestination")
		e.Str(s.BackupDestination)
	}
	{
		e.FieldStart("backupAt")
		json.EncodeDateTime(e, s.BackupAt)
	}
	{
		if s.RestoreAt.Set {
			e.FieldStart("restoreAt")
			s.RestoreAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("size")
		e.Int64(s.Size)
	}
	{
		if s.DeleteStatus.Set {
			e.FieldStart("deleteStatus")
			s.DeleteStatus.Encode(e)
		}
	}
	{
		if s.RestoreStatus.Set {
			e.FieldStart("restoreStatus")
			s.RestoreStatus.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlBackup = [7]string{
	0: "backupId",
	1: "backupDestination",
	2: "backupAt",
	3: "restoreAt",
	4: "size",
	5: "deleteStatus",
	6: "restoreStatus",
}

// Decode decodes NosqlBackup from json.
func (s *NosqlBackup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlBackup to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "backupId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.BackupId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backupId\"")
			}
		case "backupDestination":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.BackupDestination = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backupDestination\"")
			}
		case "backupAt":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.BackupAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backupAt\"")
			}
		case "restoreAt":
			if err := func() error {
				s.RestoreAt.Reset()
				if err := s.RestoreAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"restoreAt\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int64()
				s.Size = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "deleteStatus":
			if err := func() error {
				s.DeleteStatus.Reset()
				if err := s.DeleteStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deleteStatus\"")
			}
		case "restoreStatus":
			if err := func() error {
				s.RestoreStatus.Reset()
				if err := s.RestoreStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"restoreStatus\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlBackup")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlBackup) {
					name = jsonFieldsNameOfNosqlBackup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlBackup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlBackup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlBackupResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlBackupResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Nosql.Set {
			e.FieldStart("nosql")
			s.Nosql.Encode(e)
		}
	}
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlBackupResponse = [2]string{
	0: "nosql",
	1: "is_ok",
}

// Decode decodes NosqlBackupResponse from json.
func (s *NosqlBackupResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlBackupResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nosql":
			if err := func() error {
				s.Nosql.Reset()
				if err := s.Nosql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nosql\"")
			}
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlBackupResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlBackupResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlBackupResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlBackupResponseNosql) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlBackupResponseNosql) encodeFields(e *jx.Encoder) {
	{
		if s.Backups != nil {
			e.FieldStart("backups")
			e.ArrStart()
			for _, elem := range s.Backups {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNosqlBackupResponseNosql = [1]string{
	0: "backups",
}

// Decode decodes NosqlBackupResponseNosql from json.
func (s *NosqlBackupResponseNosql) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlBackupResponseNosql to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "backups":
			if err := func() error {
				s.Backups = make([]NosqlBackup, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NosqlBackup
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Backups = append(s.Backups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backups\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlBackupResponseNosql")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlBackupResponseNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlBackupResponseNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Appliance")
		s.Appliance.Encode(e)
	}
}

var jsonFieldsNameOfNosqlCreateRequest = [1]string{
	0: "Appliance",
}

// Decode decodes NosqlCreateRequest from json.
func (s *NosqlCreateRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Appliance":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Appliance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Appliance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlCreateRequest) {
					name = jsonFieldsNameOfNosqlCreateRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateRequestAppliance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateRequestAppliance) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Class")
		e.Str(s.Class)
	}
	{
		e.FieldStart("Name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("Description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Tags.Set {
			e.FieldStart("Tags")
			s.Tags.Encode(e)
		}
	}
	{
		e.FieldStart("ServiceClass")
		s.ServiceClass.Encode(e)
	}
	{
		e.FieldStart("Plan")
		s.Plan.Encode(e)
	}
	{
		if s.Disk.Set {
			e.FieldStart("Disk")
			s.Disk.Encode(e)
		}
	}
	{
		if s.Settings.Set {
			e.FieldStart("Settings")
			s.Settings.Encode(e)
		}
	}
	{
		e.FieldStart("Remark")
		s.Remark.Encode(e)
	}
	{
		e.FieldStart("UserInterfaces")
		e.ArrStart()
		for _, elem := range s.UserInterfaces {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfNosqlCreateRequestAppliance = [10]string{
	0: "Class",
	1: "Name",
	2: "Description",
	3: "Tags",
	4: "ServiceClass",
	5: "Plan",
	6: "Disk",
	7: "Settings",
	8: "Remark",
	9: "UserInterfaces",
}

// Decode decodes NosqlCreateRequestAppliance from json.
func (s *NosqlCreateRequestAppliance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateRequestAppliance to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Class":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Class = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Class\"")
			}
		case "Name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Name\"")
			}
		case "Description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Description\"")
			}
		case "Tags":
			if err := func() error {
				s.Tags.Reset()
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Tags\"")
			}
		case "ServiceClass":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.ServiceClass.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ServiceClass\"")
			}
		case "Plan":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Plan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Plan\"")
			}
		case "Disk":
			if err := func() error {
				s.Disk.Reset()
				if err := s.Disk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Disk\"")
			}
		case "Settings":
			if err := func() error {
				s.Settings.Reset()
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Settings\"")
			}
		case "Remark":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Remark.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Remark\"")
			}
		case "UserInterfaces":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				s.UserInterfaces = make([]NosqlCreateRequestApplianceUserInterfacesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NosqlCreateRequestApplianceUserInterfacesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.UserInterfaces = append(s.UserInterfaces, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UserInterfaces\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateRequestAppliance")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00110011,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlCreateRequestAppliance) {
					name = jsonFieldsNameOfNosqlCreateRequestAppliance[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateRequestAppliance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateRequestAppliance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateRequestApplianceDisk) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateRequestApplianceDisk) encodeFields(e *jx.Encoder) {
	{
		if s.EncryptionKey.Set {
			e.FieldStart("EncryptionKey")
			s.EncryptionKey.Encode(e)
		}
	}
	{
		if s.EncryptionAlgorithm.Set {
			e.FieldStart("EncryptionAlgorithm")
			s.EncryptionAlgorithm.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlCreateRequestApplianceDisk = [2]string{
	0: "EncryptionKey",
	1: "EncryptionAlgorithm",
}

// Decode decodes NosqlCreateRequestApplianceDisk from json.
func (s *NosqlCreateRequestApplianceDisk) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateRequestApplianceDisk to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "EncryptionKey":
			if err := func() error {
				s.EncryptionKey.Reset()
				if err := s.EncryptionKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"EncryptionKey\"")
			}
		case "EncryptionAlgorithm":
			if err := func() error {
				s.EncryptionAlgorithm.Reset()
				if err := s.EncryptionAlgorithm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"EncryptionAlgorithm\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateRequestApplianceDisk")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateRequestApplianceDisk) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateRequestApplianceDisk) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateRequestApplianceDiskEncryptionKey) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateRequestApplianceDiskEncryptionKey) encodeFields(e *jx.Encoder) {
	{
		if s.KMSKeyID.Set {
			e.FieldStart("KMSKeyID")
			s.KMSKeyID.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlCreateRequestApplianceDiskEncryptionKey = [1]string{
	0: "KMSKeyID",
}

// Decode decodes NosqlCreateRequestApplianceDiskEncryptionKey from json.
func (s *NosqlCreateRequestApplianceDiskEncryptionKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateRequestApplianceDiskEncryptionKey to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "KMSKeyID":
			if err := func() error {
				s.KMSKeyID.Reset()
				if err := s.KMSKeyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"KMSKeyID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateRequestApplianceDiskEncryptionKey")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateRequestApplianceDiskEncryptionKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateRequestApplianceDiskEncryptionKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateRequestApplianceSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateRequestApplianceSettings) encodeFields(e *jx.Encoder) {
	{
		if s.Backup.Set {
			e.FieldStart("Backup")
			s.Backup.Encode(e)
		}
	}
	{
		if s.SourceNetwork != nil {
			e.FieldStart("SourceNetwork")
			e.ArrStart()
			for _, elem := range s.SourceNetwork {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReserveIPAddress.Set {
			e.FieldStart("ReserveIPAddress")
			s.ReserveIPAddress.Encode(e)
		}
	}
	{
		if s.Repair.Set {
			e.FieldStart("Repair")
			s.Repair.Encode(e)
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("Password")
			s.Password.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlCreateRequestApplianceSettings = [5]string{
	0: "Backup",
	1: "SourceNetwork",
	2: "ReserveIPAddress",
	3: "Repair",
	4: "Password",
}

// Decode decodes NosqlCreateRequestApplianceSettings from json.
func (s *NosqlCreateRequestApplianceSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateRequestApplianceSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Backup":
			if err := func() error {
				s.Backup.Reset()
				if err := s.Backup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Backup\"")
			}
		case "SourceNetwork":
			if err := func() error {
				s.SourceNetwork = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SourceNetwork = append(s.SourceNetwork, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SourceNetwork\"")
			}
		case "ReserveIPAddress":
			if err := func() error {
				s.ReserveIPAddress.Reset()
				if err := s.ReserveIPAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ReserveIPAddress\"")
			}
		case "Repair":
			if err := func() error {
				s.Repair.Reset()
				if err := s.Repair.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Repair\"")
			}
		case "Password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateRequestApplianceSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateRequestApplianceSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateRequestApplianceSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateRequestApplianceSettingsBackup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateRequestApplianceSettingsBackup) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Connect")
		e.Str(s.Connect)
	}
	{
		if s.DayOfWeek.Set {
			e.FieldStart("DayOfWeek")
			s.DayOfWeek.Encode(e)
		}
	}
	{
		if s.Time.Set {
			e.FieldStart("Time")
			s.Time.Encode(e)
		}
	}
	{
		if s.Rotate.Set {
			e.FieldStart("Rotate")
			s.Rotate.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlCreateRequestApplianceSettingsBackup = [4]string{
	0: "Connect",
	1: "DayOfWeek",
	2: "Time",
	3: "Rotate",
}

// Decode decodes NosqlCreateRequestApplianceSettingsBackup from json.
func (s *NosqlCreateRequestApplianceSettingsBackup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateRequestApplianceSettingsBackup to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Connect":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Connect = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Connect\"")
			}
		case "DayOfWeek":
			if err := func() error {
				s.DayOfWeek.Reset()
				if err := s.DayOfWeek.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DayOfWeek\"")
			}
		case "Time":
			if err := func() error {
				s.Time.Reset()
				if err := s.Time.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Time\"")
			}
		case "Rotate":
			if err := func() error {
				s.Rotate.Reset()
				if err := s.Rotate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Rotate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateRequestApplianceSettingsBackup")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlCreateRequestApplianceSettingsBackup) {
					name = jsonFieldsNameOfNosqlCreateRequestApplianceSettingsBackup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateRequestApplianceSettingsBackup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateRequestApplianceSettingsBackup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem as json.
func (s NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem from json.
func (s *NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem(v) {
	case NosqlCreateRequestApplianceSettingsBackupDayOfWeekItemSun:
		*s = NosqlCreateRequestApplianceSettingsBackupDayOfWeekItemSun
	case NosqlCreateRequestApplianceSettingsBackupDayOfWeekItemMon:
		*s = NosqlCreateRequestApplianceSettingsBackupDayOfWeekItemMon
	case NosqlCreateRequestApplianceSettingsBackupDayOfWeekItemTue:
		*s = NosqlCreateRequestApplianceSettingsBackupDayOfWeekItemTue
	case NosqlCreateRequestApplianceSettingsBackupDayOfWeekItemWed:
		*s = NosqlCreateRequestApplianceSettingsBackupDayOfWeekItemWed
	case NosqlCreateRequestApplianceSettingsBackupDayOfWeekItemThu:
		*s = NosqlCreateRequestApplianceSettingsBackupDayOfWeekItemThu
	case NosqlCreateRequestApplianceSettingsBackupDayOfWeekItemFri:
		*s = NosqlCreateRequestApplianceSettingsBackupDayOfWeekItemFri
	case NosqlCreateRequestApplianceSettingsBackupDayOfWeekItemSat:
		*s = NosqlCreateRequestApplianceSettingsBackupDayOfWeekItemSat
	default:
		*s = NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateRequestApplianceSettingsRepair) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateRequestApplianceSettingsRepair) encodeFields(e *jx.Encoder) {
	{
		if s.Incremental.Set {
			e.FieldStart("Incremental")
			s.Incremental.Encode(e)
		}
	}
	{
		if s.Full.Set {
			e.FieldStart("Full")
			s.Full.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlCreateRequestApplianceSettingsRepair = [2]string{
	0: "Incremental",
	1: "Full",
}

// Decode decodes NosqlCreateRequestApplianceSettingsRepair from json.
func (s *NosqlCreateRequestApplianceSettingsRepair) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateRequestApplianceSettingsRepair to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Incremental":
			if err := func() error {
				s.Incremental.Reset()
				if err := s.Incremental.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Incremental\"")
			}
		case "Full":
			if err := func() error {
				s.Full.Reset()
				if err := s.Full.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Full\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateRequestApplianceSettingsRepair")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateRequestApplianceSettingsRepair) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateRequestApplianceSettingsRepair) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateRequestApplianceSettingsRepairFull) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateRequestApplianceSettingsRepairFull) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Interval")
		s.Interval.Encode(e)
	}
	{
		e.FieldStart("DayOfWeek")
		s.DayOfWeek.Encode(e)
	}
	{
		e.FieldStart("Time")
		e.Str(s.Time)
	}
}

var jsonFieldsNameOfNosqlCreateRequestApplianceSettingsRepairFull = [3]string{
	0: "Interval",
	1: "DayOfWeek",
	2: "Time",
}

// Decode decodes NosqlCreateRequestApplianceSettingsRepairFull from json.
func (s *NosqlCreateRequestApplianceSettingsRepairFull) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateRequestApplianceSettingsRepairFull to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Interval":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Interval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Interval\"")
			}
		case "DayOfWeek":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.DayOfWeek.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DayOfWeek\"")
			}
		case "Time":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Time = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateRequestApplianceSettingsRepairFull")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlCreateRequestApplianceSettingsRepairFull) {
					name = jsonFieldsNameOfNosqlCreateRequestApplianceSettingsRepairFull[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateRequestApplianceSettingsRepairFull) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateRequestApplianceSettingsRepairFull) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlCreateRequestApplianceSettingsRepairFullDayOfWeek as json.
func (s NosqlCreateRequestApplianceSettingsRepairFullDayOfWeek) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NosqlCreateRequestApplianceSettingsRepairFullDayOfWeek from json.
func (s *NosqlCreateRequestApplianceSettingsRepairFullDayOfWeek) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateRequestApplianceSettingsRepairFullDayOfWeek to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NosqlCreateRequestApplianceSettingsRepairFullDayOfWeek(v) {
	case NosqlCreateRequestApplianceSettingsRepairFullDayOfWeekSun:
		*s = NosqlCreateRequestApplianceSettingsRepairFullDayOfWeekSun
	case NosqlCreateRequestApplianceSettingsRepairFullDayOfWeekMon:
		*s = NosqlCreateRequestApplianceSettingsRepairFullDayOfWeekMon
	case NosqlCreateRequestApplianceSettingsRepairFullDayOfWeekTue:
		*s = NosqlCreateRequestApplianceSettingsRepairFullDayOfWeekTue
	case NosqlCreateRequestApplianceSettingsRepairFullDayOfWeekWed:
		*s = NosqlCreateRequestApplianceSettingsRepairFullDayOfWeekWed
	case NosqlCreateRequestApplianceSettingsRepairFullDayOfWeekThu:
		*s = NosqlCreateRequestApplianceSettingsRepairFullDayOfWeekThu
	case NosqlCreateRequestApplianceSettingsRepairFullDayOfWeekFri:
		*s = NosqlCreateRequestApplianceSettingsRepairFullDayOfWeekFri
	case NosqlCreateRequestApplianceSettingsRepairFullDayOfWeekSat:
		*s = NosqlCreateRequestApplianceSettingsRepairFullDayOfWeekSat
	default:
		*s = NosqlCreateRequestApplianceSettingsRepairFullDayOfWeek(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlCreateRequestApplianceSettingsRepairFullDayOfWeek) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateRequestApplianceSettingsRepairFullDayOfWeek) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlCreateRequestApplianceSettingsRepairFullInterval as json.
func (s NosqlCreateRequestApplianceSettingsRepairFullInterval) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes NosqlCreateRequestApplianceSettingsRepairFullInterval from json.
func (s *NosqlCreateRequestApplianceSettingsRepairFullInterval) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateRequestApplianceSettingsRepairFullInterval to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = NosqlCreateRequestApplianceSettingsRepairFullInterval(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlCreateRequestApplianceSettingsRepairFullInterval) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateRequestApplianceSettingsRepairFullInterval) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateRequestApplianceSettingsRepairIncremental) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateRequestApplianceSettingsRepairIncremental) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("DaysOfWeek")
		e.ArrStart()
		for _, elem := range s.DaysOfWeek {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("Time")
		e.Str(s.Time)
	}
}

var jsonFieldsNameOfNosqlCreateRequestApplianceSettingsRepairIncremental = [2]string{
	0: "DaysOfWeek",
	1: "Time",
}

// Decode decodes NosqlCreateRequestApplianceSettingsRepairIncremental from json.
func (s *NosqlCreateRequestApplianceSettingsRepairIncremental) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateRequestApplianceSettingsRepairIncremental to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "DaysOfWeek":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.DaysOfWeek = make([]NosqlCreateRequestApplianceSettingsRepairIncrementalDaysOfWeekItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NosqlCreateRequestApplianceSettingsRepairIncrementalDaysOfWeekItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DaysOfWeek = append(s.DaysOfWeek, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DaysOfWeek\"")
			}
		case "Time":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Time = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateRequestApplianceSettingsRepairIncremental")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlCreateRequestApplianceSettingsRepairIncremental) {
					name = jsonFieldsNameOfNosqlCreateRequestApplianceSettingsRepairIncremental[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateRequestApplianceSettingsRepairIncremental) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateRequestApplianceSettingsRepairIncremental) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlCreateRequestApplianceSettingsRepairIncrementalDaysOfWeekItem as json.
func (s NosqlCreateRequestApplianceSettingsRepairIncrementalDaysOfWeekItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NosqlCreateRequestApplianceSettingsRepairIncrementalDaysOfWeekItem from json.
func (s *NosqlCreateRequestApplianceSettingsRepairIncrementalDaysOfWeekItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateRequestApplianceSettingsRepairIncrementalDaysOfWeekItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NosqlCreateRequestApplianceSettingsRepairIncrementalDaysOfWeekItem(v) {
	case NosqlCreateRequestApplianceSettingsRepairIncrementalDaysOfWeekItemSun:
		*s = NosqlCreateRequestApplianceSettingsRepairIncrementalDaysOfWeekItemSun
	case NosqlCreateRequestApplianceSettingsRepairIncrementalDaysOfWeekItemMon:
		*s = NosqlCreateRequestApplianceSettingsRepairIncrementalDaysOfWeekItemMon
	case NosqlCreateRequestApplianceSettingsRepairIncrementalDaysOfWeekItemTue:
		*s = NosqlCreateRequestApplianceSettingsRepairIncrementalDaysOfWeekItemTue
	case NosqlCreateRequestApplianceSettingsRepairIncrementalDaysOfWeekItemWed:
		*s = NosqlCreateRequestApplianceSettingsRepairIncrementalDaysOfWeekItemWed
	case NosqlCreateRequestApplianceSettingsRepairIncrementalDaysOfWeekItemThu:
		*s = NosqlCreateRequestApplianceSettingsRepairIncrementalDaysOfWeekItemThu
	case NosqlCreateRequestApplianceSettingsRepairIncrementalDaysOfWeekItemFri:
		*s = NosqlCreateRequestApplianceSettingsRepairIncrementalDaysOfWeekItemFri
	case NosqlCreateRequestApplianceSettingsRepairIncrementalDaysOfWeekItemSat:
		*s = NosqlCreateRequestApplianceSettingsRepairIncrementalDaysOfWeekItemSat
	default:
		*s = NosqlCreateRequestApplianceSettingsRepairIncrementalDaysOfWeekItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlCreateRequestApplianceSettingsRepairIncrementalDaysOfWeekItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateRequestApplianceSettingsRepairIncrementalDaysOfWeekItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateRequestApplianceUserInterfacesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateRequestApplianceUserInterfacesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Switch")
		s.Switch.Encode(e)
	}
	{
		e.FieldStart("UserIPAddress1")
		json.EncodeIPv4(e, s.UserIPAddress1)
	}
	{
		if s.UserIPAddress2.Set {
			e.FieldStart("UserIPAddress2")
			s.UserIPAddress2.Encode(e)
		}
	}
	{
		if s.UserIPAddress3.Set {
			e.FieldStart("UserIPAddress3")
			s.UserIPAddress3.Encode(e)
		}
	}
	{
		if s.UserSubnet.Set {
			e.FieldStart("UserSubnet")
			s.UserSubnet.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlCreateRequestApplianceUserInterfacesItem = [5]string{
	0: "Switch",
	1: "UserIPAddress1",
	2: "UserIPAddress2",
	3: "UserIPAddress3",
	4: "UserSubnet",
}

// Decode decodes NosqlCreateRequestApplianceUserInterfacesItem from json.
func (s *NosqlCreateRequestApplianceUserInterfacesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateRequestApplianceUserInterfacesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Switch":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Switch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Switch\"")
			}
		case "UserIPAddress1":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeIPv4(d)
				s.UserIPAddress1 = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UserIPAddress1\"")
			}
		case "UserIPAddress2":
			if err := func() error {
				s.UserIPAddress2.Reset()
				if err := s.UserIPAddress2.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UserIPAddress2\"")
			}
		case "UserIPAddress3":
			if err := func() error {
				s.UserIPAddress3.Reset()
				if err := s.UserIPAddress3.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UserIPAddress3\"")
			}
		case "UserSubnet":
			if err := func() error {
				s.UserSubnet.Reset()
				if err := s.UserSubnet.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UserSubnet\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateRequestApplianceUserInterfacesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlCreateRequestApplianceUserInterfacesItem) {
					name = jsonFieldsNameOfNosqlCreateRequestApplianceUserInterfacesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateRequestApplianceUserInterfacesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateRequestApplianceUserInterfacesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateRequestApplianceUserInterfacesItemSwitch) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateRequestApplianceUserInterfacesItemSwitch) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ID")
		e.Str(s.ID)
	}
}

var jsonFieldsNameOfNosqlCreateRequestApplianceUserInterfacesItemSwitch = [1]string{
	0: "ID",
}

// Decode decodes NosqlCreateRequestApplianceUserInterfacesItemSwitch from json.
func (s *NosqlCreateRequestApplianceUserInterfacesItemSwitch) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateRequestApplianceUserInterfacesItemSwitch to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ID":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateRequestApplianceUserInterfacesItemSwitch")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlCreateRequestApplianceUserInterfacesItemSwitch) {
					name = jsonFieldsNameOfNosqlCreateRequestApplianceUserInterfacesItemSwitch[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateRequestApplianceUserInterfacesItemSwitch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateRequestApplianceUserInterfacesItemSwitch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateRequestApplianceUserInterfacesItemUserSubnet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateRequestApplianceUserInterfacesItemUserSubnet) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("DefaultRoute")
		e.Str(s.DefaultRoute)
	}
	{
		e.FieldStart("NetworkMaskLen")
		e.Int(s.NetworkMaskLen)
	}
}

var jsonFieldsNameOfNosqlCreateRequestApplianceUserInterfacesItemUserSubnet = [2]string{
	0: "DefaultRoute",
	1: "NetworkMaskLen",
}

// Decode decodes NosqlCreateRequestApplianceUserInterfacesItemUserSubnet from json.
func (s *NosqlCreateRequestApplianceUserInterfacesItemUserSubnet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateRequestApplianceUserInterfacesItemUserSubnet to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "DefaultRoute":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DefaultRoute = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DefaultRoute\"")
			}
		case "NetworkMaskLen":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.NetworkMaskLen = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"NetworkMaskLen\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateRequestApplianceUserInterfacesItemUserSubnet")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlCreateRequestApplianceUserInterfacesItemUserSubnet) {
					name = jsonFieldsNameOfNosqlCreateRequestApplianceUserInterfacesItemUserSubnet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateRequestApplianceUserInterfacesItemUserSubnet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateRequestApplianceUserInterfacesItemUserSubnet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Appliance")
		s.Appliance.Encode(e)
	}
	{
		if s.Class.Set {
			e.FieldStart("Class")
			s.Class.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("Name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("Description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Plan.Set {
			e.FieldStart("Plan")
			s.Plan.Encode(e)
		}
	}
	{
		if s.Settings.Set {
			e.FieldStart("Settings")
			s.Settings.Encode(e)
		}
	}
	{
		if s.Remark.Set {
			e.FieldStart("Remark")
			s.Remark.Encode(e)
		}
	}
	{
		e.FieldStart("ID")
		e.Str(s.ID)
	}
	{
		if s.Account.Set {
			e.FieldStart("Account")
			s.Account.Encode(e)
		}
	}
	{
		if s.Tags.Set {
			e.FieldStart("Tags")
			s.Tags.Encode(e)
		}
	}
	{
		if s.Availability.Set {
			e.FieldStart("Availability")
			s.Availability.Encode(e)
		}
	}
	{
		if s.ServerCount.Set {
			e.FieldStart("ServerCount")
			s.ServerCount.Encode(e)
		}
	}
	{
		if s.HiddenRemark.Set {
			e.FieldStart("HiddenRemark")
			s.HiddenRemark.Encode(e)
		}
	}
	{
		if s.Success.Set {
			e.FieldStart("Success")
			s.Success.Encode(e)
		}
	}
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlCreateResponse = [15]string{
	0:  "Appliance",
	1:  "Class",
	2:  "Name",
	3:  "Description",
	4:  "Plan",
	5:  "Settings",
	6:  "Remark",
	7:  "ID",
	8:  "Account",
	9:  "Tags",
	10: "Availability",
	11: "ServerCount",
	12: "HiddenRemark",
	13: "Success",
	14: "is_ok",
}

// Decode decodes NosqlCreateResponse from json.
func (s *NosqlCreateResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateResponse to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Appliance":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Appliance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Appliance\"")
			}
		case "Class":
			if err := func() error {
				s.Class.Reset()
				if err := s.Class.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Class\"")
			}
		case "Name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Name\"")
			}
		case "Description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Description\"")
			}
		case "Plan":
			if err := func() error {
				s.Plan.Reset()
				if err := s.Plan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Plan\"")
			}
		case "Settings":
			if err := func() error {
				s.Settings.Reset()
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Settings\"")
			}
		case "Remark":
			if err := func() error {
				s.Remark.Reset()
				if err := s.Remark.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Remark\"")
			}
		case "ID":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		case "Account":
			if err := func() error {
				s.Account.Reset()
				if err := s.Account.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Account\"")
			}
		case "Tags":
			if err := func() error {
				s.Tags.Reset()
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Tags\"")
			}
		case "Availability":
			if err := func() error {
				s.Availability.Reset()
				if err := s.Availability.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Availability\"")
			}
		case "ServerCount":
			if err := func() error {
				s.ServerCount.Reset()
				if err := s.ServerCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ServerCount\"")
			}
		case "HiddenRemark":
			if err := func() error {
				s.HiddenRemark.Reset()
				if err := s.HiddenRemark.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"HiddenRemark\"")
			}
		case "Success":
			if err := func() error {
				s.Success.Reset()
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Success\"")
			}
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlCreateResponse) {
					name = jsonFieldsNameOfNosqlCreateResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateResponseAccount) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateResponseAccount) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("ID")
			s.ID.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlCreateResponseAccount = [1]string{
	0: "ID",
}

// Decode decodes NosqlCreateResponseAccount from json.
func (s *NosqlCreateResponseAccount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateResponseAccount to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ID":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateResponseAccount")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateResponseAccount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateResponseAccount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateResponseHiddenRemark) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateResponseHiddenRemark) encodeFields(e *jx.Encoder) {
	{
		if s.PlanSpec.Set {
			e.FieldStart("PlanSpec")
			s.PlanSpec.Encode(e)
		}
	}
	{
		if s.Encrypted.Set {
			e.FieldStart("Encrypted")
			s.Encrypted.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlCreateResponseHiddenRemark = [2]string{
	0: "PlanSpec",
	1: "Encrypted",
}

// Decode decodes NosqlCreateResponseHiddenRemark from json.
func (s *NosqlCreateResponseHiddenRemark) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateResponseHiddenRemark to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "PlanSpec":
			if err := func() error {
				s.PlanSpec.Reset()
				if err := s.PlanSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PlanSpec\"")
			}
		case "Encrypted":
			if err := func() error {
				s.Encrypted.Reset()
				if err := s.Encrypted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Encrypted\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateResponseHiddenRemark")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateResponseHiddenRemark) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateResponseHiddenRemark) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateResponseHiddenRemarkEncrypted) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateResponseHiddenRemarkEncrypted) encodeFields(e *jx.Encoder) {
	{
		if s.Algorithm.Set {
			e.FieldStart("Algorithm")
			s.Algorithm.Encode(e)
		}
	}
	{
		if s.IV.Set {
			e.FieldStart("IV")
			s.IV.Encode(e)
		}
	}
	{
		if s.MD5.Set {
			e.FieldStart("md5")
			s.MD5.Encode(e)
		}
	}
	{
		if s.Associative.Set {
			e.FieldStart("Associative")
			s.Associative.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("Data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlCreateResponseHiddenRemarkEncrypted = [5]string{
	0: "Algorithm",
	1: "IV",
	2: "md5",
	3: "Associative",
	4: "Data",
}

// Decode decodes NosqlCreateResponseHiddenRemarkEncrypted from json.
func (s *NosqlCreateResponseHiddenRemarkEncrypted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateResponseHiddenRemarkEncrypted to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Algorithm":
			if err := func() error {
				s.Algorithm.Reset()
				if err := s.Algorithm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Algorithm\"")
			}
		case "IV":
			if err := func() error {
				s.IV.Reset()
				if err := s.IV.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"IV\"")
			}
		case "md5":
			if err := func() error {
				s.MD5.Reset()
				if err := s.MD5.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"md5\"")
			}
		case "Associative":
			if err := func() error {
				s.Associative.Reset()
				if err := s.Associative.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Associative\"")
			}
		case "Data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateResponseHiddenRemarkEncrypted")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateResponseHiddenRemarkEncrypted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateResponseHiddenRemarkEncrypted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateResponseHiddenRemarkPlanSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateResponseHiddenRemarkPlanSpec) encodeFields(e *jx.Encoder) {
	{
		if s.Note.Set {
			e.FieldStart("Note")
			s.Note.Encode(e)
		}
	}
	{
		if s.ServiceClass.Set {
			e.FieldStart("ServiceClass")
			s.ServiceClass.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlCreateResponseHiddenRemarkPlanSpec = [2]string{
	0: "Note",
	1: "ServiceClass",
}

// Decode decodes NosqlCreateResponseHiddenRemarkPlanSpec from json.
func (s *NosqlCreateResponseHiddenRemarkPlanSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateResponseHiddenRemarkPlanSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Note":
			if err := func() error {
				s.Note.Reset()
				if err := s.Note.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Note\"")
			}
		case "ServiceClass":
			if err := func() error {
				s.ServiceClass.Reset()
				if err := s.ServiceClass.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ServiceClass\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateResponseHiddenRemarkPlanSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateResponseHiddenRemarkPlanSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateResponseHiddenRemarkPlanSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlCreateResponseHiddenRemarkPlanSpecNote) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlCreateResponseHiddenRemarkPlanSpecNote) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("ID")
			s.ID.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlCreateResponseHiddenRemarkPlanSpecNote = [1]string{
	0: "ID",
}

// Decode decodes NosqlCreateResponseHiddenRemarkPlanSpecNote from json.
func (s *NosqlCreateResponseHiddenRemarkPlanSpecNote) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlCreateResponseHiddenRemarkPlanSpecNote to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ID":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlCreateResponseHiddenRemarkPlanSpecNote")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlCreateResponseHiddenRemarkPlanSpecNote) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlCreateResponseHiddenRemarkPlanSpecNote) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlGetParameter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlGetParameter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("settingItemId")
		e.Str(s.SettingItemId)
	}
	{
		e.FieldStart("settingItem")
		e.Str(s.SettingItem)
	}
	{
		if s.DefaultValue.Set {
			e.FieldStart("defaultValue")
			s.DefaultValue.Encode(e)
		}
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.ParameterOptions != nil {
			e.FieldStart("parameterOptions")
			e.ArrStart()
			for _, elem := range s.ParameterOptions {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SettingValue.Set {
			e.FieldStart("settingValue")
			s.SettingValue.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlGetParameter = [6]string{
	0: "settingItemId",
	1: "settingItem",
	2: "defaultValue",
	3: "description",
	4: "parameterOptions",
	5: "settingValue",
}

// Decode decodes NosqlGetParameter from json.
func (s *NosqlGetParameter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlGetParameter to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "settingItemId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SettingItemId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settingItemId\"")
			}
		case "settingItem":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SettingItem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settingItem\"")
			}
		case "defaultValue":
			if err := func() error {
				s.DefaultValue.Reset()
				if err := s.DefaultValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultValue\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "parameterOptions":
			if err := func() error {
				s.ParameterOptions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ParameterOptions = append(s.ParameterOptions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameterOptions\"")
			}
		case "settingValue":
			if err := func() error {
				s.SettingValue.Reset()
				if err := s.SettingValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settingValue\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlGetParameter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlGetParameter) {
					name = jsonFieldsNameOfNosqlGetParameter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlGetParameter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlGetParameter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlGetResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlGetResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Appliance")
		s.Appliance.Encode(e)
	}
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlGetResponse = [2]string{
	0: "Appliance",
	1: "is_ok",
}

// Decode decodes NosqlGetResponse from json.
func (s *NosqlGetResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlGetResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Appliance":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Appliance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Appliance\"")
			}
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlGetResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlGetResponse) {
					name = jsonFieldsNameOfNosqlGetResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlGetResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlGetResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlGetVersionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlGetVersionResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Nosql.Set {
			e.FieldStart("nosql")
			s.Nosql.Encode(e)
		}
	}
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlGetVersionResponse = [2]string{
	0: "nosql",
	1: "is_ok",
}

// Decode decodes NosqlGetVersionResponse from json.
func (s *NosqlGetVersionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlGetVersionResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nosql":
			if err := func() error {
				s.Nosql.Reset()
				if err := s.Nosql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nosql\"")
			}
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlGetVersionResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlGetVersionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlGetVersionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlGetVersionResponseNosql) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlGetVersionResponseNosql) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("DatabaseVersion")
		e.Str(s.DatabaseVersion)
	}
	{
		e.FieldStart("UpgradableVersions")
		e.ArrStart()
		for _, elem := range s.UpgradableVersions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfNosqlGetVersionResponseNosql = [2]string{
	0: "DatabaseVersion",
	1: "UpgradableVersions",
}

// Decode decodes NosqlGetVersionResponseNosql from json.
func (s *NosqlGetVersionResponseNosql) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlGetVersionResponseNosql to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "DatabaseVersion":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DatabaseVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DatabaseVersion\"")
			}
		case "UpgradableVersions":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.UpgradableVersions = make([]NosqlGetVersionResponseNosqlUpgradableVersionsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NosqlGetVersionResponseNosqlUpgradableVersionsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.UpgradableVersions = append(s.UpgradableVersions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UpgradableVersions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlGetVersionResponseNosql")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlGetVersionResponseNosql) {
					name = jsonFieldsNameOfNosqlGetVersionResponseNosql[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlGetVersionResponseNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlGetVersionResponseNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlGetVersionResponseNosqlUpgradableVersionsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlGetVersionResponseNosqlUpgradableVersionsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
}

var jsonFieldsNameOfNosqlGetVersionResponseNosqlUpgradableVersionsItem = [1]string{
	0: "version",
}

// Decode decodes NosqlGetVersionResponseNosqlUpgradableVersionsItem from json.
func (s *NosqlGetVersionResponseNosqlUpgradableVersionsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlGetVersionResponseNosqlUpgradableVersionsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlGetVersionResponseNosqlUpgradableVersionsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlGetVersionResponseNosqlUpgradableVersionsItem) {
					name = jsonFieldsNameOfNosqlGetVersionResponseNosqlUpgradableVersionsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlGetVersionResponseNosqlUpgradableVersionsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlGetVersionResponseNosqlUpgradableVersionsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlIsOkResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlIsOkResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Nosql.Set {
			e.FieldStart("Nosql")
			s.Nosql.Encode(e)
		}
	}
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlIsOkResponse = [2]string{
	0: "Nosql",
	1: "is_ok",
}

// Decode decodes NosqlIsOkResponse from json.
func (s *NosqlIsOkResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlIsOkResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Nosql":
			if err := func() error {
				s.Nosql.Reset()
				if err := s.Nosql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Nosql\"")
			}
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlIsOkResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlIsOkResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlIsOkResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlIsOkResponseNosql) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlIsOkResponseNosql) encodeFields(e *jx.Encoder) {
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlIsOkResponseNosql = [1]string{
	0: "is_ok",
}

// Decode decodes NosqlIsOkResponseNosql from json.
func (s *NosqlIsOkResponseNosql) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlIsOkResponseNosql to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlIsOkResponseNosql")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlIsOkResponseNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlIsOkResponseNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlListResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("From")
		e.Int(s.From)
	}
	{
		e.FieldStart("Count")
		e.Int(s.Count)
	}
	{
		e.FieldStart("Total")
		e.Int(s.Total)
	}
	{
		e.FieldStart("Appliances")
		e.ArrStart()
		for _, elem := range s.Appliances {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlListResponse = [5]string{
	0: "From",
	1: "Count",
	2: "Total",
	3: "Appliances",
	4: "is_ok",
}

// Decode decodes NosqlListResponse from json.
func (s *NosqlListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlListResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "From":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.From = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"From\"")
			}
		case "Count":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Count = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Count\"")
			}
		case "Total":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Total\"")
			}
		case "Appliances":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Appliances = make([]GetNosqlAppliance, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetNosqlAppliance
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Appliances = append(s.Appliances, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Appliances\"")
			}
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlListResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlListResponse) {
					name = jsonFieldsNameOfNosqlListResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlNodeAppliance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlNodeAppliance) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ID")
		e.Str(s.ID)
	}
	{
		e.FieldStart("Availability")
		s.Availability.Encode(e)
	}
	{
		if s.Zone.Set {
			e.FieldStart("Zone")
			s.Zone.Encode(e)
		}
	}
	{
		if s.Nodes != nil {
			e.FieldStart("Nodes")
			e.ArrStart()
			for _, elem := range s.Nodes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNosqlNodeAppliance = [4]string{
	0: "ID",
	1: "Availability",
	2: "Zone",
	3: "Nodes",
}

// Decode decodes NosqlNodeAppliance from json.
func (s *NosqlNodeAppliance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlNodeAppliance to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ID":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		case "Availability":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Availability.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Availability\"")
			}
		case "Zone":
			if err := func() error {
				s.Zone.Reset()
				if err := s.Zone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Zone\"")
			}
		case "Nodes":
			if err := func() error {
				s.Nodes = make([]NosqldbNodeStatus, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NosqldbNodeStatus
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Nodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlNodeAppliance")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlNodeAppliance) {
					name = jsonFieldsNameOfNosqlNodeAppliance[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlNodeAppliance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlNodeAppliance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlNodeApplianceZone) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlNodeApplianceZone) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("Name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlNodeApplianceZone = [1]string{
	0: "Name",
}

// Decode decodes NosqlNodeApplianceZone from json.
func (s *NosqlNodeApplianceZone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlNodeApplianceZone to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlNodeApplianceZone")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlNodeApplianceZone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlNodeApplianceZone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlOkResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlOkResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Nosql.Set {
			e.FieldStart("nosql")
			s.Nosql.Encode(e)
		}
	}
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlOkResponse = [2]string{
	0: "nosql",
	1: "is_ok",
}

// Decode decodes NosqlOkResponse from json.
func (s *NosqlOkResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlOkResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nosql":
			if err := func() error {
				s.Nosql.Reset()
				if err := s.Nosql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nosql\"")
			}
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlOkResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlOkResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlOkResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlOkResponseNosql) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlOkResponseNosql) encodeFields(e *jx.Encoder) {
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlOkResponseNosql = [1]string{
	0: "is_ok",
}

// Decode decodes NosqlOkResponseNosql from json.
func (s *NosqlOkResponseNosql) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlOkResponseNosql to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlOkResponseNosql")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlOkResponseNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlOkResponseNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlPutParameter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlPutParameter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("settingItemId")
		e.Str(s.SettingItemId)
	}
	{
		e.FieldStart("settingValue")
		e.Str(s.SettingValue)
	}
}

var jsonFieldsNameOfNosqlPutParameter = [2]string{
	0: "settingItemId",
	1: "settingValue",
}

// Decode decodes NosqlPutParameter from json.
func (s *NosqlPutParameter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlPutParameter to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "settingItemId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SettingItemId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settingItemId\"")
			}
		case "settingValue":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SettingValue = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settingValue\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlPutParameter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlPutParameter) {
					name = jsonFieldsNameOfNosqlPutParameter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlPutParameter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlPutParameter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlPutVersionRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlPutVersionRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nosql")
		s.Nosql.Encode(e)
	}
}

var jsonFieldsNameOfNosqlPutVersionRequest = [1]string{
	0: "nosql",
}

// Decode decodes NosqlPutVersionRequest from json.
func (s *NosqlPutVersionRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlPutVersionRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nosql":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Nosql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nosql\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlPutVersionRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlPutVersionRequest) {
					name = jsonFieldsNameOfNosqlPutVersionRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlPutVersionRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlPutVersionRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlPutVersionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlPutVersionResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Nosql.Set {
			e.FieldStart("nosql")
			s.Nosql.Encode(e)
		}
	}
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlPutVersionResponse = [2]string{
	0: "nosql",
	1: "is_ok",
}

// Decode decodes NosqlPutVersionResponse from json.
func (s *NosqlPutVersionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlPutVersionResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nosql":
			if err := func() error {
				s.Nosql.Reset()
				if err := s.Nosql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nosql\"")
			}
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlPutVersionResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlPutVersionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlPutVersionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlRemark) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlRemark) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Nosql")
		s.Nosql.Encode(e)
	}
	{
		if s.Servers != nil {
			e.FieldStart("Servers")
			e.ArrStart()
			for _, elem := range s.Servers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNosqlRemark = [2]string{
	0: "Nosql",
	1: "Servers",
}

// Decode decodes NosqlRemark from json.
func (s *NosqlRemark) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlRemark to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Nosql":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Nosql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Nosql\"")
			}
		case "Servers":
			if err := func() error {
				s.Servers = make([]NosqlRemarkServersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NosqlRemarkServersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Servers = append(s.Servers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Servers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlRemark")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlRemark) {
					name = jsonFieldsNameOfNosqlRemark[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlRemark) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlRemark) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlRemarkNosql) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlRemarkNosql) encodeFields(e *jx.Encoder) {
	{
		if s.PrimaryNodes.Set {
			e.FieldStart("PrimaryNodes")
			s.PrimaryNodes.Encode(e)
		}
	}
	{
		if s.DatabaseEngine.Set {
			e.FieldStart("DatabaseEngine")
			s.DatabaseEngine.Encode(e)
		}
	}
	{
		if s.DatabaseVersion.Set {
			e.FieldStart("DatabaseVersion")
			s.DatabaseVersion.Encode(e)
		}
	}
	{
		if s.DefaultUser.Set {
			e.FieldStart("DefaultUser")
			s.DefaultUser.Encode(e)
		}
	}
	{
		if s.DiskSize.Set {
			e.FieldStart("DiskSize")
			s.DiskSize.Encode(e)
		}
	}
	{
		if s.Memory.Set {
			e.FieldStart("Memory")
			s.Memory.Encode(e)
		}
	}
	{
		e.FieldStart("Nodes")
		e.Int(s.Nodes)
	}
	{
		if s.Port.Set {
			e.FieldStart("Port")
			s.Port.Encode(e)
		}
	}
	{
		if s.Storage.Set {
			e.FieldStart("Storage")
			s.Storage.Encode(e)
		}
	}
	{
		if s.Virtualcore.Set {
			e.FieldStart("Virtualcore")
			s.Virtualcore.Encode(e)
		}
	}
	{
		e.FieldStart("Zone")
		e.Str(s.Zone)
	}
}

var jsonFieldsNameOfNosqlRemarkNosql = [11]string{
	0:  "PrimaryNodes",
	1:  "DatabaseEngine",
	2:  "DatabaseVersion",
	3:  "DefaultUser",
	4:  "DiskSize",
	5:  "Memory",
	6:  "Nodes",
	7:  "Port",
	8:  "Storage",
	9:  "Virtualcore",
	10: "Zone",
}

// Decode decodes NosqlRemarkNosql from json.
func (s *NosqlRemarkNosql) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlRemarkNosql to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "PrimaryNodes":
			if err := func() error {
				s.PrimaryNodes.Reset()
				if err := s.PrimaryNodes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PrimaryNodes\"")
			}
		case "DatabaseEngine":
			if err := func() error {
				s.DatabaseEngine.Reset()
				if err := s.DatabaseEngine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DatabaseEngine\"")
			}
		case "DatabaseVersion":
			if err := func() error {
				s.DatabaseVersion.Reset()
				if err := s.DatabaseVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DatabaseVersion\"")
			}
		case "DefaultUser":
			if err := func() error {
				s.DefaultUser.Reset()
				if err := s.DefaultUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DefaultUser\"")
			}
		case "DiskSize":
			if err := func() error {
				s.DiskSize.Reset()
				if err := s.DiskSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DiskSize\"")
			}
		case "Memory":
			if err := func() error {
				s.Memory.Reset()
				if err := s.Memory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Memory\"")
			}
		case "Nodes":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Nodes = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Nodes\"")
			}
		case "Port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Port\"")
			}
		case "Storage":
			if err := func() error {
				s.Storage.Reset()
				if err := s.Storage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Storage\"")
			}
		case "Virtualcore":
			if err := func() error {
				s.Virtualcore.Reset()
				if err := s.Virtualcore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Virtualcore\"")
			}
		case "Zone":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Zone = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Zone\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlRemarkNosql")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01000000,
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlRemarkNosql) {
					name = jsonFieldsNameOfNosqlRemarkNosql[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlRemarkNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlRemarkNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlRemarkNosqlDatabaseEngine as json.
func (s NosqlRemarkNosqlDatabaseEngine) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NosqlRemarkNosqlDatabaseEngine from json.
func (s *NosqlRemarkNosqlDatabaseEngine) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlRemarkNosqlDatabaseEngine to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NosqlRemarkNosqlDatabaseEngine(v) {
	case NosqlRemarkNosqlDatabaseEngineCassandra:
		*s = NosqlRemarkNosqlDatabaseEngineCassandra
	default:
		*s = NosqlRemarkNosqlDatabaseEngine(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlRemarkNosqlDatabaseEngine) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlRemarkNosqlDatabaseEngine) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlRemarkNosqlDiskSize as json.
func (s NosqlRemarkNosqlDiskSize) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes NosqlRemarkNosqlDiskSize from json.
func (s *NosqlRemarkNosqlDiskSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlRemarkNosqlDiskSize to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = NosqlRemarkNosqlDiskSize(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlRemarkNosqlDiskSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlRemarkNosqlDiskSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlRemarkNosqlMemory as json.
func (s NosqlRemarkNosqlMemory) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes NosqlRemarkNosqlMemory from json.
func (s *NosqlRemarkNosqlMemory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlRemarkNosqlMemory to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = NosqlRemarkNosqlMemory(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlRemarkNosqlMemory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlRemarkNosqlMemory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlRemarkNosqlPrimaryNodes) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlRemarkNosqlPrimaryNodes) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Appliance")
		s.Appliance.Encode(e)
	}
}

var jsonFieldsNameOfNosqlRemarkNosqlPrimaryNodes = [1]string{
	0: "Appliance",
}

// Decode decodes NosqlRemarkNosqlPrimaryNodes from json.
func (s *NosqlRemarkNosqlPrimaryNodes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlRemarkNosqlPrimaryNodes to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Appliance":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Appliance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Appliance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlRemarkNosqlPrimaryNodes")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlRemarkNosqlPrimaryNodes) {
					name = jsonFieldsNameOfNosqlRemarkNosqlPrimaryNodes[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlRemarkNosqlPrimaryNodes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlRemarkNosqlPrimaryNodes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlRemarkNosqlPrimaryNodesAppliance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlRemarkNosqlPrimaryNodesAppliance) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ID")
		e.Str(s.ID)
	}
	{
		e.FieldStart("Zone")
		s.Zone.Encode(e)
	}
}

var jsonFieldsNameOfNosqlRemarkNosqlPrimaryNodesAppliance = [2]string{
	0: "ID",
	1: "Zone",
}

// Decode decodes NosqlRemarkNosqlPrimaryNodesAppliance from json.
func (s *NosqlRemarkNosqlPrimaryNodesAppliance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlRemarkNosqlPrimaryNodesAppliance to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ID":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		case "Zone":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Zone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Zone\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlRemarkNosqlPrimaryNodesAppliance")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlRemarkNosqlPrimaryNodesAppliance) {
					name = jsonFieldsNameOfNosqlRemarkNosqlPrimaryNodesAppliance[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlRemarkNosqlPrimaryNodesAppliance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlRemarkNosqlPrimaryNodesAppliance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlRemarkNosqlPrimaryNodesApplianceZone) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlRemarkNosqlPrimaryNodesApplianceZone) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfNosqlRemarkNosqlPrimaryNodesApplianceZone = [1]string{
	0: "Name",
}

// Decode decodes NosqlRemarkNosqlPrimaryNodesApplianceZone from json.
func (s *NosqlRemarkNosqlPrimaryNodesApplianceZone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlRemarkNosqlPrimaryNodesApplianceZone to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlRemarkNosqlPrimaryNodesApplianceZone")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlRemarkNosqlPrimaryNodesApplianceZone) {
					name = jsonFieldsNameOfNosqlRemarkNosqlPrimaryNodesApplianceZone[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlRemarkNosqlPrimaryNodesApplianceZone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlRemarkNosqlPrimaryNodesApplianceZone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlRemarkNosqlStorage as json.
func (s NosqlRemarkNosqlStorage) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NosqlRemarkNosqlStorage from json.
func (s *NosqlRemarkNosqlStorage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlRemarkNosqlStorage to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NosqlRemarkNosqlStorage(v) {
	case NosqlRemarkNosqlStorageSSD:
		*s = NosqlRemarkNosqlStorageSSD
	default:
		*s = NosqlRemarkNosqlStorage(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlRemarkNosqlStorage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlRemarkNosqlStorage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlRemarkNosqlVirtualcore as json.
func (s NosqlRemarkNosqlVirtualcore) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes NosqlRemarkNosqlVirtualcore from json.
func (s *NosqlRemarkNosqlVirtualcore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlRemarkNosqlVirtualcore to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = NosqlRemarkNosqlVirtualcore(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlRemarkNosqlVirtualcore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlRemarkNosqlVirtualcore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlRemarkServersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlRemarkServersItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("UserIPAddress")
		json.EncodeIPv4(e, s.UserIPAddress)
	}
}

var jsonFieldsNameOfNosqlRemarkServersItem = [1]string{
	0: "UserIPAddress",
}

// Decode decodes NosqlRemarkServersItem from json.
func (s *NosqlRemarkServersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlRemarkServersItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "UserIPAddress":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeIPv4(d)
				s.UserIPAddress = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UserIPAddress\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlRemarkServersItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlRemarkServersItem) {
					name = jsonFieldsNameOfNosqlRemarkServersItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlRemarkServersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlRemarkServersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlRepairRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlRepairRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Nosql.Set {
			e.FieldStart("nosql")
			s.Nosql.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlRepairRequest = [1]string{
	0: "nosql",
}

// Decode decodes NosqlRepairRequest from json.
func (s *NosqlRepairRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlRepairRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nosql":
			if err := func() error {
				s.Nosql.Reset()
				if err := s.Nosql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nosql\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlRepairRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlRepairRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlRepairRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlRepairRequestNosql) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlRepairRequestNosql) encodeFields(e *jx.Encoder) {
	{
		if s.RepairType.Set {
			e.FieldStart("repairType")
			s.RepairType.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlRepairRequestNosql = [1]string{
	0: "repairType",
}

// Decode decodes NosqlRepairRequestNosql from json.
func (s *NosqlRepairRequestNosql) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlRepairRequestNosql to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "repairType":
			if err := func() error {
				s.RepairType.Reset()
				if err := s.RepairType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repairType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlRepairRequestNosql")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlRepairRequestNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlRepairRequestNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlRepairRequestNosqlRepairType as json.
func (s NosqlRepairRequestNosqlRepairType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NosqlRepairRequestNosqlRepairType from json.
func (s *NosqlRepairRequestNosqlRepairType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlRepairRequestNosqlRepairType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NosqlRepairRequestNosqlRepairType(v) {
	case NosqlRepairRequestNosqlRepairTypeIncremental:
		*s = NosqlRepairRequestNosqlRepairTypeIncremental
	case NosqlRepairRequestNosqlRepairTypeFull:
		*s = NosqlRepairRequestNosqlRepairTypeFull
	default:
		*s = NosqlRepairRequestNosqlRepairType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlRepairRequestNosqlRepairType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlRepairRequestNosqlRepairType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlSettings) encodeFields(e *jx.Encoder) {
	{
		if s.Backup.Set {
			e.FieldStart("Backup")
			s.Backup.Encode(e)
		}
	}
	{
		if s.SourceNetwork != nil {
			e.FieldStart("SourceNetwork")
			e.ArrStart()
			for _, elem := range s.SourceNetwork {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReserveIPAddress.Set {
			e.FieldStart("ReserveIPAddress")
			s.ReserveIPAddress.Encode(e)
		}
	}
	{
		if s.Repair.Set {
			e.FieldStart("Repair")
			s.Repair.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlSettings = [4]string{
	0: "Backup",
	1: "SourceNetwork",
	2: "ReserveIPAddress",
	3: "Repair",
}

// Decode decodes NosqlSettings from json.
func (s *NosqlSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Backup":
			if err := func() error {
				s.Backup.Reset()
				if err := s.Backup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Backup\"")
			}
		case "SourceNetwork":
			if err := func() error {
				s.SourceNetwork = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SourceNetwork = append(s.SourceNetwork, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SourceNetwork\"")
			}
		case "ReserveIPAddress":
			if err := func() error {
				s.ReserveIPAddress.Reset()
				if err := s.ReserveIPAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ReserveIPAddress\"")
			}
		case "Repair":
			if err := func() error {
				s.Repair.Reset()
				if err := s.Repair.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Repair\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlSettingsBackup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlSettingsBackup) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Connect")
		e.Str(s.Connect)
	}
	{
		if s.DayOfWeek.Set {
			e.FieldStart("DayOfWeek")
			s.DayOfWeek.Encode(e)
		}
	}
	{
		if s.Time.Set {
			e.FieldStart("Time")
			s.Time.Encode(e)
		}
	}
	{
		if s.Rotate.Set {
			e.FieldStart("Rotate")
			s.Rotate.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlSettingsBackup = [4]string{
	0: "Connect",
	1: "DayOfWeek",
	2: "Time",
	3: "Rotate",
}

// Decode decodes NosqlSettingsBackup from json.
func (s *NosqlSettingsBackup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlSettingsBackup to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Connect":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Connect = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Connect\"")
			}
		case "DayOfWeek":
			if err := func() error {
				s.DayOfWeek.Reset()
				if err := s.DayOfWeek.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DayOfWeek\"")
			}
		case "Time":
			if err := func() error {
				s.Time.Reset()
				if err := s.Time.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Time\"")
			}
		case "Rotate":
			if err := func() error {
				s.Rotate.Reset()
				if err := s.Rotate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Rotate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlSettingsBackup")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlSettingsBackup) {
					name = jsonFieldsNameOfNosqlSettingsBackup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlSettingsBackup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlSettingsBackup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlSettingsBackupDayOfWeekItem as json.
func (s NosqlSettingsBackupDayOfWeekItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NosqlSettingsBackupDayOfWeekItem from json.
func (s *NosqlSettingsBackupDayOfWeekItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlSettingsBackupDayOfWeekItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NosqlSettingsBackupDayOfWeekItem(v) {
	case NosqlSettingsBackupDayOfWeekItemSun:
		*s = NosqlSettingsBackupDayOfWeekItemSun
	case NosqlSettingsBackupDayOfWeekItemMon:
		*s = NosqlSettingsBackupDayOfWeekItemMon
	case NosqlSettingsBackupDayOfWeekItemTue:
		*s = NosqlSettingsBackupDayOfWeekItemTue
	case NosqlSettingsBackupDayOfWeekItemWed:
		*s = NosqlSettingsBackupDayOfWeekItemWed
	case NosqlSettingsBackupDayOfWeekItemThu:
		*s = NosqlSettingsBackupDayOfWeekItemThu
	case NosqlSettingsBackupDayOfWeekItemFri:
		*s = NosqlSettingsBackupDayOfWeekItemFri
	case NosqlSettingsBackupDayOfWeekItemSat:
		*s = NosqlSettingsBackupDayOfWeekItemSat
	default:
		*s = NosqlSettingsBackupDayOfWeekItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlSettingsBackupDayOfWeekItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlSettingsBackupDayOfWeekItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlSettingsRepair) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlSettingsRepair) encodeFields(e *jx.Encoder) {
	{
		if s.Incremental.Set {
			e.FieldStart("Incremental")
			s.Incremental.Encode(e)
		}
	}
	{
		if s.Full.Set {
			e.FieldStart("Full")
			s.Full.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlSettingsRepair = [2]string{
	0: "Incremental",
	1: "Full",
}

// Decode decodes NosqlSettingsRepair from json.
func (s *NosqlSettingsRepair) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlSettingsRepair to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Incremental":
			if err := func() error {
				s.Incremental.Reset()
				if err := s.Incremental.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Incremental\"")
			}
		case "Full":
			if err := func() error {
				s.Full.Reset()
				if err := s.Full.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Full\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlSettingsRepair")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlSettingsRepair) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlSettingsRepair) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlSettingsRepairFull) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlSettingsRepairFull) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Interval")
		s.Interval.Encode(e)
	}
	{
		e.FieldStart("DayOfWeek")
		s.DayOfWeek.Encode(e)
	}
	{
		e.FieldStart("Time")
		e.Str(s.Time)
	}
}

var jsonFieldsNameOfNosqlSettingsRepairFull = [3]string{
	0: "Interval",
	1: "DayOfWeek",
	2: "Time",
}

// Decode decodes NosqlSettingsRepairFull from json.
func (s *NosqlSettingsRepairFull) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlSettingsRepairFull to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Interval":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Interval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Interval\"")
			}
		case "DayOfWeek":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.DayOfWeek.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DayOfWeek\"")
			}
		case "Time":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Time = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlSettingsRepairFull")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlSettingsRepairFull) {
					name = jsonFieldsNameOfNosqlSettingsRepairFull[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlSettingsRepairFull) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlSettingsRepairFull) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlSettingsRepairFullDayOfWeek as json.
func (s NosqlSettingsRepairFullDayOfWeek) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NosqlSettingsRepairFullDayOfWeek from json.
func (s *NosqlSettingsRepairFullDayOfWeek) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlSettingsRepairFullDayOfWeek to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NosqlSettingsRepairFullDayOfWeek(v) {
	case NosqlSettingsRepairFullDayOfWeekSun:
		*s = NosqlSettingsRepairFullDayOfWeekSun
	case NosqlSettingsRepairFullDayOfWeekMon:
		*s = NosqlSettingsRepairFullDayOfWeekMon
	case NosqlSettingsRepairFullDayOfWeekTue:
		*s = NosqlSettingsRepairFullDayOfWeekTue
	case NosqlSettingsRepairFullDayOfWeekWed:
		*s = NosqlSettingsRepairFullDayOfWeekWed
	case NosqlSettingsRepairFullDayOfWeekThu:
		*s = NosqlSettingsRepairFullDayOfWeekThu
	case NosqlSettingsRepairFullDayOfWeekFri:
		*s = NosqlSettingsRepairFullDayOfWeekFri
	case NosqlSettingsRepairFullDayOfWeekSat:
		*s = NosqlSettingsRepairFullDayOfWeekSat
	default:
		*s = NosqlSettingsRepairFullDayOfWeek(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlSettingsRepairFullDayOfWeek) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlSettingsRepairFullDayOfWeek) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlSettingsRepairFullInterval as json.
func (s NosqlSettingsRepairFullInterval) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes NosqlSettingsRepairFullInterval from json.
func (s *NosqlSettingsRepairFullInterval) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlSettingsRepairFullInterval to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = NosqlSettingsRepairFullInterval(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlSettingsRepairFullInterval) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlSettingsRepairFullInterval) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlSettingsRepairIncremental) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlSettingsRepairIncremental) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("DaysOfWeek")
		e.ArrStart()
		for _, elem := range s.DaysOfWeek {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("Time")
		e.Str(s.Time)
	}
}

var jsonFieldsNameOfNosqlSettingsRepairIncremental = [2]string{
	0: "DaysOfWeek",
	1: "Time",
}

// Decode decodes NosqlSettingsRepairIncremental from json.
func (s *NosqlSettingsRepairIncremental) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlSettingsRepairIncremental to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "DaysOfWeek":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.DaysOfWeek = make([]NosqlSettingsRepairIncrementalDaysOfWeekItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NosqlSettingsRepairIncrementalDaysOfWeekItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DaysOfWeek = append(s.DaysOfWeek, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DaysOfWeek\"")
			}
		case "Time":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Time = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlSettingsRepairIncremental")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlSettingsRepairIncremental) {
					name = jsonFieldsNameOfNosqlSettingsRepairIncremental[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlSettingsRepairIncremental) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlSettingsRepairIncremental) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlSettingsRepairIncrementalDaysOfWeekItem as json.
func (s NosqlSettingsRepairIncrementalDaysOfWeekItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NosqlSettingsRepairIncrementalDaysOfWeekItem from json.
func (s *NosqlSettingsRepairIncrementalDaysOfWeekItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlSettingsRepairIncrementalDaysOfWeekItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NosqlSettingsRepairIncrementalDaysOfWeekItem(v) {
	case NosqlSettingsRepairIncrementalDaysOfWeekItemSun:
		*s = NosqlSettingsRepairIncrementalDaysOfWeekItemSun
	case NosqlSettingsRepairIncrementalDaysOfWeekItemMon:
		*s = NosqlSettingsRepairIncrementalDaysOfWeekItemMon
	case NosqlSettingsRepairIncrementalDaysOfWeekItemTue:
		*s = NosqlSettingsRepairIncrementalDaysOfWeekItemTue
	case NosqlSettingsRepairIncrementalDaysOfWeekItemWed:
		*s = NosqlSettingsRepairIncrementalDaysOfWeekItemWed
	case NosqlSettingsRepairIncrementalDaysOfWeekItemThu:
		*s = NosqlSettingsRepairIncrementalDaysOfWeekItemThu
	case NosqlSettingsRepairIncrementalDaysOfWeekItemFri:
		*s = NosqlSettingsRepairIncrementalDaysOfWeekItemFri
	case NosqlSettingsRepairIncrementalDaysOfWeekItemSat:
		*s = NosqlSettingsRepairIncrementalDaysOfWeekItemSat
	default:
		*s = NosqlSettingsRepairIncrementalDaysOfWeekItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlSettingsRepairIncrementalDaysOfWeekItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlSettingsRepairIncrementalDaysOfWeekItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlStatusResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlStatusResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Appliance.Set {
			e.FieldStart("Appliance")
			s.Appliance.Encode(e)
		}
	}
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlStatusResponse = [2]string{
	0: "Appliance",
	1: "is_ok",
}

// Decode decodes NosqlStatusResponse from json.
func (s *NosqlStatusResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlStatusResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Appliance":
			if err := func() error {
				s.Appliance.Reset()
				if err := s.Appliance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Appliance\"")
			}
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlStatusResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlStatusResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlStatusResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlStatusResponseAppliance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlStatusResponseAppliance) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("ID")
			s.ID.Encode(e)
		}
	}
	{
		if s.SettingsResponse.Set {
			e.FieldStart("SettingsResponse")
			s.SettingsResponse.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlStatusResponseAppliance = [2]string{
	0: "ID",
	1: "SettingsResponse",
}

// Decode decodes NosqlStatusResponseAppliance from json.
func (s *NosqlStatusResponseAppliance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlStatusResponseAppliance to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ID":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		case "SettingsResponse":
			if err := func() error {
				s.SettingsResponse.Reset()
				if err := s.SettingsResponse.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SettingsResponse\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlStatusResponseAppliance")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlStatusResponseAppliance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlStatusResponseAppliance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlStatusResponseApplianceSettingsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlStatusResponseApplianceSettingsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Nosql.Set {
			e.FieldStart("Nosql")
			s.Nosql.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlStatusResponseApplianceSettingsResponse = [1]string{
	0: "Nosql",
}

// Decode decodes NosqlStatusResponseApplianceSettingsResponse from json.
func (s *NosqlStatusResponseApplianceSettingsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlStatusResponseApplianceSettingsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Nosql":
			if err := func() error {
				s.Nosql.Reset()
				if err := s.Nosql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Nosql\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlStatusResponseApplianceSettingsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlStatusResponseApplianceSettingsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlStatusResponseApplianceSettingsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlStatusResponseApplianceSettingsResponseNosql) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlStatusResponseApplianceSettingsResponseNosql) encodeFields(e *jx.Encoder) {
	{
		if s.DatabaseVersion.Set {
			e.FieldStart("DatabaseVersion")
			s.DatabaseVersion.Encode(e)
		}
	}
	{
		if s.UpgradeVersion.Set {
			e.FieldStart("UpgradeVersion")
			s.UpgradeVersion.Encode(e)
		}
	}
	{
		if s.Jobs != nil {
			e.FieldStart("Jobs")
			e.ArrStart()
			for _, elem := range s.Jobs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PrimaryNodes.Set {
			e.FieldStart("PrimaryNodes")
			s.PrimaryNodes.Encode(e)
		}
	}
	{
		if s.AddNodes != nil {
			e.FieldStart("AddNodes")
			e.ArrStart()
			for _, elem := range s.AddNodes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNosqlStatusResponseApplianceSettingsResponseNosql = [5]string{
	0: "DatabaseVersion",
	1: "UpgradeVersion",
	2: "Jobs",
	3: "PrimaryNodes",
	4: "AddNodes",
}

// Decode decodes NosqlStatusResponseApplianceSettingsResponseNosql from json.
func (s *NosqlStatusResponseApplianceSettingsResponseNosql) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlStatusResponseApplianceSettingsResponseNosql to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "DatabaseVersion":
			if err := func() error {
				s.DatabaseVersion.Reset()
				if err := s.DatabaseVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DatabaseVersion\"")
			}
		case "UpgradeVersion":
			if err := func() error {
				s.UpgradeVersion.Reset()
				if err := s.UpgradeVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UpgradeVersion\"")
			}
		case "Jobs":
			if err := func() error {
				s.Jobs = make([]NosqlStatusResponseApplianceSettingsResponseNosqlJobsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NosqlStatusResponseApplianceSettingsResponseNosqlJobsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Jobs = append(s.Jobs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Jobs\"")
			}
		case "PrimaryNodes":
			if err := func() error {
				s.PrimaryNodes.Reset()
				if err := s.PrimaryNodes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PrimaryNodes\"")
			}
		case "AddNodes":
			if err := func() error {
				s.AddNodes = make([]NosqlStatusResponseApplianceSettingsResponseNosqlAddNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NosqlStatusResponseApplianceSettingsResponseNosqlAddNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AddNodes = append(s.AddNodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"AddNodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlStatusResponseApplianceSettingsResponseNosql")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlStatusResponseApplianceSettingsResponseNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlStatusResponseApplianceSettingsResponseNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlStatusResponseApplianceSettingsResponseNosqlAddNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlStatusResponseApplianceSettingsResponseNosqlAddNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Appliance")
		s.Appliance.Encode(e)
	}
}

var jsonFieldsNameOfNosqlStatusResponseApplianceSettingsResponseNosqlAddNodesItem = [1]string{
	0: "Appliance",
}

// Decode decodes NosqlStatusResponseApplianceSettingsResponseNosqlAddNodesItem from json.
func (s *NosqlStatusResponseApplianceSettingsResponseNosqlAddNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlStatusResponseApplianceSettingsResponseNosqlAddNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Appliance":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Appliance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Appliance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlStatusResponseApplianceSettingsResponseNosqlAddNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlStatusResponseApplianceSettingsResponseNosqlAddNodesItem) {
					name = jsonFieldsNameOfNosqlStatusResponseApplianceSettingsResponseNosqlAddNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlStatusResponseApplianceSettingsResponseNosqlAddNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlStatusResponseApplianceSettingsResponseNosqlAddNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlStatusResponseApplianceSettingsResponseNosqlJobsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlStatusResponseApplianceSettingsResponseNosqlJobsItem) encodeFields(e *jx.Encoder) {
	{
		if s.JobType.Set {
			e.FieldStart("JobType")
			s.JobType.Encode(e)
		}
	}
	{
		if s.JobStatus.Set {
			e.FieldStart("JobStatus")
			s.JobStatus.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlStatusResponseApplianceSettingsResponseNosqlJobsItem = [2]string{
	0: "JobType",
	1: "JobStatus",
}

// Decode decodes NosqlStatusResponseApplianceSettingsResponseNosqlJobsItem from json.
func (s *NosqlStatusResponseApplianceSettingsResponseNosqlJobsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlStatusResponseApplianceSettingsResponseNosqlJobsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "JobType":
			if err := func() error {
				s.JobType.Reset()
				if err := s.JobType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"JobType\"")
			}
		case "JobStatus":
			if err := func() error {
				s.JobStatus.Reset()
				if err := s.JobStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"JobStatus\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlStatusResponseApplianceSettingsResponseNosqlJobsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlStatusResponseApplianceSettingsResponseNosqlJobsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlStatusResponseApplianceSettingsResponseNosqlJobsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlStatusResponseApplianceSettingsResponseNosqlPrimaryNodes) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlStatusResponseApplianceSettingsResponseNosqlPrimaryNodes) encodeFields(e *jx.Encoder) {
	{
		if s.Appliance.Set {
			e.FieldStart("Appliance")
			s.Appliance.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlStatusResponseApplianceSettingsResponseNosqlPrimaryNodes = [1]string{
	0: "Appliance",
}

// Decode decodes NosqlStatusResponseApplianceSettingsResponseNosqlPrimaryNodes from json.
func (s *NosqlStatusResponseApplianceSettingsResponseNosqlPrimaryNodes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlStatusResponseApplianceSettingsResponseNosqlPrimaryNodes to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Appliance":
			if err := func() error {
				s.Appliance.Reset()
				if err := s.Appliance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Appliance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlStatusResponseApplianceSettingsResponseNosqlPrimaryNodes")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlStatusResponseApplianceSettingsResponseNosqlPrimaryNodes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlStatusResponseApplianceSettingsResponseNosqlPrimaryNodes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlSuccessResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlSuccessResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Appliance.Set {
			e.FieldStart("Appliance")
			s.Appliance.Encode(e)
		}
	}
	{
		if s.Success.Set {
			e.FieldStart("Success")
			s.Success.Encode(e)
		}
	}
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlSuccessResponse = [3]string{
	0: "Appliance",
	1: "Success",
	2: "is_ok",
}

// Decode decodes NosqlSuccessResponse from json.
func (s *NosqlSuccessResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlSuccessResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Appliance":
			if err := func() error {
				s.Appliance.Reset()
				if err := s.Appliance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Appliance\"")
			}
		case "Success":
			if err := func() error {
				s.Success.Reset()
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Success\"")
			}
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlSuccessResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlSuccessResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlSuccessResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlUpdateRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlUpdateRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Appliance")
		s.Appliance.Encode(e)
	}
}

var jsonFieldsNameOfNosqlUpdateRequest = [1]string{
	0: "Appliance",
}

// Decode decodes NosqlUpdateRequest from json.
func (s *NosqlUpdateRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlUpdateRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Appliance":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Appliance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Appliance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlUpdateRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlUpdateRequest) {
					name = jsonFieldsNameOfNosqlUpdateRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlUpdateRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlUpdateRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlUpdateRequestAppliance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlUpdateRequestAppliance) encodeFields(e *jx.Encoder) {
	{
		if s.Class.Set {
			e.FieldStart("Class")
			s.Class.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("Name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("Description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Tags.Set {
			e.FieldStart("Tags")
			s.Tags.Encode(e)
		}
	}
	{
		e.FieldStart("ID")
		e.Str(s.ID)
	}
	{
		e.FieldStart("Settings")
		s.Settings.Encode(e)
	}
}

var jsonFieldsNameOfNosqlUpdateRequestAppliance = [6]string{
	0: "Class",
	1: "Name",
	2: "Description",
	3: "Tags",
	4: "ID",
	5: "Settings",
}

// Decode decodes NosqlUpdateRequestAppliance from json.
func (s *NosqlUpdateRequestAppliance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlUpdateRequestAppliance to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Class":
			if err := func() error {
				s.Class.Reset()
				if err := s.Class.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Class\"")
			}
		case "Name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Name\"")
			}
		case "Description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Description\"")
			}
		case "Tags":
			if err := func() error {
				s.Tags.Reset()
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Tags\"")
			}
		case "ID":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		case "Settings":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlUpdateRequestAppliance")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlUpdateRequestAppliance) {
					name = jsonFieldsNameOfNosqlUpdateRequestAppliance[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlUpdateRequestAppliance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlUpdateRequestAppliance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlUpdateRequestApplianceSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlUpdateRequestApplianceSettings) encodeFields(e *jx.Encoder) {
	{
		if s.Backup.Set {
			e.FieldStart("Backup")
			s.Backup.Encode(e)
		}
	}
	{
		if s.SourceNetwork != nil {
			e.FieldStart("SourceNetwork")
			e.ArrStart()
			for _, elem := range s.SourceNetwork {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReserveIPAddress.Set {
			e.FieldStart("ReserveIPAddress")
			s.ReserveIPAddress.Encode(e)
		}
	}
	{
		if s.Repair.Set {
			e.FieldStart("Repair")
			s.Repair.Encode(e)
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("Password")
			s.Password.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlUpdateRequestApplianceSettings = [5]string{
	0: "Backup",
	1: "SourceNetwork",
	2: "ReserveIPAddress",
	3: "Repair",
	4: "Password",
}

// Decode decodes NosqlUpdateRequestApplianceSettings from json.
func (s *NosqlUpdateRequestApplianceSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlUpdateRequestApplianceSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Backup":
			if err := func() error {
				s.Backup.Reset()
				if err := s.Backup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Backup\"")
			}
		case "SourceNetwork":
			if err := func() error {
				s.SourceNetwork = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SourceNetwork = append(s.SourceNetwork, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SourceNetwork\"")
			}
		case "ReserveIPAddress":
			if err := func() error {
				s.ReserveIPAddress.Reset()
				if err := s.ReserveIPAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ReserveIPAddress\"")
			}
		case "Repair":
			if err := func() error {
				s.Repair.Reset()
				if err := s.Repair.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Repair\"")
			}
		case "Password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlUpdateRequestApplianceSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlUpdateRequestApplianceSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlUpdateRequestApplianceSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlUpdateRequestApplianceSettingsBackup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlUpdateRequestApplianceSettingsBackup) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Connect")
		e.Str(s.Connect)
	}
	{
		if s.DayOfWeek.Set {
			e.FieldStart("DayOfWeek")
			s.DayOfWeek.Encode(e)
		}
	}
	{
		if s.Time.Set {
			e.FieldStart("Time")
			s.Time.Encode(e)
		}
	}
	{
		if s.Rotate.Set {
			e.FieldStart("Rotate")
			s.Rotate.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlUpdateRequestApplianceSettingsBackup = [4]string{
	0: "Connect",
	1: "DayOfWeek",
	2: "Time",
	3: "Rotate",
}

// Decode decodes NosqlUpdateRequestApplianceSettingsBackup from json.
func (s *NosqlUpdateRequestApplianceSettingsBackup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlUpdateRequestApplianceSettingsBackup to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Connect":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Connect = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Connect\"")
			}
		case "DayOfWeek":
			if err := func() error {
				s.DayOfWeek.Reset()
				if err := s.DayOfWeek.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DayOfWeek\"")
			}
		case "Time":
			if err := func() error {
				s.Time.Reset()
				if err := s.Time.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Time\"")
			}
		case "Rotate":
			if err := func() error {
				s.Rotate.Reset()
				if err := s.Rotate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Rotate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlUpdateRequestApplianceSettingsBackup")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlUpdateRequestApplianceSettingsBackup) {
					name = jsonFieldsNameOfNosqlUpdateRequestApplianceSettingsBackup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlUpdateRequestApplianceSettingsBackup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlUpdateRequestApplianceSettingsBackup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem as json.
func (s NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem from json.
func (s *NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem(v) {
	case NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemSun:
		*s = NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemSun
	case NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemMon:
		*s = NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemMon
	case NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemTue:
		*s = NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemTue
	case NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemWed:
		*s = NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemWed
	case NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemThu:
		*s = NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemThu
	case NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemFri:
		*s = NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemFri
	case NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemSat:
		*s = NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemSat
	default:
		*s = NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlUpdateRequestApplianceSettingsRepair) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlUpdateRequestApplianceSettingsRepair) encodeFields(e *jx.Encoder) {
	{
		if s.Incremental.Set {
			e.FieldStart("Incremental")
			s.Incremental.Encode(e)
		}
	}
	{
		if s.Full.Set {
			e.FieldStart("Full")
			s.Full.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlUpdateRequestApplianceSettingsRepair = [2]string{
	0: "Incremental",
	1: "Full",
}

// Decode decodes NosqlUpdateRequestApplianceSettingsRepair from json.
func (s *NosqlUpdateRequestApplianceSettingsRepair) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlUpdateRequestApplianceSettingsRepair to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Incremental":
			if err := func() error {
				s.Incremental.Reset()
				if err := s.Incremental.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Incremental\"")
			}
		case "Full":
			if err := func() error {
				s.Full.Reset()
				if err := s.Full.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Full\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlUpdateRequestApplianceSettingsRepair")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlUpdateRequestApplianceSettingsRepair) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlUpdateRequestApplianceSettingsRepair) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlUpdateRequestApplianceSettingsRepairFull) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlUpdateRequestApplianceSettingsRepairFull) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Interval")
		s.Interval.Encode(e)
	}
	{
		e.FieldStart("DayOfWeek")
		s.DayOfWeek.Encode(e)
	}
	{
		e.FieldStart("Time")
		e.Str(s.Time)
	}
}

var jsonFieldsNameOfNosqlUpdateRequestApplianceSettingsRepairFull = [3]string{
	0: "Interval",
	1: "DayOfWeek",
	2: "Time",
}

// Decode decodes NosqlUpdateRequestApplianceSettingsRepairFull from json.
func (s *NosqlUpdateRequestApplianceSettingsRepairFull) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlUpdateRequestApplianceSettingsRepairFull to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Interval":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Interval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Interval\"")
			}
		case "DayOfWeek":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.DayOfWeek.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DayOfWeek\"")
			}
		case "Time":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Time = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlUpdateRequestApplianceSettingsRepairFull")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlUpdateRequestApplianceSettingsRepairFull) {
					name = jsonFieldsNameOfNosqlUpdateRequestApplianceSettingsRepairFull[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlUpdateRequestApplianceSettingsRepairFull) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlUpdateRequestApplianceSettingsRepairFull) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlUpdateRequestApplianceSettingsRepairFullDayOfWeek as json.
func (s NosqlUpdateRequestApplianceSettingsRepairFullDayOfWeek) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NosqlUpdateRequestApplianceSettingsRepairFullDayOfWeek from json.
func (s *NosqlUpdateRequestApplianceSettingsRepairFullDayOfWeek) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlUpdateRequestApplianceSettingsRepairFullDayOfWeek to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NosqlUpdateRequestApplianceSettingsRepairFullDayOfWeek(v) {
	case NosqlUpdateRequestApplianceSettingsRepairFullDayOfWeekSun:
		*s = NosqlUpdateRequestApplianceSettingsRepairFullDayOfWeekSun
	case NosqlUpdateRequestApplianceSettingsRepairFullDayOfWeekMon:
		*s = NosqlUpdateRequestApplianceSettingsRepairFullDayOfWeekMon
	case NosqlUpdateRequestApplianceSettingsRepairFullDayOfWeekTue:
		*s = NosqlUpdateRequestApplianceSettingsRepairFullDayOfWeekTue
	case NosqlUpdateRequestApplianceSettingsRepairFullDayOfWeekWed:
		*s = NosqlUpdateRequestApplianceSettingsRepairFullDayOfWeekWed
	case NosqlUpdateRequestApplianceSettingsRepairFullDayOfWeekThu:
		*s = NosqlUpdateRequestApplianceSettingsRepairFullDayOfWeekThu
	case NosqlUpdateRequestApplianceSettingsRepairFullDayOfWeekFri:
		*s = NosqlUpdateRequestApplianceSettingsRepairFullDayOfWeekFri
	case NosqlUpdateRequestApplianceSettingsRepairFullDayOfWeekSat:
		*s = NosqlUpdateRequestApplianceSettingsRepairFullDayOfWeekSat
	default:
		*s = NosqlUpdateRequestApplianceSettingsRepairFullDayOfWeek(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlUpdateRequestApplianceSettingsRepairFullDayOfWeek) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlUpdateRequestApplianceSettingsRepairFullDayOfWeek) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlUpdateRequestApplianceSettingsRepairFullInterval as json.
func (s NosqlUpdateRequestApplianceSettingsRepairFullInterval) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes NosqlUpdateRequestApplianceSettingsRepairFullInterval from json.
func (s *NosqlUpdateRequestApplianceSettingsRepairFullInterval) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlUpdateRequestApplianceSettingsRepairFullInterval to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = NosqlUpdateRequestApplianceSettingsRepairFullInterval(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlUpdateRequestApplianceSettingsRepairFullInterval) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlUpdateRequestApplianceSettingsRepairFullInterval) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlUpdateRequestApplianceSettingsRepairIncremental) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlUpdateRequestApplianceSettingsRepairIncremental) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("DaysOfWeek")
		e.ArrStart()
		for _, elem := range s.DaysOfWeek {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("Time")
		e.Str(s.Time)
	}
}

var jsonFieldsNameOfNosqlUpdateRequestApplianceSettingsRepairIncremental = [2]string{
	0: "DaysOfWeek",
	1: "Time",
}

// Decode decodes NosqlUpdateRequestApplianceSettingsRepairIncremental from json.
func (s *NosqlUpdateRequestApplianceSettingsRepairIncremental) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlUpdateRequestApplianceSettingsRepairIncremental to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "DaysOfWeek":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.DaysOfWeek = make([]NosqlUpdateRequestApplianceSettingsRepairIncrementalDaysOfWeekItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NosqlUpdateRequestApplianceSettingsRepairIncrementalDaysOfWeekItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DaysOfWeek = append(s.DaysOfWeek, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DaysOfWeek\"")
			}
		case "Time":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Time = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlUpdateRequestApplianceSettingsRepairIncremental")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNosqlUpdateRequestApplianceSettingsRepairIncremental) {
					name = jsonFieldsNameOfNosqlUpdateRequestApplianceSettingsRepairIncremental[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlUpdateRequestApplianceSettingsRepairIncremental) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlUpdateRequestApplianceSettingsRepairIncremental) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlUpdateRequestApplianceSettingsRepairIncrementalDaysOfWeekItem as json.
func (s NosqlUpdateRequestApplianceSettingsRepairIncrementalDaysOfWeekItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NosqlUpdateRequestApplianceSettingsRepairIncrementalDaysOfWeekItem from json.
func (s *NosqlUpdateRequestApplianceSettingsRepairIncrementalDaysOfWeekItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlUpdateRequestApplianceSettingsRepairIncrementalDaysOfWeekItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NosqlUpdateRequestApplianceSettingsRepairIncrementalDaysOfWeekItem(v) {
	case NosqlUpdateRequestApplianceSettingsRepairIncrementalDaysOfWeekItemSun:
		*s = NosqlUpdateRequestApplianceSettingsRepairIncrementalDaysOfWeekItemSun
	case NosqlUpdateRequestApplianceSettingsRepairIncrementalDaysOfWeekItemMon:
		*s = NosqlUpdateRequestApplianceSettingsRepairIncrementalDaysOfWeekItemMon
	case NosqlUpdateRequestApplianceSettingsRepairIncrementalDaysOfWeekItemTue:
		*s = NosqlUpdateRequestApplianceSettingsRepairIncrementalDaysOfWeekItemTue
	case NosqlUpdateRequestApplianceSettingsRepairIncrementalDaysOfWeekItemWed:
		*s = NosqlUpdateRequestApplianceSettingsRepairIncrementalDaysOfWeekItemWed
	case NosqlUpdateRequestApplianceSettingsRepairIncrementalDaysOfWeekItemThu:
		*s = NosqlUpdateRequestApplianceSettingsRepairIncrementalDaysOfWeekItemThu
	case NosqlUpdateRequestApplianceSettingsRepairIncrementalDaysOfWeekItemFri:
		*s = NosqlUpdateRequestApplianceSettingsRepairIncrementalDaysOfWeekItemFri
	case NosqlUpdateRequestApplianceSettingsRepairIncrementalDaysOfWeekItemSat:
		*s = NosqlUpdateRequestApplianceSettingsRepairIncrementalDaysOfWeekItemSat
	default:
		*s = NosqlUpdateRequestApplianceSettingsRepairIncrementalDaysOfWeekItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqlUpdateRequestApplianceSettingsRepairIncrementalDaysOfWeekItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlUpdateRequestApplianceSettingsRepairIncrementalDaysOfWeekItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqlVersion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqlVersion) encodeFields(e *jx.Encoder) {
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqlVersion = [1]string{
	0: "version",
}

// Decode decodes NosqlVersion from json.
func (s *NosqlVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqlVersion to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqlVersion")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqlVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqlVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NosqldbNodeStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NosqldbNodeStatus) encodeFields(e *jx.Encoder) {
	{
		if s.Index.Set {
			e.FieldStart("Index")
			s.Index.Encode(e)
		}
	}
	{
		if s.UserIPAddress.Set {
			e.FieldStart("UserIPAddress")
			s.UserIPAddress.Encode(e)
		}
	}
	{
		if s.NodeType.Set {
			e.FieldStart("NodeType")
			s.NodeType.Encode(e)
		}
	}
}

var jsonFieldsNameOfNosqldbNodeStatus = [3]string{
	0: "Index",
	1: "UserIPAddress",
	2: "NodeType",
}

// Decode decodes NosqldbNodeStatus from json.
func (s *NosqldbNodeStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqldbNodeStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Index":
			if err := func() error {
				s.Index.Reset()
				if err := s.Index.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Index\"")
			}
		case "UserIPAddress":
			if err := func() error {
				s.UserIPAddress.Reset()
				if err := s.UserIPAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UserIPAddress\"")
			}
		case "NodeType":
			if err := func() error {
				s.NodeType.Reset()
				if err := s.NodeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"NodeType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NosqldbNodeStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NosqldbNodeStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqldbNodeStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqldbNodeStatusNodeType as json.
func (s NosqldbNodeStatusNodeType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NosqldbNodeStatusNodeType from json.
func (s *NosqldbNodeStatusNodeType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NosqldbNodeStatusNodeType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NosqldbNodeStatusNodeType(v) {
	case NosqldbNodeStatusNodeType0:
		*s = NosqldbNodeStatusNodeType0
	case NosqldbNodeStatusNodeType1:
		*s = NosqldbNodeStatusNodeType1
	case NosqldbNodeStatusNodeType2:
		*s = NosqldbNodeStatusNodeType2
	default:
		*s = NosqldbNodeStatusNodeType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NosqldbNodeStatusNodeType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NosqldbNodeStatusNodeType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NotFoundResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NotFoundResponse) encodeFields(e *jx.Encoder) {
	{
		if s.IsFatal.Set {
			e.FieldStart("is_fatal")
			s.IsFatal.Encode(e)
		}
	}
	{
		if s.Serial.Set {
			e.FieldStart("serial")
			s.Serial.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("error_code")
			s.ErrorCode.Encode(e)
		}
	}
	{
		if s.ErrorMsg.Set {
			e.FieldStart("error_msg")
			s.ErrorMsg.Encode(e)
		}
	}
}

var jsonFieldsNameOfNotFoundResponse = [5]string{
	0: "is_fatal",
	1: "serial",
	2: "status",
	3: "error_code",
	4: "error_msg",
}

// Decode decodes NotFoundResponse from json.
func (s *NotFoundResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotFoundResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "is_fatal":
			if err := func() error {
				s.IsFatal.Reset()
				if err := s.IsFatal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_fatal\"")
			}
		case "serial":
			if err := func() error {
				s.Serial.Reset()
				if err := s.Serial.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serial\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "error_code":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_code\"")
			}
		case "error_msg":
			if err := func() error {
				s.ErrorMsg.Reset()
				if err := s.ErrorMsg.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_msg\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotFoundResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NotFoundResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotFoundResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Availability as json.
func (o OptAvailability) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes Availability from json.
func (o *OptAvailability) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAvailability to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAvailability) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAvailability) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes GetNosqlApplianceInterfacesItemSwitch as json.
func (o OptGetNosqlApplianceInterfacesItemSwitch) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetNosqlApplianceInterfacesItemSwitch from json.
func (o *OptGetNosqlApplianceInterfacesItemSwitch) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetNosqlApplianceInterfacesItemSwitch to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetNosqlApplianceInterfacesItemSwitch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetNosqlApplianceInterfacesItemSwitch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlApplianceInterfacesItemSwitchSubnetInternet as json.
func (o OptGetNosqlApplianceInterfacesItemSwitchSubnetInternet) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetNosqlApplianceInterfacesItemSwitchSubnetInternet from json.
func (o *OptGetNosqlApplianceInterfacesItemSwitchSubnetInternet) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetNosqlApplianceInterfacesItemSwitchSubnetInternet to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetNosqlApplianceInterfacesItemSwitchSubnetInternet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetNosqlApplianceInterfacesItemSwitchSubnetInternet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlApplianceRemark as json.
func (o OptGetNosqlApplianceRemark) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetNosqlApplianceRemark from json.
func (o *OptGetNosqlApplianceRemark) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetNosqlApplianceRemark to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetNosqlApplianceRemark) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetNosqlApplianceRemark) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlApplianceRemarkNosql as json.
func (o OptGetNosqlApplianceRemarkNosql) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetNosqlApplianceRemarkNosql from json.
func (o *OptGetNosqlApplianceRemarkNosql) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetNosqlApplianceRemarkNosql to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetNosqlApplianceRemarkNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetNosqlApplianceRemarkNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlApplianceRemarkNosqlDatabaseEngine as json.
func (o OptGetNosqlApplianceRemarkNosqlDatabaseEngine) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetNosqlApplianceRemarkNosqlDatabaseEngine from json.
func (o *OptGetNosqlApplianceRemarkNosqlDatabaseEngine) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetNosqlApplianceRemarkNosqlDatabaseEngine to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetNosqlApplianceRemarkNosqlDatabaseEngine) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetNosqlApplianceRemarkNosqlDatabaseEngine) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlApplianceRemarkNosqlDiskSize as json.
func (o OptGetNosqlApplianceRemarkNosqlDiskSize) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes GetNosqlApplianceRemarkNosqlDiskSize from json.
func (o *OptGetNosqlApplianceRemarkNosqlDiskSize) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetNosqlApplianceRemarkNosqlDiskSize to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetNosqlApplianceRemarkNosqlDiskSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetNosqlApplianceRemarkNosqlDiskSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlApplianceRemarkNosqlMemory as json.
func (o OptGetNosqlApplianceRemarkNosqlMemory) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes GetNosqlApplianceRemarkNosqlMemory from json.
func (o *OptGetNosqlApplianceRemarkNosqlMemory) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetNosqlApplianceRemarkNosqlMemory to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetNosqlApplianceRemarkNosqlMemory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetNosqlApplianceRemarkNosqlMemory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlApplianceRemarkNosqlPrimaryNodes as json.
func (o OptGetNosqlApplianceRemarkNosqlPrimaryNodes) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetNosqlApplianceRemarkNosqlPrimaryNodes from json.
func (o *OptGetNosqlApplianceRemarkNosqlPrimaryNodes) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetNosqlApplianceRemarkNosqlPrimaryNodes to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetNosqlApplianceRemarkNosqlPrimaryNodes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetNosqlApplianceRemarkNosqlPrimaryNodes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlApplianceRemarkNosqlPrimaryNodesAppliance as json.
func (o OptGetNosqlApplianceRemarkNosqlPrimaryNodesAppliance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetNosqlApplianceRemarkNosqlPrimaryNodesAppliance from json.
func (o *OptGetNosqlApplianceRemarkNosqlPrimaryNodesAppliance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetNosqlApplianceRemarkNosqlPrimaryNodesAppliance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetNosqlApplianceRemarkNosqlPrimaryNodesAppliance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetNosqlApplianceRemarkNosqlPrimaryNodesAppliance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlApplianceRemarkNosqlPrimaryNodesApplianceZone as json.
func (o OptGetNosqlApplianceRemarkNosqlPrimaryNodesApplianceZone) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetNosqlApplianceRemarkNosqlPrimaryNodesApplianceZone from json.
func (o *OptGetNosqlApplianceRemarkNosqlPrimaryNodesApplianceZone) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetNosqlApplianceRemarkNosqlPrimaryNodesApplianceZone to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetNosqlApplianceRemarkNosqlPrimaryNodesApplianceZone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetNosqlApplianceRemarkNosqlPrimaryNodesApplianceZone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlApplianceRemarkNosqlStorage as json.
func (o OptGetNosqlApplianceRemarkNosqlStorage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetNosqlApplianceRemarkNosqlStorage from json.
func (o *OptGetNosqlApplianceRemarkNosqlStorage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetNosqlApplianceRemarkNosqlStorage to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetNosqlApplianceRemarkNosqlStorage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetNosqlApplianceRemarkNosqlStorage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlApplianceRemarkNosqlVirtualcore as json.
func (o OptGetNosqlApplianceRemarkNosqlVirtualcore) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes GetNosqlApplianceRemarkNosqlVirtualcore from json.
func (o *OptGetNosqlApplianceRemarkNosqlVirtualcore) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetNosqlApplianceRemarkNosqlVirtualcore to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetNosqlApplianceRemarkNosqlVirtualcore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetNosqlApplianceRemarkNosqlVirtualcore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlApplianceRemarkZone as json.
func (o OptGetNosqlApplianceRemarkZone) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetNosqlApplianceRemarkZone from json.
func (o *OptGetNosqlApplianceRemarkZone) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetNosqlApplianceRemarkZone to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetNosqlApplianceRemarkZone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetNosqlApplianceRemarkZone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlSettings as json.
func (o OptGetNosqlSettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetNosqlSettings from json.
func (o *OptGetNosqlSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetNosqlSettings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetNosqlSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetNosqlSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlSettingsRepairFull as json.
func (o OptGetNosqlSettingsRepairFull) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetNosqlSettingsRepairFull from json.
func (o *OptGetNosqlSettingsRepairFull) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetNosqlSettingsRepairFull to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetNosqlSettingsRepairFull) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetNosqlSettingsRepairFull) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlSettingsRepairFullDayOfWeek as json.
func (o OptGetNosqlSettingsRepairFullDayOfWeek) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetNosqlSettingsRepairFullDayOfWeek from json.
func (o *OptGetNosqlSettingsRepairFullDayOfWeek) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetNosqlSettingsRepairFullDayOfWeek to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetNosqlSettingsRepairFullDayOfWeek) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetNosqlSettingsRepairFullDayOfWeek) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlSettingsRepairFullInterval as json.
func (o OptGetNosqlSettingsRepairFullInterval) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes GetNosqlSettingsRepairFullInterval from json.
func (o *OptGetNosqlSettingsRepairFullInterval) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetNosqlSettingsRepairFullInterval to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetNosqlSettingsRepairFullInterval) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetNosqlSettingsRepairFullInterval) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlSettingsRepairIncremental as json.
func (o OptGetNosqlSettingsRepairIncremental) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetNosqlSettingsRepairIncremental from json.
func (o *OptGetNosqlSettingsRepairIncremental) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetNosqlSettingsRepairIncremental to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetNosqlSettingsRepairIncremental) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetNosqlSettingsRepairIncremental) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParameterResponseNosql as json.
func (o OptGetParameterResponseNosql) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetParameterResponseNosql from json.
func (o *OptGetParameterResponseNosql) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetParameterResponseNosql to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetParameterResponseNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetParameterResponseNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPlan as json.
func (o OptGetPlan) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetPlan from json.
func (o *OptGetPlan) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetPlan to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetPlan) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetPlan) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetServiceClass as json.
func (o OptGetServiceClass) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetServiceClass from json.
func (o *OptGetServiceClass) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetServiceClass to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetServiceClass) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetServiceClass) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes netip.Addr as json.
func (o OptIPv4) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeIPv4(e, o.Value)
}

// Decode decodes netip.Addr from json.
func (o *OptIPv4) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIPv4 to nil")
	}
	o.Set = true
	v, err := json.DecodeIPv4(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIPv4) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIPv4) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Instance as json.
func (o OptInstance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Instance from json.
func (o *OptInstance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInstance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInstance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInstance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IsOk as json.
func (o OptIsOk) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IsOk from json.
func (o *OptIsOk) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIsOk to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIsOk) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIsOk) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptNilDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptNilDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilDateTime to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v time.Time
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes GetNosqlApplianceDisk as json.
func (o OptNilGetNosqlApplianceDisk) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetNosqlApplianceDisk from json.
func (o *OptNilGetNosqlApplianceDisk) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilGetNosqlApplianceDisk to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetNosqlApplianceDisk
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilGetNosqlApplianceDisk) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilGetNosqlApplianceDisk) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlApplianceDiskEncryptionKey as json.
func (o OptNilGetNosqlApplianceDiskEncryptionKey) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetNosqlApplianceDiskEncryptionKey from json.
func (o *OptNilGetNosqlApplianceDiskEncryptionKey) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilGetNosqlApplianceDiskEncryptionKey to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetNosqlApplianceDiskEncryptionKey
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilGetNosqlApplianceDiskEncryptionKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilGetNosqlApplianceDiskEncryptionKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlApplianceInterfacesItemSwitchSubnet as json.
func (o OptNilGetNosqlApplianceInterfacesItemSwitchSubnet) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetNosqlApplianceInterfacesItemSwitchSubnet from json.
func (o *OptNilGetNosqlApplianceInterfacesItemSwitchSubnet) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilGetNosqlApplianceInterfacesItemSwitchSubnet to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetNosqlApplianceInterfacesItemSwitchSubnet
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilGetNosqlApplianceInterfacesItemSwitchSubnet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilGetNosqlApplianceInterfacesItemSwitchSubnet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlApplianceInterfacesItemSwitchUserSubnet as json.
func (o OptNilGetNosqlApplianceInterfacesItemSwitchUserSubnet) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetNosqlApplianceInterfacesItemSwitchUserSubnet from json.
func (o *OptNilGetNosqlApplianceInterfacesItemSwitchUserSubnet) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilGetNosqlApplianceInterfacesItemSwitchUserSubnet to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetNosqlApplianceInterfacesItemSwitchUserSubnet
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilGetNosqlApplianceInterfacesItemSwitchUserSubnet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilGetNosqlApplianceInterfacesItemSwitchUserSubnet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlSettingsBackup as json.
func (o OptNilGetNosqlSettingsBackup) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetNosqlSettingsBackup from json.
func (o *OptNilGetNosqlSettingsBackup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilGetNosqlSettingsBackup to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetNosqlSettingsBackup
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilGetNosqlSettingsBackup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilGetNosqlSettingsBackup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []GetNosqlSettingsBackupDayOfWeekItem as json.
func (o OptNilGetNosqlSettingsBackupDayOfWeekItemArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []GetNosqlSettingsBackupDayOfWeekItem from json.
func (o *OptNilGetNosqlSettingsBackupDayOfWeekItemArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilGetNosqlSettingsBackupDayOfWeekItemArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []GetNosqlSettingsBackupDayOfWeekItem
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]GetNosqlSettingsBackupDayOfWeekItem, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem GetNosqlSettingsBackupDayOfWeekItem
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilGetNosqlSettingsBackupDayOfWeekItemArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilGetNosqlSettingsBackupDayOfWeekItemArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNosqlSettingsRepair as json.
func (o OptNilGetNosqlSettingsRepair) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetNosqlSettingsRepair from json.
func (o *OptNilGetNosqlSettingsRepair) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilGetNosqlSettingsRepair to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetNosqlSettingsRepair
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilGetNosqlSettingsRepair) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilGetNosqlSettingsRepair) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InstanceHost as json.
func (o OptNilInstanceHost) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes InstanceHost from json.
func (o *OptNilInstanceHost) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInstanceHost to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v InstanceHost
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInstanceHost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInstanceHost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceDisk as json.
func (o OptNilNosqlApplianceDisk) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlApplianceDisk from json.
func (o *OptNilNosqlApplianceDisk) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNosqlApplianceDisk to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NosqlApplianceDisk
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNosqlApplianceDisk) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNosqlApplianceDisk) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceInterfacesItemSwitchSubnet as json.
func (o OptNilNosqlApplianceInterfacesItemSwitchSubnet) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlApplianceInterfacesItemSwitchSubnet from json.
func (o *OptNilNosqlApplianceInterfacesItemSwitchSubnet) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNosqlApplianceInterfacesItemSwitchSubnet to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NosqlApplianceInterfacesItemSwitchSubnet
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNosqlApplianceInterfacesItemSwitchSubnet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNosqlApplianceInterfacesItemSwitchSubnet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceInterfacesItemSwitchUserSubnet as json.
func (o OptNilNosqlApplianceInterfacesItemSwitchUserSubnet) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlApplianceInterfacesItemSwitchUserSubnet from json.
func (o *OptNilNosqlApplianceInterfacesItemSwitchUserSubnet) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNosqlApplianceInterfacesItemSwitchUserSubnet to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NosqlApplianceInterfacesItemSwitchUserSubnet
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNosqlApplianceInterfacesItemSwitchUserSubnet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNosqlApplianceInterfacesItemSwitchUserSubnet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlCreateRequestApplianceDisk as json.
func (o OptNilNosqlCreateRequestApplianceDisk) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlCreateRequestApplianceDisk from json.
func (o *OptNilNosqlCreateRequestApplianceDisk) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNosqlCreateRequestApplianceDisk to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NosqlCreateRequestApplianceDisk
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNosqlCreateRequestApplianceDisk) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNosqlCreateRequestApplianceDisk) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlCreateRequestApplianceSettingsBackup as json.
func (o OptNilNosqlCreateRequestApplianceSettingsBackup) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlCreateRequestApplianceSettingsBackup from json.
func (o *OptNilNosqlCreateRequestApplianceSettingsBackup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNosqlCreateRequestApplianceSettingsBackup to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NosqlCreateRequestApplianceSettingsBackup
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNosqlCreateRequestApplianceSettingsBackup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNosqlCreateRequestApplianceSettingsBackup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem as json.
func (o OptNilNosqlCreateRequestApplianceSettingsBackupDayOfWeekItemArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem from json.
func (o *OptNilNosqlCreateRequestApplianceSettingsBackupDayOfWeekItemArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNosqlCreateRequestApplianceSettingsBackupDayOfWeekItemArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem NosqlCreateRequestApplianceSettingsBackupDayOfWeekItem
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNosqlCreateRequestApplianceSettingsBackupDayOfWeekItemArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNosqlCreateRequestApplianceSettingsBackupDayOfWeekItemArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlCreateRequestApplianceSettingsRepair as json.
func (o OptNilNosqlCreateRequestApplianceSettingsRepair) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlCreateRequestApplianceSettingsRepair from json.
func (o *OptNilNosqlCreateRequestApplianceSettingsRepair) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNosqlCreateRequestApplianceSettingsRepair to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NosqlCreateRequestApplianceSettingsRepair
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNosqlCreateRequestApplianceSettingsRepair) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNosqlCreateRequestApplianceSettingsRepair) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlSettingsBackup as json.
func (o OptNilNosqlSettingsBackup) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlSettingsBackup from json.
func (o *OptNilNosqlSettingsBackup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNosqlSettingsBackup to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NosqlSettingsBackup
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNosqlSettingsBackup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNosqlSettingsBackup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []NosqlSettingsBackupDayOfWeekItem as json.
func (o OptNilNosqlSettingsBackupDayOfWeekItemArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []NosqlSettingsBackupDayOfWeekItem from json.
func (o *OptNilNosqlSettingsBackupDayOfWeekItemArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNosqlSettingsBackupDayOfWeekItemArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []NosqlSettingsBackupDayOfWeekItem
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]NosqlSettingsBackupDayOfWeekItem, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem NosqlSettingsBackupDayOfWeekItem
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNosqlSettingsBackupDayOfWeekItemArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNosqlSettingsBackupDayOfWeekItemArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlSettingsRepair as json.
func (o OptNilNosqlSettingsRepair) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlSettingsRepair from json.
func (o *OptNilNosqlSettingsRepair) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNosqlSettingsRepair to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NosqlSettingsRepair
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNosqlSettingsRepair) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNosqlSettingsRepair) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlUpdateRequestApplianceSettingsBackup as json.
func (o OptNilNosqlUpdateRequestApplianceSettingsBackup) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlUpdateRequestApplianceSettingsBackup from json.
func (o *OptNilNosqlUpdateRequestApplianceSettingsBackup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNosqlUpdateRequestApplianceSettingsBackup to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NosqlUpdateRequestApplianceSettingsBackup
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNosqlUpdateRequestApplianceSettingsBackup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNosqlUpdateRequestApplianceSettingsBackup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem as json.
func (o OptNilNosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem from json.
func (o *OptNilNosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem NosqlUpdateRequestApplianceSettingsBackupDayOfWeekItem
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNosqlUpdateRequestApplianceSettingsBackupDayOfWeekItemArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlUpdateRequestApplianceSettingsRepair as json.
func (o OptNilNosqlUpdateRequestApplianceSettingsRepair) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlUpdateRequestApplianceSettingsRepair from json.
func (o *OptNilNosqlUpdateRequestApplianceSettingsRepair) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNosqlUpdateRequestApplianceSettingsRepair to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NosqlUpdateRequestApplianceSettingsRepair
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNosqlUpdateRequestApplianceSettingsRepair) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNosqlUpdateRequestApplianceSettingsRepair) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Tags as json.
func (o OptNilTags) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Tags from json.
func (o *OptNilTags) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilTags to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v Tags
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilTags) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilTags) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NodeHealthNosql as json.
func (o OptNodeHealthNosql) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NodeHealthNosql from json.
func (o *OptNodeHealthNosql) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNodeHealthNosql to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNodeHealthNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNodeHealthNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NodeHealthNosqlStatus as json.
func (o OptNodeHealthNosqlStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NodeHealthNosqlStatus from json.
func (o *OptNodeHealthNosqlStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNodeHealthNosqlStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNodeHealthNosqlStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNodeHealthNosqlStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlAppliance as json.
func (o OptNosqlAppliance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlAppliance from json.
func (o *OptNosqlAppliance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlAppliance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlAppliance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlAppliance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceDiskEncryptionKey as json.
func (o OptNosqlApplianceDiskEncryptionKey) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlApplianceDiskEncryptionKey from json.
func (o *OptNosqlApplianceDiskEncryptionKey) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlApplianceDiskEncryptionKey to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlApplianceDiskEncryptionKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlApplianceDiskEncryptionKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceInterfacesItemSwitch as json.
func (o OptNosqlApplianceInterfacesItemSwitch) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlApplianceInterfacesItemSwitch from json.
func (o *OptNosqlApplianceInterfacesItemSwitch) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlApplianceInterfacesItemSwitch to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlApplianceInterfacesItemSwitch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlApplianceInterfacesItemSwitch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceInterfacesItemSwitchSubnetInternet as json.
func (o OptNosqlApplianceInterfacesItemSwitchSubnetInternet) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlApplianceInterfacesItemSwitchSubnetInternet from json.
func (o *OptNosqlApplianceInterfacesItemSwitchSubnetInternet) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlApplianceInterfacesItemSwitchSubnetInternet to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlApplianceInterfacesItemSwitchSubnetInternet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlApplianceInterfacesItemSwitchSubnetInternet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceRemark as json.
func (o OptNosqlApplianceRemark) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlApplianceRemark from json.
func (o *OptNosqlApplianceRemark) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlApplianceRemark to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlApplianceRemark) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlApplianceRemark) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceRemarkNosqlDatabaseEngine as json.
func (o OptNosqlApplianceRemarkNosqlDatabaseEngine) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NosqlApplianceRemarkNosqlDatabaseEngine from json.
func (o *OptNosqlApplianceRemarkNosqlDatabaseEngine) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlApplianceRemarkNosqlDatabaseEngine to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlApplianceRemarkNosqlDatabaseEngine) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlApplianceRemarkNosqlDatabaseEngine) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceRemarkNosqlDiskSize as json.
func (o OptNosqlApplianceRemarkNosqlDiskSize) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes NosqlApplianceRemarkNosqlDiskSize from json.
func (o *OptNosqlApplianceRemarkNosqlDiskSize) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlApplianceRemarkNosqlDiskSize to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlApplianceRemarkNosqlDiskSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlApplianceRemarkNosqlDiskSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceRemarkNosqlMemory as json.
func (o OptNosqlApplianceRemarkNosqlMemory) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes NosqlApplianceRemarkNosqlMemory from json.
func (o *OptNosqlApplianceRemarkNosqlMemory) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlApplianceRemarkNosqlMemory to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlApplianceRemarkNosqlMemory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlApplianceRemarkNosqlMemory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceRemarkNosqlPrimaryNodes as json.
func (o OptNosqlApplianceRemarkNosqlPrimaryNodes) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlApplianceRemarkNosqlPrimaryNodes from json.
func (o *OptNosqlApplianceRemarkNosqlPrimaryNodes) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlApplianceRemarkNosqlPrimaryNodes to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlApplianceRemarkNosqlPrimaryNodes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlApplianceRemarkNosqlPrimaryNodes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceRemarkNosqlStorage as json.
func (o OptNosqlApplianceRemarkNosqlStorage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NosqlApplianceRemarkNosqlStorage from json.
func (o *OptNosqlApplianceRemarkNosqlStorage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlApplianceRemarkNosqlStorage to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlApplianceRemarkNosqlStorage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlApplianceRemarkNosqlStorage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceRemarkNosqlVirtualcore as json.
func (o OptNosqlApplianceRemarkNosqlVirtualcore) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes NosqlApplianceRemarkNosqlVirtualcore from json.
func (o *OptNosqlApplianceRemarkNosqlVirtualcore) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlApplianceRemarkNosqlVirtualcore to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlApplianceRemarkNosqlVirtualcore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlApplianceRemarkNosqlVirtualcore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlApplianceRemarkZone as json.
func (o OptNosqlApplianceRemarkZone) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlApplianceRemarkZone from json.
func (o *OptNosqlApplianceRemarkZone) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlApplianceRemarkZone to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlApplianceRemarkZone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlApplianceRemarkZone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlBackupResponseNosql as json.
func (o OptNosqlBackupResponseNosql) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlBackupResponseNosql from json.
func (o *OptNosqlBackupResponseNosql) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlBackupResponseNosql to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlBackupResponseNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlBackupResponseNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlCreateRequestApplianceDiskEncryptionKey as json.
func (o OptNosqlCreateRequestApplianceDiskEncryptionKey) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlCreateRequestApplianceDiskEncryptionKey from json.
func (o *OptNosqlCreateRequestApplianceDiskEncryptionKey) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlCreateRequestApplianceDiskEncryptionKey to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlCreateRequestApplianceDiskEncryptionKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlCreateRequestApplianceDiskEncryptionKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlCreateRequestApplianceSettings as json.
func (o OptNosqlCreateRequestApplianceSettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlCreateRequestApplianceSettings from json.
func (o *OptNosqlCreateRequestApplianceSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlCreateRequestApplianceSettings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlCreateRequestApplianceSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlCreateRequestApplianceSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlCreateRequestApplianceSettingsRepairFull as json.
func (o OptNosqlCreateRequestApplianceSettingsRepairFull) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlCreateRequestApplianceSettingsRepairFull from json.
func (o *OptNosqlCreateRequestApplianceSettingsRepairFull) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlCreateRequestApplianceSettingsRepairFull to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlCreateRequestApplianceSettingsRepairFull) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlCreateRequestApplianceSettingsRepairFull) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlCreateRequestApplianceSettingsRepairIncremental as json.
func (o OptNosqlCreateRequestApplianceSettingsRepairIncremental) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlCreateRequestApplianceSettingsRepairIncremental from json.
func (o *OptNosqlCreateRequestApplianceSettingsRepairIncremental) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlCreateRequestApplianceSettingsRepairIncremental to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlCreateRequestApplianceSettingsRepairIncremental) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlCreateRequestApplianceSettingsRepairIncremental) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlCreateRequestApplianceUserInterfacesItemUserSubnet as json.
func (o OptNosqlCreateRequestApplianceUserInterfacesItemUserSubnet) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlCreateRequestApplianceUserInterfacesItemUserSubnet from json.
func (o *OptNosqlCreateRequestApplianceUserInterfacesItemUserSubnet) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlCreateRequestApplianceUserInterfacesItemUserSubnet to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlCreateRequestApplianceUserInterfacesItemUserSubnet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlCreateRequestApplianceUserInterfacesItemUserSubnet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlCreateResponseAccount as json.
func (o OptNosqlCreateResponseAccount) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlCreateResponseAccount from json.
func (o *OptNosqlCreateResponseAccount) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlCreateResponseAccount to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlCreateResponseAccount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlCreateResponseAccount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlCreateResponseHiddenRemark as json.
func (o OptNosqlCreateResponseHiddenRemark) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlCreateResponseHiddenRemark from json.
func (o *OptNosqlCreateResponseHiddenRemark) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlCreateResponseHiddenRemark to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlCreateResponseHiddenRemark) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlCreateResponseHiddenRemark) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlCreateResponseHiddenRemarkEncrypted as json.
func (o OptNosqlCreateResponseHiddenRemarkEncrypted) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlCreateResponseHiddenRemarkEncrypted from json.
func (o *OptNosqlCreateResponseHiddenRemarkEncrypted) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlCreateResponseHiddenRemarkEncrypted to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlCreateResponseHiddenRemarkEncrypted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlCreateResponseHiddenRemarkEncrypted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlCreateResponseHiddenRemarkPlanSpec as json.
func (o OptNosqlCreateResponseHiddenRemarkPlanSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlCreateResponseHiddenRemarkPlanSpec from json.
func (o *OptNosqlCreateResponseHiddenRemarkPlanSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlCreateResponseHiddenRemarkPlanSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlCreateResponseHiddenRemarkPlanSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlCreateResponseHiddenRemarkPlanSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlCreateResponseHiddenRemarkPlanSpecNote as json.
func (o OptNosqlCreateResponseHiddenRemarkPlanSpecNote) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlCreateResponseHiddenRemarkPlanSpecNote from json.
func (o *OptNosqlCreateResponseHiddenRemarkPlanSpecNote) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlCreateResponseHiddenRemarkPlanSpecNote to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlCreateResponseHiddenRemarkPlanSpecNote) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlCreateResponseHiddenRemarkPlanSpecNote) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlGetVersionResponseNosql as json.
func (o OptNosqlGetVersionResponseNosql) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlGetVersionResponseNosql from json.
func (o *OptNosqlGetVersionResponseNosql) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlGetVersionResponseNosql to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlGetVersionResponseNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlGetVersionResponseNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlIsOkResponseNosql as json.
func (o OptNosqlIsOkResponseNosql) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlIsOkResponseNosql from json.
func (o *OptNosqlIsOkResponseNosql) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlIsOkResponseNosql to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlIsOkResponseNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlIsOkResponseNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlNodeAppliance as json.
func (o OptNosqlNodeAppliance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlNodeAppliance from json.
func (o *OptNosqlNodeAppliance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlNodeAppliance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlNodeAppliance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlNodeAppliance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlNodeApplianceZone as json.
func (o OptNosqlNodeApplianceZone) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlNodeApplianceZone from json.
func (o *OptNosqlNodeApplianceZone) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlNodeApplianceZone to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlNodeApplianceZone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlNodeApplianceZone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlOkResponseNosql as json.
func (o OptNosqlOkResponseNosql) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlOkResponseNosql from json.
func (o *OptNosqlOkResponseNosql) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlOkResponseNosql to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlOkResponseNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlOkResponseNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlRemark as json.
func (o OptNosqlRemark) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlRemark from json.
func (o *OptNosqlRemark) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlRemark to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlRemark) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlRemark) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlRemarkNosqlDatabaseEngine as json.
func (o OptNosqlRemarkNosqlDatabaseEngine) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NosqlRemarkNosqlDatabaseEngine from json.
func (o *OptNosqlRemarkNosqlDatabaseEngine) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlRemarkNosqlDatabaseEngine to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlRemarkNosqlDatabaseEngine) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlRemarkNosqlDatabaseEngine) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlRemarkNosqlDiskSize as json.
func (o OptNosqlRemarkNosqlDiskSize) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes NosqlRemarkNosqlDiskSize from json.
func (o *OptNosqlRemarkNosqlDiskSize) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlRemarkNosqlDiskSize to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlRemarkNosqlDiskSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlRemarkNosqlDiskSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlRemarkNosqlMemory as json.
func (o OptNosqlRemarkNosqlMemory) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes NosqlRemarkNosqlMemory from json.
func (o *OptNosqlRemarkNosqlMemory) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlRemarkNosqlMemory to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlRemarkNosqlMemory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlRemarkNosqlMemory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlRemarkNosqlPrimaryNodes as json.
func (o OptNosqlRemarkNosqlPrimaryNodes) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlRemarkNosqlPrimaryNodes from json.
func (o *OptNosqlRemarkNosqlPrimaryNodes) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlRemarkNosqlPrimaryNodes to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlRemarkNosqlPrimaryNodes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlRemarkNosqlPrimaryNodes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlRemarkNosqlStorage as json.
func (o OptNosqlRemarkNosqlStorage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NosqlRemarkNosqlStorage from json.
func (o *OptNosqlRemarkNosqlStorage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlRemarkNosqlStorage to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlRemarkNosqlStorage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlRemarkNosqlStorage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlRemarkNosqlVirtualcore as json.
func (o OptNosqlRemarkNosqlVirtualcore) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes NosqlRemarkNosqlVirtualcore from json.
func (o *OptNosqlRemarkNosqlVirtualcore) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlRemarkNosqlVirtualcore to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlRemarkNosqlVirtualcore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlRemarkNosqlVirtualcore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlRepairRequestNosql as json.
func (o OptNosqlRepairRequestNosql) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlRepairRequestNosql from json.
func (o *OptNosqlRepairRequestNosql) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlRepairRequestNosql to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlRepairRequestNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlRepairRequestNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlRepairRequestNosqlRepairType as json.
func (o OptNosqlRepairRequestNosqlRepairType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NosqlRepairRequestNosqlRepairType from json.
func (o *OptNosqlRepairRequestNosqlRepairType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlRepairRequestNosqlRepairType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlRepairRequestNosqlRepairType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlRepairRequestNosqlRepairType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlSettings as json.
func (o OptNosqlSettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlSettings from json.
func (o *OptNosqlSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlSettings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlSettingsRepairFull as json.
func (o OptNosqlSettingsRepairFull) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlSettingsRepairFull from json.
func (o *OptNosqlSettingsRepairFull) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlSettingsRepairFull to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlSettingsRepairFull) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlSettingsRepairFull) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlSettingsRepairIncremental as json.
func (o OptNosqlSettingsRepairIncremental) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlSettingsRepairIncremental from json.
func (o *OptNosqlSettingsRepairIncremental) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlSettingsRepairIncremental to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlSettingsRepairIncremental) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlSettingsRepairIncremental) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlStatusResponseAppliance as json.
func (o OptNosqlStatusResponseAppliance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlStatusResponseAppliance from json.
func (o *OptNosqlStatusResponseAppliance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlStatusResponseAppliance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlStatusResponseAppliance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlStatusResponseAppliance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlStatusResponseApplianceSettingsResponse as json.
func (o OptNosqlStatusResponseApplianceSettingsResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlStatusResponseApplianceSettingsResponse from json.
func (o *OptNosqlStatusResponseApplianceSettingsResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlStatusResponseApplianceSettingsResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlStatusResponseApplianceSettingsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlStatusResponseApplianceSettingsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlStatusResponseApplianceSettingsResponseNosql as json.
func (o OptNosqlStatusResponseApplianceSettingsResponseNosql) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlStatusResponseApplianceSettingsResponseNosql from json.
func (o *OptNosqlStatusResponseApplianceSettingsResponseNosql) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlStatusResponseApplianceSettingsResponseNosql to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlStatusResponseApplianceSettingsResponseNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlStatusResponseApplianceSettingsResponseNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlStatusResponseApplianceSettingsResponseNosqlPrimaryNodes as json.
func (o OptNosqlStatusResponseApplianceSettingsResponseNosqlPrimaryNodes) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlStatusResponseApplianceSettingsResponseNosqlPrimaryNodes from json.
func (o *OptNosqlStatusResponseApplianceSettingsResponseNosqlPrimaryNodes) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlStatusResponseApplianceSettingsResponseNosqlPrimaryNodes to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlStatusResponseApplianceSettingsResponseNosqlPrimaryNodes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlStatusResponseApplianceSettingsResponseNosqlPrimaryNodes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlUpdateRequestApplianceSettingsRepairFull as json.
func (o OptNosqlUpdateRequestApplianceSettingsRepairFull) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlUpdateRequestApplianceSettingsRepairFull from json.
func (o *OptNosqlUpdateRequestApplianceSettingsRepairFull) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlUpdateRequestApplianceSettingsRepairFull to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlUpdateRequestApplianceSettingsRepairFull) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlUpdateRequestApplianceSettingsRepairFull) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlUpdateRequestApplianceSettingsRepairIncremental as json.
func (o OptNosqlUpdateRequestApplianceSettingsRepairIncremental) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlUpdateRequestApplianceSettingsRepairIncremental from json.
func (o *OptNosqlUpdateRequestApplianceSettingsRepairIncremental) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlUpdateRequestApplianceSettingsRepairIncremental to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlUpdateRequestApplianceSettingsRepairIncremental) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlUpdateRequestApplianceSettingsRepairIncremental) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqlVersion as json.
func (o OptNosqlVersion) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NosqlVersion from json.
func (o *OptNosqlVersion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqlVersion to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqlVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqlVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NosqldbNodeStatusNodeType as json.
func (o OptNosqldbNodeStatusNodeType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NosqldbNodeStatusNodeType from json.
func (o *OptNosqldbNodeStatusNodeType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNosqldbNodeStatusNodeType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNosqldbNodeStatusNodeType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNosqldbNodeStatusNodeType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Password as json.
func (o OptPassword) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Password from json.
func (o *OptPassword) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPassword to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPassword) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPassword) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Plan as json.
func (o OptPlan) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Plan from json.
func (o *OptPlan) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPlan to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPlan) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPlan) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PutParameterResponseNosql as json.
func (o OptPutParameterResponseNosql) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PutParameterResponseNosql from json.
func (o *OptPutParameterResponseNosql) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPutParameterResponseNosql to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPutParameterResponseNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPutParameterResponseNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ServiceClass as json.
func (o OptServiceClass) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ServiceClass from json.
func (o *OptServiceClass) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptServiceClass to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptServiceClass) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptServiceClass) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Success as json.
func (o OptSuccess) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Success from json.
func (o *OptSuccess) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSuccess to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Password as json.
func (s Password) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes Password from json.
func (s *Password) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Password to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Password(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Password) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Password) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Plan) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Plan) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("ID")
			s.ID.Encode(e)
		}
	}
}

var jsonFieldsNameOfPlan = [1]string{
	0: "ID",
}

// Decode decodes Plan from json.
func (s *Plan) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Plan to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ID":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Plan")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Plan) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Plan) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PutParameterRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PutParameterRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nosql")
		s.Nosql.Encode(e)
	}
}

var jsonFieldsNameOfPutParameterRequest = [1]string{
	0: "nosql",
}

// Decode decodes PutParameterRequest from json.
func (s *PutParameterRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PutParameterRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nosql":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Nosql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nosql\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PutParameterRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPutParameterRequest) {
					name = jsonFieldsNameOfPutParameterRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PutParameterRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PutParameterRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PutParameterRequestNosql) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PutParameterRequestNosql) encodeFields(e *jx.Encoder) {
	{
		if s.Parameters != nil {
			e.FieldStart("parameters")
			e.ArrStart()
			for _, elem := range s.Parameters {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPutParameterRequestNosql = [1]string{
	0: "parameters",
}

// Decode decodes PutParameterRequestNosql from json.
func (s *PutParameterRequestNosql) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PutParameterRequestNosql to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "parameters":
			if err := func() error {
				s.Parameters = make([]NosqlPutParameter, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NosqlPutParameter
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Parameters = append(s.Parameters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PutParameterRequestNosql")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PutParameterRequestNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PutParameterRequestNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PutParameterResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PutParameterResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Nosql.Set {
			e.FieldStart("nosql")
			s.Nosql.Encode(e)
		}
	}
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfPutParameterResponse = [2]string{
	0: "nosql",
	1: "is_ok",
}

// Decode decodes PutParameterResponse from json.
func (s *PutParameterResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PutParameterResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nosql":
			if err := func() error {
				s.Nosql.Reset()
				if err := s.Nosql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nosql\"")
			}
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PutParameterResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PutParameterResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PutParameterResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PutParameterResponseNosql) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PutParameterResponseNosql) encodeFields(e *jx.Encoder) {
	{
		if s.Parameters != nil {
			e.FieldStart("parameters")
			e.ArrStart()
			for _, elem := range s.Parameters {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPutParameterResponseNosql = [1]string{
	0: "parameters",
}

// Decode decodes PutParameterResponseNosql from json.
func (s *PutParameterResponseNosql) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PutParameterResponseNosql to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "parameters":
			if err := func() error {
				s.Parameters = make([]NosqlPutParameter, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NosqlPutParameter
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Parameters = append(s.Parameters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PutParameterResponseNosql")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PutParameterResponseNosql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PutParameterResponseNosql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecoverNoSQLNodeAccepted as json.
func (s *RecoverNoSQLNodeAccepted) Encode(e *jx.Encoder) {
	unwrapped := (*SuccessResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes RecoverNoSQLNodeAccepted from json.
func (s *RecoverNoSQLNodeAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecoverNoSQLNodeAccepted to nil")
	}
	var unwrapped SuccessResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RecoverNoSQLNodeAccepted(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecoverNoSQLNodeAccepted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecoverNoSQLNodeAccepted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecoverNoSQLNodeOK as json.
func (s *RecoverNoSQLNodeOK) Encode(e *jx.Encoder) {
	unwrapped := (*SuccessResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes RecoverNoSQLNodeOK from json.
func (s *RecoverNoSQLNodeOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecoverNoSQLNodeOK to nil")
	}
	var unwrapped SuccessResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RecoverNoSQLNodeOK(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecoverNoSQLNodeOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecoverNoSQLNodeOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ServerErrorResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ServerErrorResponse) encodeFields(e *jx.Encoder) {
	{
		if s.IsFatal.Set {
			e.FieldStart("is_fatal")
			s.IsFatal.Encode(e)
		}
	}
	{
		if s.Serial.Set {
			e.FieldStart("serial")
			s.Serial.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("error_code")
			s.ErrorCode.Encode(e)
		}
	}
	{
		if s.ErrorMsg.Set {
			e.FieldStart("error_msg")
			s.ErrorMsg.Encode(e)
		}
	}
}

var jsonFieldsNameOfServerErrorResponse = [5]string{
	0: "is_fatal",
	1: "serial",
	2: "status",
	3: "error_code",
	4: "error_msg",
}

// Decode decodes ServerErrorResponse from json.
func (s *ServerErrorResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServerErrorResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "is_fatal":
			if err := func() error {
				s.IsFatal.Reset()
				if err := s.IsFatal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_fatal\"")
			}
		case "serial":
			if err := func() error {
				s.Serial.Reset()
				if err := s.Serial.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serial\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "error_code":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_code\"")
			}
		case "error_msg":
			if err := func() error {
				s.ErrorMsg.Reset()
				if err := s.ErrorMsg.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_msg\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServerErrorResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ServerErrorResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServerErrorResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ServiceClass as json.
func (s ServiceClass) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes ServiceClass from json.
func (s *ServiceClass) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServiceClass to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ServiceClass(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ServiceClass) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServiceClass) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Success as json.
func (s Success) Encode(e *jx.Encoder) {
	switch s.Type {
	case BoolSuccess:
		e.Bool(s.Bool)
	case StringSuccess:
		e.Str(s.String)
	}
}

// Decode decodes Success from json.
func (s *Success) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Success to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolSuccess
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringSuccess
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Success) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Success) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Success.Set {
			e.FieldStart("Success")
			s.Success.Encode(e)
		}
	}
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessResponse = [2]string{
	0: "Success",
	1: "is_ok",
}

// Decode decodes SuccessResponse from json.
func (s *SuccessResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Success":
			if err := func() error {
				s.Success.Reset()
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Success\"")
			}
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Tags as json.
func (s Tags) Encode(e *jx.Encoder) {
	unwrapped := []string(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes Tags from json.
func (s *Tags) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Tags to nil")
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Tags(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Tags) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Tags) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnauthorizedResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnauthorizedResponse) encodeFields(e *jx.Encoder) {
	{
		if s.IsFatal.Set {
			e.FieldStart("is_fatal")
			s.IsFatal.Encode(e)
		}
	}
	{
		if s.Serial.Set {
			e.FieldStart("serial")
			s.Serial.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("error_code")
			s.ErrorCode.Encode(e)
		}
	}
	{
		if s.ErrorMsg.Set {
			e.FieldStart("error_msg")
			s.ErrorMsg.Encode(e)
		}
	}
}

var jsonFieldsNameOfUnauthorizedResponse = [5]string{
	0: "is_fatal",
	1: "serial",
	2: "status",
	3: "error_code",
	4: "error_msg",
}

// Decode decodes UnauthorizedResponse from json.
func (s *UnauthorizedResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnauthorizedResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "is_fatal":
			if err := func() error {
				s.IsFatal.Reset()
				if err := s.IsFatal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_fatal\"")
			}
		case "serial":
			if err := func() error {
				s.Serial.Reset()
				if err := s.Serial.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serial\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "error_code":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_code\"")
			}
		case "error_msg":
			if err := func() error {
				s.ErrorMsg.Reset()
				if err := s.ErrorMsg.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_msg\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnauthorizedResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnauthorizedResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnauthorizedResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
